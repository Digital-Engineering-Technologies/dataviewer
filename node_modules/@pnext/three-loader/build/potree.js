!function(g,I){"object"==typeof exports&&"object"==typeof module?module.exports=I(require("three")):"function"==typeof define&&define.amd?define("potree",["three"],I):"object"==typeof exports?exports.potree=I(require("three")):g.potree=I(g.three)}(self,(__WEBPACK_EXTERNAL_MODULE__604__=>(()=>{"use strict";var __webpack_modules__={414:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("precision highp float;\\nprecision highp int;\\n\\nuniform mat4 projectionMatrix;\\n\\nuniform float screenWidth;\\nuniform float screenHeight;\\n\\nuniform sampler2D map;\\n\\nvarying vec2 vUv;\\n\\nvoid main() {\\n\\n\\tfloat dx = 1.0 / screenWidth;\\n\\tfloat dy = 1.0 / screenHeight;\\n\\n\\tvec3 color = vec3(0.0, 0.0, 0.0);\\n\\tcolor += texture2D(map, vUv + vec2(-dx, -dy)).rgb;\\n\\tcolor += texture2D(map, vUv + vec2(  0, -dy)).rgb;\\n\\tcolor += texture2D(map, vUv + vec2(+dx, -dy)).rgb;\\n\\tcolor += texture2D(map, vUv + vec2(-dx,   0)).rgb;\\n\\tcolor += texture2D(map, vUv + vec2(  0,   0)).rgb;\\n\\tcolor += texture2D(map, vUv + vec2(+dx,   0)).rgb;\\n\\tcolor += texture2D(map, vUv + vec2(-dx,  dy)).rgb;\\n\\tcolor += texture2D(map, vUv + vec2(  0,  dy)).rgb;\\n\\tcolor += texture2D(map, vUv + vec2(+dx,  dy)).rgb;\\n    \\n\\tcolor = color / 9.0;\\n\\t\\n\\tgl_FragColor = vec4(color, 1.0);\\n\\t\\n\\t\\n}");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDE0LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL3BvdHJlZS8uL3NyYy9tYXRlcmlhbHMvc2hhZGVycy9ibHVyLmZyYWc/MjI5MyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5wcmVjaXNpb24gaGlnaHAgaW50O1xcblxcbnVuaWZvcm0gbWF0NCBwcm9qZWN0aW9uTWF0cml4O1xcblxcbnVuaWZvcm0gZmxvYXQgc2NyZWVuV2lkdGg7XFxudW5pZm9ybSBmbG9hdCBzY3JlZW5IZWlnaHQ7XFxuXFxudW5pZm9ybSBzYW1wbGVyMkQgbWFwO1xcblxcbnZhcnlpbmcgdmVjMiB2VXY7XFxuXFxudm9pZCBtYWluKCkge1xcblxcblxcdGZsb2F0IGR4ID0gMS4wIC8gc2NyZWVuV2lkdGg7XFxuXFx0ZmxvYXQgZHkgPSAxLjAgLyBzY3JlZW5IZWlnaHQ7XFxuXFxuXFx0dmVjMyBjb2xvciA9IHZlYzMoMC4wLCAwLjAsIDAuMCk7XFxuXFx0Y29sb3IgKz0gdGV4dHVyZTJEKG1hcCwgdlV2ICsgdmVjMigtZHgsIC1keSkpLnJnYjtcXG5cXHRjb2xvciArPSB0ZXh0dXJlMkQobWFwLCB2VXYgKyB2ZWMyKCAgMCwgLWR5KSkucmdiO1xcblxcdGNvbG9yICs9IHRleHR1cmUyRChtYXAsIHZVdiArIHZlYzIoK2R4LCAtZHkpKS5yZ2I7XFxuXFx0Y29sb3IgKz0gdGV4dHVyZTJEKG1hcCwgdlV2ICsgdmVjMigtZHgsICAgMCkpLnJnYjtcXG5cXHRjb2xvciArPSB0ZXh0dXJlMkQobWFwLCB2VXYgKyB2ZWMyKCAgMCwgICAwKSkucmdiO1xcblxcdGNvbG9yICs9IHRleHR1cmUyRChtYXAsIHZVdiArIHZlYzIoK2R4LCAgIDApKS5yZ2I7XFxuXFx0Y29sb3IgKz0gdGV4dHVyZTJEKG1hcCwgdlV2ICsgdmVjMigtZHgsICBkeSkpLnJnYjtcXG5cXHRjb2xvciArPSB0ZXh0dXJlMkQobWFwLCB2VXYgKyB2ZWMyKCAgMCwgIGR5KSkucmdiO1xcblxcdGNvbG9yICs9IHRleHR1cmUyRChtYXAsIHZVdiArIHZlYzIoK2R4LCAgZHkpKS5yZ2I7XFxuICAgIFxcblxcdGNvbG9yID0gY29sb3IgLyA5LjA7XFxuXFx0XFxuXFx0Z2xfRnJhZ0NvbG9yID0gdmVjNChjb2xvciwgMS4wKTtcXG5cXHRcXG5cXHRcXG59XCI7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///414\n')},575:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("precision highp float;\\nprecision highp int;\\n\\nattribute vec3 position;\\nattribute vec2 uv;\\n\\nuniform mat4 modelViewMatrix;\\nuniform mat4 projectionMatrix;\\n\\nvarying vec2 vUv;\\n\\nvoid main() {\\n    vUv = uv;\\n\\n    gl_Position =   projectionMatrix * modelViewMatrix * vec4(position, 1.0);\\n}");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTc1LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL3BvdHJlZS8uL3NyYy9tYXRlcmlhbHMvc2hhZGVycy9ibHVyLnZlcnQ/NWRiYyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5wcmVjaXNpb24gaGlnaHAgaW50O1xcblxcbmF0dHJpYnV0ZSB2ZWMzIHBvc2l0aW9uO1xcbmF0dHJpYnV0ZSB2ZWMyIHV2O1xcblxcbnVuaWZvcm0gbWF0NCBtb2RlbFZpZXdNYXRyaXg7XFxudW5pZm9ybSBtYXQ0IHByb2plY3Rpb25NYXRyaXg7XFxuXFxudmFyeWluZyB2ZWMyIHZVdjtcXG5cXG52b2lkIG1haW4oKSB7XFxuICAgIHZVdiA9IHV2O1xcblxcbiAgICBnbF9Qb3NpdGlvbiA9ICAgcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQocG9zaXRpb24sIDEuMCk7XFxufVwiOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///575\n')},168:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("precision highp float;\\nprecision highp int;\\n\\n#if defined paraboloid_point_shape\\n\\t#extension GL_EXT_frag_depth : enable\\n#endif\\n\\nuniform mat4 viewMatrix;\\nuniform vec3 cameraPosition;\\n\\nuniform mat4 projectionMatrix;\\nuniform float opacity;\\n\\nuniform float blendHardness;\\nuniform float blendDepthSupplement;\\nuniform float fov;\\nuniform float spacing;\\nuniform float pcIndex;\\nuniform float screenWidth;\\nuniform float screenHeight;\\n\\nuniform sampler2D depthMap;\\n\\n#if defined (clip_horizontally) || defined (clip_vertically)\\n\\tuniform vec4 clipExtent;\\n#endif\\n\\n#ifdef use_texture_blending\\n\\tuniform sampler2D backgroundMap;\\n#endif\\n\\n\\n#ifdef use_point_cloud_mixing\\n\\tuniform int pointCloudMixingMode;\\n\\tuniform float pointCloudID;\\n\\tuniform float pointCloudMixAngle;\\n\\tuniform float stripeDistanceX;\\n\\tuniform float stripeDistanceY;\\n\\n\\tuniform float stripeDivisorX;\\n\\tuniform float stripeDivisorY;\\n#endif\\n\\n#ifdef highlight_point\\n\\tuniform vec4 highlightedPointColor;\\n#endif\\n\\nvarying vec3 vColor;\\n\\n#if !defined(color_type_point_index)\\n\\tvarying float vOpacity;\\n#endif\\n\\n#if defined(weighted_splats)\\n\\tvarying float vLinearDepth;\\n#endif\\n\\n#if !defined(paraboloid_point_shape) && defined(use_edl)\\n\\tvarying float vLogDepth;\\n#endif\\n\\n#if defined(color_type_phong) && (MAX_POINT_LIGHTS > 0 || MAX_DIR_LIGHTS > 0) || defined(paraboloid_point_shape)\\n\\tvarying vec3 vViewPosition;\\n#endif\\n\\n#if defined(weighted_splats) || defined(paraboloid_point_shape)\\n\\tvarying float vRadius;\\n#endif\\n\\n#if defined(color_type_phong) && (MAX_POINT_LIGHTS > 0 || MAX_DIR_LIGHTS > 0)\\n\\tvarying vec3 vNormal;\\n#endif\\n\\n#ifdef highlight_point\\n\\tvarying float vHighlight;\\n#endif\\n\\nfloat specularStrength = 1.0;\\n\\nvoid main() {\\n\\tvec3 color = vColor;\\n\\tfloat depth = gl_FragCoord.z;\\n\\n\\t#if defined (clip_horizontally) || defined (clip_vertically)\\n\\tvec2 ndc = vec2((gl_FragCoord.x / screenWidth), 1.0 - (gl_FragCoord.y / screenHeight));\\n\\n\\tif(step(clipExtent.x, ndc.x) * step(ndc.x, clipExtent.z) < 1.0)\\n\\t{\\n\\t\\tdiscard;\\n\\t}\\n\\n\\tif(step(clipExtent.y, ndc.y) * step(ndc.y, clipExtent.w) < 1.0)\\n\\t{\\n\\t\\tdiscard;\\n\\t}\\n\\t#endif  \\n\\n\\t#if defined(circle_point_shape) || defined(paraboloid_point_shape) || defined (weighted_splats)\\n\\t\\tfloat u = 2.0 * gl_PointCoord.x - 1.0;\\n\\t\\tfloat v = 2.0 * gl_PointCoord.y - 1.0;\\n\\t#endif\\n\\n\\t#if defined(circle_point_shape) || defined (weighted_splats)\\n\\t\\tfloat cc = u*u + v*v;\\n\\t\\tif(cc > 1.0){\\n\\t\\t\\tdiscard;\\n\\t\\t}\\n\\t#endif\\n\\n\\t#if defined weighted_splats\\n\\t\\tvec2 uv = gl_FragCoord.xy / vec2(screenWidth, screenHeight);\\n\\t\\tfloat sDepth = texture2D(depthMap, uv).r;\\n\\t\\tif(vLinearDepth > sDepth + vRadius + blendDepthSupplement){\\n\\t\\t\\tdiscard;\\n\\t\\t}\\n\\t#endif\\n\\n\\t#if defined color_type_point_index\\n\\t\\tgl_FragColor = vec4(color, pcIndex / 255.0);\\n\\t#else\\n\\t\\tgl_FragColor = vec4(color, vOpacity);\\n\\t#endif\\n\\n\\t#ifdef use_point_cloud_mixing\\n\\t\\tbool discardFragment = false;\\n\\n\\t\\tif (pointCloudMixingMode == 1) {  // Checkboard\\n\\t\\t\\tfloat vPointCloudID = pointCloudID > 10. ? pointCloudID/10.: pointCloudID;\\n\\t\\t\\tdiscardFragment = mod(gl_FragCoord.x, vPointCloudID) > 0.5 && mod(gl_FragCoord.y, vPointCloudID) > 0.5;\\n\\t\\t}\\n\\t\\telse if (pointCloudMixingMode == 2) {  // Stripes\\n\\t\\t\\tfloat angle = pointCloudMixAngle * pointCloudID / 180.;\\n\\t\\t\\tfloat u = cos(angle) * gl_FragCoord.x + sin(angle) * gl_FragCoord.y;\\n\\t\\t\\tfloat v = -sin(angle) * gl_FragCoord.x + cos(angle) * gl_FragCoord.y;\\n\\n\\t\\t\\tdiscardFragment = mod(u, stripeDistanceX) >= stripeDistanceX/stripeDivisorX && mod(v, stripeDistanceY) >= stripeDistanceY/stripeDivisorY;\\n\\t\\t}\\n\\t\\tif (discardFragment) {\\n\\t\\t\\tdiscard;\\n\\t\\t}\\n\\t#endif\\n\\n\\t#ifdef use_texture_blending\\n\\t\\tvec2 vUv = gl_FragCoord.xy / vec2(screenWidth, screenHeight);\\n\\n\\t\\tvec4 tColor = texture2D(backgroundMap, vUv);\\n\\t\\tgl_FragColor = vec4(vOpacity * color, 1.) + vec4((1. - vOpacity) * tColor.rgb, 0.);\\n\\t#endif\\n\\n\\t#if defined(color_type_phong)\\n\\t\\t#if MAX_POINT_LIGHTS > 0 || MAX_DIR_LIGHTS > 0\\n\\t\\t\\tvec3 normal = normalize( vNormal );\\n\\t\\t\\tnormal.z = abs(normal.z);\\n\\n\\t\\t\\tvec3 viewPosition = normalize( vViewPosition );\\n\\t\\t#endif\\n\\n\\t\\t// code taken from three.js phong light fragment shader\\n\\n\\t\\t#if MAX_POINT_LIGHTS > 0\\n\\n\\t\\t\\tvec3 pointDiffuse = vec3( 0.0 );\\n\\t\\t\\tvec3 pointSpecular = vec3( 0.0 );\\n\\n\\t\\t\\tfor ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\\n\\n\\t\\t\\t\\tvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\\n\\t\\t\\t\\tvec3 lVector = lPosition.xyz + vViewPosition.xyz;\\n\\n\\t\\t\\t\\tfloat lDistance = 1.0;\\n\\t\\t\\t\\tif ( pointLightDistance[ i ] > 0.0 )\\n\\t\\t\\t\\t\\tlDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\\n\\n\\t\\t\\t\\tlVector = normalize( lVector );\\n\\n\\t\\t\\t\\t\\t\\t// diffuse\\n\\n\\t\\t\\t\\tfloat dotProduct = dot( normal, lVector );\\n\\n\\t\\t\\t\\t#ifdef WRAP_AROUND\\n\\n\\t\\t\\t\\t\\tfloat pointDiffuseWeightFull = max( dotProduct, 0.0 );\\n\\t\\t\\t\\t\\tfloat pointDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\\n\\n\\t\\t\\t\\t\\tvec3 pointDiffuseWeight = mix( vec3( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\\n\\n\\t\\t\\t\\t#else\\n\\n\\t\\t\\t\\t\\tfloat pointDiffuseWeight = max( dotProduct, 0.0 );\\n\\n\\t\\t\\t\\t#endif\\n\\n\\t\\t\\t\\tpointDiffuse += diffuse * pointLightColor[ i ] * pointDiffuseWeight * lDistance;\\n\\n\\t\\t\\t\\t// specular\\n\\n\\t\\t\\t\\tvec3 pointHalfVector = normalize( lVector + viewPosition );\\n\\t\\t\\t\\tfloat pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\\n\\t\\t\\t\\tfloat pointSpecularWeight = specularStrength * max( pow( pointDotNormalHalf, shininess ), 0.0 );\\n\\n\\t\\t\\t\\tfloat specularNormalization = ( shininess + 2.0 ) / 8.0;\\n\\n\\t\\t\\t\\tvec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, pointHalfVector ), 0.0 ), 5.0 );\\n\\t\\t\\t\\tpointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance * specularNormalization;\\n\\t\\t\\t\\tpointSpecular = vec3(0.0, 0.0, 0.0);\\n\\t\\t\\t}\\n\\n\\t\\t#endif\\n\\n\\t\\t#if MAX_DIR_LIGHTS > 0\\n\\n\\t\\t\\tvec3 dirDiffuse = vec3( 0.0 );\\n\\t\\t\\tvec3 dirSpecular = vec3( 0.0 );\\n\\n\\t\\t\\tfor( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\\n\\n\\t\\t\\t\\tvec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\\n\\t\\t\\t\\tvec3 dirVector = normalize( lDirection.xyz );\\n\\n\\t\\t\\t\\t\\t\\t// diffuse\\n\\n\\t\\t\\t\\tfloat dotProduct = dot( normal, dirVector );\\n\\n\\t\\t\\t\\t#ifdef WRAP_AROUND\\n\\n\\t\\t\\t\\t\\tfloat dirDiffuseWeightFull = max( dotProduct, 0.0 );\\n\\t\\t\\t\\t\\tfloat dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\\n\\n\\t\\t\\t\\t\\tvec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );\\n\\n\\t\\t\\t\\t#else\\n\\n\\t\\t\\t\\t\\tfloat dirDiffuseWeight = max( dotProduct, 0.0 );\\n\\n\\t\\t\\t\\t#endif\\n\\n\\t\\t\\t\\tdirDiffuse += diffuse * directionalLightColor[ i ] * dirDiffuseWeight;\\n\\n\\t\\t\\t\\t// specular\\n\\n\\t\\t\\t\\tvec3 dirHalfVector = normalize( dirVector + viewPosition );\\n\\t\\t\\t\\tfloat dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\\n\\t\\t\\t\\tfloat dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininess ), 0.0 );\\n\\n\\t\\t\\t\\tfloat specularNormalization = ( shininess + 2.0 ) / 8.0;\\n\\n\\t\\t\\t\\tvec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( dirVector, dirHalfVector ), 0.0 ), 5.0 );\\n\\t\\t\\t\\tdirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\\n\\t\\t\\t}\\n\\n\\t\\t#endif\\n\\n\\t\\tvec3 totalDiffuse = vec3( 0.0 );\\n\\t\\tvec3 totalSpecular = vec3( 0.0 );\\n\\n\\t\\t#if MAX_POINT_LIGHTS > 0\\n\\n\\t\\t\\ttotalDiffuse += pointDiffuse;\\n\\t\\t\\ttotalSpecular += pointSpecular;\\n\\n\\t\\t#endif\\n\\n\\t\\t#if MAX_DIR_LIGHTS > 0\\n\\n\\t\\t\\ttotalDiffuse += dirDiffuse;\\n\\t\\t\\ttotalSpecular += dirSpecular;\\n\\n\\t\\t#endif\\n\\n\\t\\tgl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient ) + totalSpecular;\\n\\n\\t#endif\\n\\n\\t#if defined weighted_splats\\n\\t    //float w = pow(1.0 - (u*u + v*v), blendHardness);\\n\\n\\t\\tfloat wx = 2.0 * length(2.0 * gl_PointCoord - 1.0);\\n\\t\\tfloat w = exp(-wx * wx * 0.5);\\n\\n\\t\\t//float distance = length(2.0 * gl_PointCoord - 1.0);\\n\\t\\t//float w = exp( -(distance * distance) / blendHardness);\\n\\n\\t\\tgl_FragColor.rgb = gl_FragColor.rgb * w;\\n\\t\\tgl_FragColor.a = w;\\n\\t#endif\\n\\n\\t#if defined paraboloid_point_shape\\n\\t\\tfloat wi = 0.0 - ( u*u + v*v);\\n\\t\\tvec4 pos = vec4(vViewPosition, 1.0);\\n\\t\\tpos.z += wi * vRadius;\\n\\t\\tfloat linearDepth = -pos.z;\\n\\t\\tpos = projectionMatrix * pos;\\n\\t\\tpos = pos / pos.w;\\n\\t\\tfloat expDepth = pos.z;\\n\\t\\tdepth = (pos.z + 1.0) / 2.0;\\n\\t\\tgl_FragDepthEXT = depth;\\n\\n\\t\\t#if defined(color_type_depth)\\n\\t\\t\\tgl_FragColor.r = linearDepth;\\n\\t\\t\\tgl_FragColor.g = expDepth;\\n\\t\\t#endif\\n\\n\\t\\t#if defined(use_edl)\\n\\t\\t\\tgl_FragColor.a = log2(linearDepth);\\n\\t\\t#endif\\n\\n\\t#else\\n\\t\\t#if defined(use_edl)\\n\\t\\t\\tgl_FragColor.a = vLogDepth;\\n\\t\\t#endif\\n\\t#endif\\n\\n\\t#ifdef highlight_point\\n\\t\\tif (vHighlight > 0.0) {\\n\\t\\t\\tgl_FragColor = highlightedPointColor;\\n\\t\\t}\\n\\t#endif\\n}\\n");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTY4LmpzIiwibWFwcGluZ3MiOiI7OztBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG90cmVlLy4vc3JjL21hdGVyaWFscy9zaGFkZXJzL3BvaW50Y2xvdWQuZnJhZz8wNTA1Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbnByZWNpc2lvbiBoaWdocCBpbnQ7XFxuXFxuI2lmIGRlZmluZWQgcGFyYWJvbG9pZF9wb2ludF9zaGFwZVxcblxcdCNleHRlbnNpb24gR0xfRVhUX2ZyYWdfZGVwdGggOiBlbmFibGVcXG4jZW5kaWZcXG5cXG51bmlmb3JtIG1hdDQgdmlld01hdHJpeDtcXG51bmlmb3JtIHZlYzMgY2FtZXJhUG9zaXRpb247XFxuXFxudW5pZm9ybSBtYXQ0IHByb2plY3Rpb25NYXRyaXg7XFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcblxcbnVuaWZvcm0gZmxvYXQgYmxlbmRIYXJkbmVzcztcXG51bmlmb3JtIGZsb2F0IGJsZW5kRGVwdGhTdXBwbGVtZW50O1xcbnVuaWZvcm0gZmxvYXQgZm92O1xcbnVuaWZvcm0gZmxvYXQgc3BhY2luZztcXG51bmlmb3JtIGZsb2F0IHBjSW5kZXg7XFxudW5pZm9ybSBmbG9hdCBzY3JlZW5XaWR0aDtcXG51bmlmb3JtIGZsb2F0IHNjcmVlbkhlaWdodDtcXG5cXG51bmlmb3JtIHNhbXBsZXIyRCBkZXB0aE1hcDtcXG5cXG4jaWYgZGVmaW5lZCAoY2xpcF9ob3Jpem9udGFsbHkpIHx8IGRlZmluZWQgKGNsaXBfdmVydGljYWxseSlcXG5cXHR1bmlmb3JtIHZlYzQgY2xpcEV4dGVudDtcXG4jZW5kaWZcXG5cXG4jaWZkZWYgdXNlX3RleHR1cmVfYmxlbmRpbmdcXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCBiYWNrZ3JvdW5kTWFwO1xcbiNlbmRpZlxcblxcblxcbiNpZmRlZiB1c2VfcG9pbnRfY2xvdWRfbWl4aW5nXFxuXFx0dW5pZm9ybSBpbnQgcG9pbnRDbG91ZE1peGluZ01vZGU7XFxuXFx0dW5pZm9ybSBmbG9hdCBwb2ludENsb3VkSUQ7XFxuXFx0dW5pZm9ybSBmbG9hdCBwb2ludENsb3VkTWl4QW5nbGU7XFxuXFx0dW5pZm9ybSBmbG9hdCBzdHJpcGVEaXN0YW5jZVg7XFxuXFx0dW5pZm9ybSBmbG9hdCBzdHJpcGVEaXN0YW5jZVk7XFxuXFxuXFx0dW5pZm9ybSBmbG9hdCBzdHJpcGVEaXZpc29yWDtcXG5cXHR1bmlmb3JtIGZsb2F0IHN0cmlwZURpdmlzb3JZO1xcbiNlbmRpZlxcblxcbiNpZmRlZiBoaWdobGlnaHRfcG9pbnRcXG5cXHR1bmlmb3JtIHZlYzQgaGlnaGxpZ2h0ZWRQb2ludENvbG9yO1xcbiNlbmRpZlxcblxcbnZhcnlpbmcgdmVjMyB2Q29sb3I7XFxuXFxuI2lmICFkZWZpbmVkKGNvbG9yX3R5cGVfcG9pbnRfaW5kZXgpXFxuXFx0dmFyeWluZyBmbG9hdCB2T3BhY2l0eTtcXG4jZW5kaWZcXG5cXG4jaWYgZGVmaW5lZCh3ZWlnaHRlZF9zcGxhdHMpXFxuXFx0dmFyeWluZyBmbG9hdCB2TGluZWFyRGVwdGg7XFxuI2VuZGlmXFxuXFxuI2lmICFkZWZpbmVkKHBhcmFib2xvaWRfcG9pbnRfc2hhcGUpICYmIGRlZmluZWQodXNlX2VkbClcXG5cXHR2YXJ5aW5nIGZsb2F0IHZMb2dEZXB0aDtcXG4jZW5kaWZcXG5cXG4jaWYgZGVmaW5lZChjb2xvcl90eXBlX3Bob25nKSAmJiAoTUFYX1BPSU5UX0xJR0hUUyA+IDAgfHwgTUFYX0RJUl9MSUdIVFMgPiAwKSB8fCBkZWZpbmVkKHBhcmFib2xvaWRfcG9pbnRfc2hhcGUpXFxuXFx0dmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247XFxuI2VuZGlmXFxuXFxuI2lmIGRlZmluZWQod2VpZ2h0ZWRfc3BsYXRzKSB8fCBkZWZpbmVkKHBhcmFib2xvaWRfcG9pbnRfc2hhcGUpXFxuXFx0dmFyeWluZyBmbG9hdCB2UmFkaXVzO1xcbiNlbmRpZlxcblxcbiNpZiBkZWZpbmVkKGNvbG9yX3R5cGVfcGhvbmcpICYmIChNQVhfUE9JTlRfTElHSFRTID4gMCB8fCBNQVhfRElSX0xJR0hUUyA+IDApXFxuXFx0dmFyeWluZyB2ZWMzIHZOb3JtYWw7XFxuI2VuZGlmXFxuXFxuI2lmZGVmIGhpZ2hsaWdodF9wb2ludFxcblxcdHZhcnlpbmcgZmxvYXQgdkhpZ2hsaWdodDtcXG4jZW5kaWZcXG5cXG5mbG9hdCBzcGVjdWxhclN0cmVuZ3RoID0gMS4wO1xcblxcbnZvaWQgbWFpbigpIHtcXG5cXHR2ZWMzIGNvbG9yID0gdkNvbG9yO1xcblxcdGZsb2F0IGRlcHRoID0gZ2xfRnJhZ0Nvb3JkLno7XFxuXFxuXFx0I2lmIGRlZmluZWQgKGNsaXBfaG9yaXpvbnRhbGx5KSB8fCBkZWZpbmVkIChjbGlwX3ZlcnRpY2FsbHkpXFxuXFx0dmVjMiBuZGMgPSB2ZWMyKChnbF9GcmFnQ29vcmQueCAvIHNjcmVlbldpZHRoKSwgMS4wIC0gKGdsX0ZyYWdDb29yZC55IC8gc2NyZWVuSGVpZ2h0KSk7XFxuXFxuXFx0aWYoc3RlcChjbGlwRXh0ZW50LngsIG5kYy54KSAqIHN0ZXAobmRjLngsIGNsaXBFeHRlbnQueikgPCAxLjApXFxuXFx0e1xcblxcdFxcdGRpc2NhcmQ7XFxuXFx0fVxcblxcblxcdGlmKHN0ZXAoY2xpcEV4dGVudC55LCBuZGMueSkgKiBzdGVwKG5kYy55LCBjbGlwRXh0ZW50LncpIDwgMS4wKVxcblxcdHtcXG5cXHRcXHRkaXNjYXJkO1xcblxcdH1cXG5cXHQjZW5kaWYgIFxcblxcblxcdCNpZiBkZWZpbmVkKGNpcmNsZV9wb2ludF9zaGFwZSkgfHwgZGVmaW5lZChwYXJhYm9sb2lkX3BvaW50X3NoYXBlKSB8fCBkZWZpbmVkICh3ZWlnaHRlZF9zcGxhdHMpXFxuXFx0XFx0ZmxvYXQgdSA9IDIuMCAqIGdsX1BvaW50Q29vcmQueCAtIDEuMDtcXG5cXHRcXHRmbG9hdCB2ID0gMi4wICogZ2xfUG9pbnRDb29yZC55IC0gMS4wO1xcblxcdCNlbmRpZlxcblxcblxcdCNpZiBkZWZpbmVkKGNpcmNsZV9wb2ludF9zaGFwZSkgfHwgZGVmaW5lZCAod2VpZ2h0ZWRfc3BsYXRzKVxcblxcdFxcdGZsb2F0IGNjID0gdSp1ICsgdip2O1xcblxcdFxcdGlmKGNjID4gMS4wKXtcXG5cXHRcXHRcXHRkaXNjYXJkO1xcblxcdFxcdH1cXG5cXHQjZW5kaWZcXG5cXG5cXHQjaWYgZGVmaW5lZCB3ZWlnaHRlZF9zcGxhdHNcXG5cXHRcXHR2ZWMyIHV2ID0gZ2xfRnJhZ0Nvb3JkLnh5IC8gdmVjMihzY3JlZW5XaWR0aCwgc2NyZWVuSGVpZ2h0KTtcXG5cXHRcXHRmbG9hdCBzRGVwdGggPSB0ZXh0dXJlMkQoZGVwdGhNYXAsIHV2KS5yO1xcblxcdFxcdGlmKHZMaW5lYXJEZXB0aCA+IHNEZXB0aCArIHZSYWRpdXMgKyBibGVuZERlcHRoU3VwcGxlbWVudCl7XFxuXFx0XFx0XFx0ZGlzY2FyZDtcXG5cXHRcXHR9XFxuXFx0I2VuZGlmXFxuXFxuXFx0I2lmIGRlZmluZWQgY29sb3JfdHlwZV9wb2ludF9pbmRleFxcblxcdFxcdGdsX0ZyYWdDb2xvciA9IHZlYzQoY29sb3IsIHBjSW5kZXggLyAyNTUuMCk7XFxuXFx0I2Vsc2VcXG5cXHRcXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KGNvbG9yLCB2T3BhY2l0eSk7XFxuXFx0I2VuZGlmXFxuXFxuXFx0I2lmZGVmIHVzZV9wb2ludF9jbG91ZF9taXhpbmdcXG5cXHRcXHRib29sIGRpc2NhcmRGcmFnbWVudCA9IGZhbHNlO1xcblxcblxcdFxcdGlmIChwb2ludENsb3VkTWl4aW5nTW9kZSA9PSAxKSB7ICAvLyBDaGVja2JvYXJkXFxuXFx0XFx0XFx0ZmxvYXQgdlBvaW50Q2xvdWRJRCA9IHBvaW50Q2xvdWRJRCA+IDEwLiA/IHBvaW50Q2xvdWRJRC8xMC46IHBvaW50Q2xvdWRJRDtcXG5cXHRcXHRcXHRkaXNjYXJkRnJhZ21lbnQgPSBtb2QoZ2xfRnJhZ0Nvb3JkLngsIHZQb2ludENsb3VkSUQpID4gMC41ICYmIG1vZChnbF9GcmFnQ29vcmQueSwgdlBvaW50Q2xvdWRJRCkgPiAwLjU7XFxuXFx0XFx0fVxcblxcdFxcdGVsc2UgaWYgKHBvaW50Q2xvdWRNaXhpbmdNb2RlID09IDIpIHsgIC8vIFN0cmlwZXNcXG5cXHRcXHRcXHRmbG9hdCBhbmdsZSA9IHBvaW50Q2xvdWRNaXhBbmdsZSAqIHBvaW50Q2xvdWRJRCAvIDE4MC47XFxuXFx0XFx0XFx0ZmxvYXQgdSA9IGNvcyhhbmdsZSkgKiBnbF9GcmFnQ29vcmQueCArIHNpbihhbmdsZSkgKiBnbF9GcmFnQ29vcmQueTtcXG5cXHRcXHRcXHRmbG9hdCB2ID0gLXNpbihhbmdsZSkgKiBnbF9GcmFnQ29vcmQueCArIGNvcyhhbmdsZSkgKiBnbF9GcmFnQ29vcmQueTtcXG5cXG5cXHRcXHRcXHRkaXNjYXJkRnJhZ21lbnQgPSBtb2QodSwgc3RyaXBlRGlzdGFuY2VYKSA+PSBzdHJpcGVEaXN0YW5jZVgvc3RyaXBlRGl2aXNvclggJiYgbW9kKHYsIHN0cmlwZURpc3RhbmNlWSkgPj0gc3RyaXBlRGlzdGFuY2VZL3N0cmlwZURpdmlzb3JZO1xcblxcdFxcdH1cXG5cXHRcXHRpZiAoZGlzY2FyZEZyYWdtZW50KSB7XFxuXFx0XFx0XFx0ZGlzY2FyZDtcXG5cXHRcXHR9XFxuXFx0I2VuZGlmXFxuXFxuXFx0I2lmZGVmIHVzZV90ZXh0dXJlX2JsZW5kaW5nXFxuXFx0XFx0dmVjMiB2VXYgPSBnbF9GcmFnQ29vcmQueHkgLyB2ZWMyKHNjcmVlbldpZHRoLCBzY3JlZW5IZWlnaHQpO1xcblxcblxcdFxcdHZlYzQgdENvbG9yID0gdGV4dHVyZTJEKGJhY2tncm91bmRNYXAsIHZVdik7XFxuXFx0XFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCh2T3BhY2l0eSAqIGNvbG9yLCAxLikgKyB2ZWM0KCgxLiAtIHZPcGFjaXR5KSAqIHRDb2xvci5yZ2IsIDAuKTtcXG5cXHQjZW5kaWZcXG5cXG5cXHQjaWYgZGVmaW5lZChjb2xvcl90eXBlX3Bob25nKVxcblxcdFxcdCNpZiBNQVhfUE9JTlRfTElHSFRTID4gMCB8fCBNQVhfRElSX0xJR0hUUyA+IDBcXG5cXHRcXHRcXHR2ZWMzIG5vcm1hbCA9IG5vcm1hbGl6ZSggdk5vcm1hbCApO1xcblxcdFxcdFxcdG5vcm1hbC56ID0gYWJzKG5vcm1hbC56KTtcXG5cXG5cXHRcXHRcXHR2ZWMzIHZpZXdQb3NpdGlvbiA9IG5vcm1hbGl6ZSggdlZpZXdQb3NpdGlvbiApO1xcblxcdFxcdCNlbmRpZlxcblxcblxcdFxcdC8vIGNvZGUgdGFrZW4gZnJvbSB0aHJlZS5qcyBwaG9uZyBsaWdodCBmcmFnbWVudCBzaGFkZXJcXG5cXG5cXHRcXHQjaWYgTUFYX1BPSU5UX0xJR0hUUyA+IDBcXG5cXG5cXHRcXHRcXHR2ZWMzIHBvaW50RGlmZnVzZSA9IHZlYzMoIDAuMCApO1xcblxcdFxcdFxcdHZlYzMgcG9pbnRTcGVjdWxhciA9IHZlYzMoIDAuMCApO1xcblxcblxcdFxcdFxcdGZvciAoIGludCBpID0gMDsgaSA8IE1BWF9QT0lOVF9MSUdIVFM7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmVjNCBsUG9zaXRpb24gPSB2aWV3TWF0cml4ICogdmVjNCggcG9pbnRMaWdodFBvc2l0aW9uWyBpIF0sIDEuMCApO1xcblxcdFxcdFxcdFxcdHZlYzMgbFZlY3RvciA9IGxQb3NpdGlvbi54eXogKyB2Vmlld1Bvc2l0aW9uLnh5ejtcXG5cXG5cXHRcXHRcXHRcXHRmbG9hdCBsRGlzdGFuY2UgPSAxLjA7XFxuXFx0XFx0XFx0XFx0aWYgKCBwb2ludExpZ2h0RGlzdGFuY2VbIGkgXSA+IDAuMCApXFxuXFx0XFx0XFx0XFx0XFx0bERpc3RhbmNlID0gMS4wIC0gbWluKCAoIGxlbmd0aCggbFZlY3RvciApIC8gcG9pbnRMaWdodERpc3RhbmNlWyBpIF0gKSwgMS4wICk7XFxuXFxuXFx0XFx0XFx0XFx0bFZlY3RvciA9IG5vcm1hbGl6ZSggbFZlY3RvciApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIGRpZmZ1c2VcXG5cXG5cXHRcXHRcXHRcXHRmbG9hdCBkb3RQcm9kdWN0ID0gZG90KCBub3JtYWwsIGxWZWN0b3IgKTtcXG5cXG5cXHRcXHRcXHRcXHQjaWZkZWYgV1JBUF9BUk9VTkRcXG5cXG5cXHRcXHRcXHRcXHRcXHRmbG9hdCBwb2ludERpZmZ1c2VXZWlnaHRGdWxsID0gbWF4KCBkb3RQcm9kdWN0LCAwLjAgKTtcXG5cXHRcXHRcXHRcXHRcXHRmbG9hdCBwb2ludERpZmZ1c2VXZWlnaHRIYWxmID0gbWF4KCAwLjUgKiBkb3RQcm9kdWN0ICsgMC41LCAwLjAgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2ZWMzIHBvaW50RGlmZnVzZVdlaWdodCA9IG1peCggdmVjMyggcG9pbnREaWZmdXNlV2VpZ2h0RnVsbCApLCB2ZWMzKCBwb2ludERpZmZ1c2VXZWlnaHRIYWxmICksIHdyYXBSR0IgKTtcXG5cXG5cXHRcXHRcXHRcXHQjZWxzZVxcblxcblxcdFxcdFxcdFxcdFxcdGZsb2F0IHBvaW50RGlmZnVzZVdlaWdodCA9IG1heCggZG90UHJvZHVjdCwgMC4wICk7XFxuXFxuXFx0XFx0XFx0XFx0I2VuZGlmXFxuXFxuXFx0XFx0XFx0XFx0cG9pbnREaWZmdXNlICs9IGRpZmZ1c2UgKiBwb2ludExpZ2h0Q29sb3JbIGkgXSAqIHBvaW50RGlmZnVzZVdlaWdodCAqIGxEaXN0YW5jZTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBzcGVjdWxhclxcblxcblxcdFxcdFxcdFxcdHZlYzMgcG9pbnRIYWxmVmVjdG9yID0gbm9ybWFsaXplKCBsVmVjdG9yICsgdmlld1Bvc2l0aW9uICk7XFxuXFx0XFx0XFx0XFx0ZmxvYXQgcG9pbnREb3ROb3JtYWxIYWxmID0gbWF4KCBkb3QoIG5vcm1hbCwgcG9pbnRIYWxmVmVjdG9yICksIDAuMCApO1xcblxcdFxcdFxcdFxcdGZsb2F0IHBvaW50U3BlY3VsYXJXZWlnaHQgPSBzcGVjdWxhclN0cmVuZ3RoICogbWF4KCBwb3coIHBvaW50RG90Tm9ybWFsSGFsZiwgc2hpbmluZXNzICksIDAuMCApO1xcblxcblxcdFxcdFxcdFxcdGZsb2F0IHNwZWN1bGFyTm9ybWFsaXphdGlvbiA9ICggc2hpbmluZXNzICsgMi4wICkgLyA4LjA7XFxuXFxuXFx0XFx0XFx0XFx0dmVjMyBzY2hsaWNrID0gc3BlY3VsYXIgKyB2ZWMzKCAxLjAgLSBzcGVjdWxhciApICogcG93KCBtYXgoIDEuMCAtIGRvdCggbFZlY3RvciwgcG9pbnRIYWxmVmVjdG9yICksIDAuMCApLCA1LjAgKTtcXG5cXHRcXHRcXHRcXHRwb2ludFNwZWN1bGFyICs9IHNjaGxpY2sgKiBwb2ludExpZ2h0Q29sb3JbIGkgXSAqIHBvaW50U3BlY3VsYXJXZWlnaHQgKiBwb2ludERpZmZ1c2VXZWlnaHQgKiBsRGlzdGFuY2UgKiBzcGVjdWxhck5vcm1hbGl6YXRpb247XFxuXFx0XFx0XFx0XFx0cG9pbnRTcGVjdWxhciA9IHZlYzMoMC4wLCAwLjAsIDAuMCk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdCNlbmRpZlxcblxcblxcdFxcdCNpZiBNQVhfRElSX0xJR0hUUyA+IDBcXG5cXG5cXHRcXHRcXHR2ZWMzIGRpckRpZmZ1c2UgPSB2ZWMzKCAwLjAgKTtcXG5cXHRcXHRcXHR2ZWMzIGRpclNwZWN1bGFyID0gdmVjMyggMC4wICk7XFxuXFxuXFx0XFx0XFx0Zm9yKCBpbnQgaSA9IDA7IGkgPCBNQVhfRElSX0xJR0hUUzsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHR2ZWM0IGxEaXJlY3Rpb24gPSB2aWV3TWF0cml4ICogdmVjNCggZGlyZWN0aW9uYWxMaWdodERpcmVjdGlvblsgaSBdLCAwLjAgKTtcXG5cXHRcXHRcXHRcXHR2ZWMzIGRpclZlY3RvciA9IG5vcm1hbGl6ZSggbERpcmVjdGlvbi54eXogKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBkaWZmdXNlXFxuXFxuXFx0XFx0XFx0XFx0ZmxvYXQgZG90UHJvZHVjdCA9IGRvdCggbm9ybWFsLCBkaXJWZWN0b3IgKTtcXG5cXG5cXHRcXHRcXHRcXHQjaWZkZWYgV1JBUF9BUk9VTkRcXG5cXG5cXHRcXHRcXHRcXHRcXHRmbG9hdCBkaXJEaWZmdXNlV2VpZ2h0RnVsbCA9IG1heCggZG90UHJvZHVjdCwgMC4wICk7XFxuXFx0XFx0XFx0XFx0XFx0ZmxvYXQgZGlyRGlmZnVzZVdlaWdodEhhbGYgPSBtYXgoIDAuNSAqIGRvdFByb2R1Y3QgKyAwLjUsIDAuMCApO1xcblxcblxcdFxcdFxcdFxcdFxcdHZlYzMgZGlyRGlmZnVzZVdlaWdodCA9IG1peCggdmVjMyggZGlyRGlmZnVzZVdlaWdodEZ1bGwgKSwgdmVjMyggZGlyRGlmZnVzZVdlaWdodEhhbGYgKSwgd3JhcFJHQiApO1xcblxcblxcdFxcdFxcdFxcdCNlbHNlXFxuXFxuXFx0XFx0XFx0XFx0XFx0ZmxvYXQgZGlyRGlmZnVzZVdlaWdodCA9IG1heCggZG90UHJvZHVjdCwgMC4wICk7XFxuXFxuXFx0XFx0XFx0XFx0I2VuZGlmXFxuXFxuXFx0XFx0XFx0XFx0ZGlyRGlmZnVzZSArPSBkaWZmdXNlICogZGlyZWN0aW9uYWxMaWdodENvbG9yWyBpIF0gKiBkaXJEaWZmdXNlV2VpZ2h0O1xcblxcblxcdFxcdFxcdFxcdC8vIHNwZWN1bGFyXFxuXFxuXFx0XFx0XFx0XFx0dmVjMyBkaXJIYWxmVmVjdG9yID0gbm9ybWFsaXplKCBkaXJWZWN0b3IgKyB2aWV3UG9zaXRpb24gKTtcXG5cXHRcXHRcXHRcXHRmbG9hdCBkaXJEb3ROb3JtYWxIYWxmID0gbWF4KCBkb3QoIG5vcm1hbCwgZGlySGFsZlZlY3RvciApLCAwLjAgKTtcXG5cXHRcXHRcXHRcXHRmbG9hdCBkaXJTcGVjdWxhcldlaWdodCA9IHNwZWN1bGFyU3RyZW5ndGggKiBtYXgoIHBvdyggZGlyRG90Tm9ybWFsSGFsZiwgc2hpbmluZXNzICksIDAuMCApO1xcblxcblxcdFxcdFxcdFxcdGZsb2F0IHNwZWN1bGFyTm9ybWFsaXphdGlvbiA9ICggc2hpbmluZXNzICsgMi4wICkgLyA4LjA7XFxuXFxuXFx0XFx0XFx0XFx0dmVjMyBzY2hsaWNrID0gc3BlY3VsYXIgKyB2ZWMzKCAxLjAgLSBzcGVjdWxhciApICogcG93KCBtYXgoIDEuMCAtIGRvdCggZGlyVmVjdG9yLCBkaXJIYWxmVmVjdG9yICksIDAuMCApLCA1LjAgKTtcXG5cXHRcXHRcXHRcXHRkaXJTcGVjdWxhciArPSBzY2hsaWNrICogZGlyZWN0aW9uYWxMaWdodENvbG9yWyBpIF0gKiBkaXJTcGVjdWxhcldlaWdodCAqIGRpckRpZmZ1c2VXZWlnaHQgKiBzcGVjdWxhck5vcm1hbGl6YXRpb247XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdCNlbmRpZlxcblxcblxcdFxcdHZlYzMgdG90YWxEaWZmdXNlID0gdmVjMyggMC4wICk7XFxuXFx0XFx0dmVjMyB0b3RhbFNwZWN1bGFyID0gdmVjMyggMC4wICk7XFxuXFxuXFx0XFx0I2lmIE1BWF9QT0lOVF9MSUdIVFMgPiAwXFxuXFxuXFx0XFx0XFx0dG90YWxEaWZmdXNlICs9IHBvaW50RGlmZnVzZTtcXG5cXHRcXHRcXHR0b3RhbFNwZWN1bGFyICs9IHBvaW50U3BlY3VsYXI7XFxuXFxuXFx0XFx0I2VuZGlmXFxuXFxuXFx0XFx0I2lmIE1BWF9ESVJfTElHSFRTID4gMFxcblxcblxcdFxcdFxcdHRvdGFsRGlmZnVzZSArPSBkaXJEaWZmdXNlO1xcblxcdFxcdFxcdHRvdGFsU3BlY3VsYXIgKz0gZGlyU3BlY3VsYXI7XFxuXFxuXFx0XFx0I2VuZGlmXFxuXFxuXFx0XFx0Z2xfRnJhZ0NvbG9yLnh5eiA9IGdsX0ZyYWdDb2xvci54eXogKiAoIGVtaXNzaXZlICsgdG90YWxEaWZmdXNlICsgYW1iaWVudExpZ2h0Q29sb3IgKiBhbWJpZW50ICkgKyB0b3RhbFNwZWN1bGFyO1xcblxcblxcdCNlbmRpZlxcblxcblxcdCNpZiBkZWZpbmVkIHdlaWdodGVkX3NwbGF0c1xcblxcdCAgICAvL2Zsb2F0IHcgPSBwb3coMS4wIC0gKHUqdSArIHYqdiksIGJsZW5kSGFyZG5lc3MpO1xcblxcblxcdFxcdGZsb2F0IHd4ID0gMi4wICogbGVuZ3RoKDIuMCAqIGdsX1BvaW50Q29vcmQgLSAxLjApO1xcblxcdFxcdGZsb2F0IHcgPSBleHAoLXd4ICogd3ggKiAwLjUpO1xcblxcblxcdFxcdC8vZmxvYXQgZGlzdGFuY2UgPSBsZW5ndGgoMi4wICogZ2xfUG9pbnRDb29yZCAtIDEuMCk7XFxuXFx0XFx0Ly9mbG9hdCB3ID0gZXhwKCAtKGRpc3RhbmNlICogZGlzdGFuY2UpIC8gYmxlbmRIYXJkbmVzcyk7XFxuXFxuXFx0XFx0Z2xfRnJhZ0NvbG9yLnJnYiA9IGdsX0ZyYWdDb2xvci5yZ2IgKiB3O1xcblxcdFxcdGdsX0ZyYWdDb2xvci5hID0gdztcXG5cXHQjZW5kaWZcXG5cXG5cXHQjaWYgZGVmaW5lZCBwYXJhYm9sb2lkX3BvaW50X3NoYXBlXFxuXFx0XFx0ZmxvYXQgd2kgPSAwLjAgLSAoIHUqdSArIHYqdik7XFxuXFx0XFx0dmVjNCBwb3MgPSB2ZWM0KHZWaWV3UG9zaXRpb24sIDEuMCk7XFxuXFx0XFx0cG9zLnogKz0gd2kgKiB2UmFkaXVzO1xcblxcdFxcdGZsb2F0IGxpbmVhckRlcHRoID0gLXBvcy56O1xcblxcdFxcdHBvcyA9IHByb2plY3Rpb25NYXRyaXggKiBwb3M7XFxuXFx0XFx0cG9zID0gcG9zIC8gcG9zLnc7XFxuXFx0XFx0ZmxvYXQgZXhwRGVwdGggPSBwb3MuejtcXG5cXHRcXHRkZXB0aCA9IChwb3MueiArIDEuMCkgLyAyLjA7XFxuXFx0XFx0Z2xfRnJhZ0RlcHRoRVhUID0gZGVwdGg7XFxuXFxuXFx0XFx0I2lmIGRlZmluZWQoY29sb3JfdHlwZV9kZXB0aClcXG5cXHRcXHRcXHRnbF9GcmFnQ29sb3IuciA9IGxpbmVhckRlcHRoO1xcblxcdFxcdFxcdGdsX0ZyYWdDb2xvci5nID0gZXhwRGVwdGg7XFxuXFx0XFx0I2VuZGlmXFxuXFxuXFx0XFx0I2lmIGRlZmluZWQodXNlX2VkbClcXG5cXHRcXHRcXHRnbF9GcmFnQ29sb3IuYSA9IGxvZzIobGluZWFyRGVwdGgpO1xcblxcdFxcdCNlbmRpZlxcblxcblxcdCNlbHNlXFxuXFx0XFx0I2lmIGRlZmluZWQodXNlX2VkbClcXG5cXHRcXHRcXHRnbF9GcmFnQ29sb3IuYSA9IHZMb2dEZXB0aDtcXG5cXHRcXHQjZW5kaWZcXG5cXHQjZW5kaWZcXG5cXG5cXHQjaWZkZWYgaGlnaGxpZ2h0X3BvaW50XFxuXFx0XFx0aWYgKHZIaWdobGlnaHQgPiAwLjApIHtcXG5cXHRcXHRcXHRnbF9GcmFnQ29sb3IgPSBoaWdobGlnaHRlZFBvaW50Q29sb3I7XFxuXFx0XFx0fVxcblxcdCNlbmRpZlxcbn1cXG5cIjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///168\n')},245:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("precision highp float;\\nprecision highp int;\\n\\n#define max_clip_boxes 30\\n\\nattribute vec3 position;\\nattribute vec3 color;\\n\\n#ifdef color_rgba\\n\\tattribute vec4 rgba;\\n#endif\\n\\nattribute vec3 normal;\\nattribute float intensity;\\nattribute float classification;\\nattribute float returnNumber;\\nattribute float numberOfReturns;\\nattribute float pointSourceID;\\nattribute vec4 indices;\\nattribute vec2 uv;\\n\\nuniform mat4 modelMatrix;\\nuniform mat4 modelViewMatrix;\\nuniform mat4 projectionMatrix;\\nuniform mat4 viewMatrix;\\nuniform mat3 normalMatrix;\\n\\nuniform float pcIndex;\\n\\nuniform float screenWidth;\\nuniform float screenHeight;\\nuniform float fov;\\nuniform float spacing;\\n\\n#if defined use_clip_box\\n\\tuniform mat4 clipBoxes[max_clip_boxes];\\n#endif\\n\\nuniform float heightMin;\\nuniform float heightMax;\\nuniform float size; // pixel size factor\\nuniform float minSize; // minimum pixel size\\nuniform float maxSize; // maximum pixel size\\nuniform float octreeSize;\\nuniform vec3 bbSize;\\nuniform vec3 uColor;\\nuniform float opacity;\\nuniform float clipBoxCount;\\nuniform float level;\\nuniform float vnStart;\\nuniform bool isLeafNode;\\n\\nuniform float filterByNormalThreshold;\\nuniform vec2 intensityRange;\\nuniform float opacityAttenuation;\\nuniform float intensityGamma;\\nuniform float intensityContrast;\\nuniform float intensityBrightness;\\nuniform float rgbGamma;\\nuniform float rgbContrast;\\nuniform float rgbBrightness;\\nuniform float transition;\\nuniform float wRGB;\\nuniform float wIntensity;\\nuniform float wElevation;\\nuniform float wClassification;\\nuniform float wReturnNumber;\\nuniform float wSourceID;\\n\\nuniform sampler2D visibleNodes;\\nuniform sampler2D gradient;\\nuniform sampler2D classificationLUT;\\nuniform sampler2D depthMap;\\n\\n#ifdef use_texture_blending\\n\\tuniform sampler2D backgroundMap;\\n#endif\\n\\n#ifdef use_point_cloud_mixing\\n\\tuniform int pointCloudMixingMode;\\n\\tuniform float pointCloudID;\\n\\n\\tuniform float pointCloudMixAngle;\\n\\tuniform float stripeDistanceX;\\n\\tuniform float stripeDistanceY;\\n\\n\\tuniform float stripeDivisorX;\\n\\tuniform float stripeDivisorY;\\n#endif\\n\\n#ifdef highlight_point\\n\\tuniform vec3 highlightedPointCoordinate;\\n\\tuniform bool enablePointHighlighting;\\n\\tuniform float highlightedPointScale;\\n#endif\\n\\n#ifdef use_filter_by_normal\\n\\tuniform int normalFilteringMode;\\n#endif\\n\\nvarying vec3 vColor;\\n\\n#if !defined(color_type_point_index)\\n\\tvarying float vOpacity;\\n#endif\\n\\n#if defined(weighted_splats)\\n\\tvarying float vLinearDepth;\\n#endif\\n\\n#if !defined(paraboloid_point_shape) && defined(use_edl)\\n\\tvarying float vLogDepth;\\n#endif\\n\\n#if defined(color_type_phong) && (MAX_POINT_LIGHTS > 0 || MAX_DIR_LIGHTS > 0) || defined(paraboloid_point_shape)\\n\\tvarying vec3 vViewPosition;\\n#endif\\n\\n#if defined(weighted_splats) || defined(paraboloid_point_shape)\\n\\tvarying float vRadius;\\n#endif\\n\\n#if defined(color_type_phong) && (MAX_POINT_LIGHTS > 0 || MAX_DIR_LIGHTS > 0)\\n\\tvarying vec3 vNormal;\\n#endif\\n\\n#ifdef highlight_point\\n\\tvarying float vHighlight;\\n#endif\\n\\n// ---------------------\\n// OCTREE\\n// ---------------------\\n\\n#if (defined(adaptive_point_size) || defined(color_type_lod)) && defined(tree_type_octree)\\n\\n/**\\n * Rounds the specified number to the closest integer.\\n */\\nfloat round(float number){\\n\\treturn floor(number + 0.5);\\n}\\n\\n/**\\n * Gets the number of 1-bits up to inclusive index position.\\n *\\n * number is treated as if it were an integer in the range 0-255\\n */\\nint numberOfOnes(int number, int index) {\\n\\tint numOnes = 0;\\n\\tint tmp = 128;\\n\\tfor (int i = 7; i >= 0; i--) {\\n\\n\\t\\tif (number >= tmp) {\\n\\t\\t\\tnumber = number - tmp;\\n\\n\\t\\t\\tif (i <= index) {\\n\\t\\t\\t\\tnumOnes++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\ttmp = tmp / 2;\\n\\t}\\n\\n\\treturn numOnes;\\n}\\n\\n/**\\n * Checks whether the bit at index is 1.0\\n *\\n * number is treated as if it were an integer in the range 0-255\\n */\\nbool isBitSet(int number, int index){\\n\\n\\t// weird multi else if due to lack of proper array, int and bitwise support in WebGL 1.0\\n\\tint powi = 1;\\n\\tif (index == 0) {\\n\\t\\tpowi = 1;\\n\\t} else if (index == 1) {\\n\\t\\tpowi = 2;\\n\\t} else if (index == 2) {\\n\\t\\tpowi = 4;\\n\\t} else if (index == 3) {\\n\\t\\tpowi = 8;\\n\\t} else if (index == 4) {\\n\\t\\tpowi = 16;\\n\\t} else if (index == 5) {\\n\\t\\tpowi = 32;\\n\\t} else if (index == 6) {\\n\\t\\tpowi = 64;\\n\\t} else if (index == 7) {\\n\\t\\tpowi = 128;\\n\\t}\\n\\n\\tint ndp = number / powi;\\n\\n\\treturn mod(float(ndp), 2.0) != 0.0;\\n}\\n\\n/**\\n * Gets the the LOD at the point position.\\n */\\nfloat getLOD() {\\n\\tvec3 offset = vec3(0.0, 0.0, 0.0);\\n\\tint iOffset = int(vnStart);\\n\\tfloat depth = level;\\n\\n\\tfor (float i = 0.0; i <= 30.0; i++) {\\n\\t\\tfloat nodeSizeAtLevel = octreeSize  / pow(2.0, i + level + 0.0);\\n\\n\\t\\tvec3 index3d = (position-offset) / nodeSizeAtLevel;\\n\\t\\tindex3d = floor(index3d + 0.5);\\n\\t\\tint index = int(round(4.0 * index3d.x + 2.0 * index3d.y + index3d.z));\\n\\n\\t\\tvec4 value = texture2D(visibleNodes, vec2(float(iOffset) / 2048.0, 0.0));\\n\\t\\tint mask = int(round(value.r * 255.0));\\n\\n\\t\\tif (isBitSet(mask, index)) {\\n\\t\\t\\t// there are more visible child nodes at this position\\n\\t\\t\\tint advanceG = int(round(value.g * 255.0)) * 256;\\n\\t\\t\\tint advanceB = int(round(value.b * 255.0));\\n\\t\\t\\tint advanceChild = numberOfOnes(mask, index - 1);\\n\\t\\t\\tint advance = advanceG + advanceB + advanceChild;\\n\\n\\t\\t\\tiOffset = iOffset + advance;\\n\\n\\t\\t\\tdepth++;\\n\\t\\t} else {\\n\\t\\t\\treturn value.a * 255.0; // no more visible child nodes at this position\\n\\t\\t}\\n\\n\\t\\toffset = offset + (vec3(1.0, 1.0, 1.0) * nodeSizeAtLevel * 0.5) * index3d;\\n\\t}\\n\\n\\treturn depth;\\n}\\n\\nfloat getPointSizeAttenuation() {\\n\\treturn 0.5 * pow(2.0, getLOD());\\n}\\n\\n#endif\\n\\n// ---------------------\\n// KD-TREE\\n// ---------------------\\n\\n#if (defined(adaptive_point_size) || defined(color_type_lod)) && defined(tree_type_kdtree)\\n\\nfloat getLOD() {\\n\\tvec3 offset = vec3(0.0, 0.0, 0.0);\\n\\tfloat intOffset = 0.0;\\n\\tfloat depth = 0.0;\\n\\n\\tvec3 size = bbSize;\\n\\tvec3 pos = position;\\n\\n\\tfor (float i = 0.0; i <= 1000.0; i++) {\\n\\n\\t\\tvec4 value = texture2D(visibleNodes, vec2(intOffset / 2048.0, 0.0));\\n\\n\\t\\tint children = int(value.r * 255.0);\\n\\t\\tfloat next = value.g * 255.0;\\n\\t\\tint split = int(value.b * 255.0);\\n\\n\\t\\tif (next == 0.0) {\\n\\t\\t \\treturn depth;\\n\\t\\t}\\n\\n\\t\\tvec3 splitv = vec3(0.0, 0.0, 0.0);\\n\\t\\tif (split == 1) {\\n\\t\\t\\tsplitv.x = 1.0;\\n\\t\\t} else if (split == 2) {\\n\\t\\t \\tsplitv.y = 1.0;\\n\\t\\t} else if (split == 4) {\\n\\t\\t \\tsplitv.z = 1.0;\\n\\t\\t}\\n\\n\\t\\tintOffset = intOffset + next;\\n\\n\\t\\tfloat factor = length(pos * splitv / size);\\n\\t\\tif (factor < 0.5) {\\n\\t\\t \\t// left\\n\\t\\t\\tif (children == 0 || children == 2) {\\n\\t\\t\\t\\treturn depth;\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\t// right\\n\\t\\t\\tpos = pos - size * splitv * 0.5;\\n\\t\\t\\tif (children == 0 || children == 1) {\\n\\t\\t\\t\\treturn depth;\\n\\t\\t\\t}\\n\\t\\t\\tif (children == 3) {\\n\\t\\t\\t\\tintOffset = intOffset + 1.0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tsize = size * ((1.0 - (splitv + 1.0) / 2.0) + 0.5);\\n\\n\\t\\tdepth++;\\n\\t}\\n\\n\\n\\treturn depth;\\n}\\n\\nfloat getPointSizeAttenuation() {\\n\\treturn 0.5 * pow(1.3, getLOD());\\n}\\n\\n#endif\\n\\n// formula adapted from: http://www.dfstudios.co.uk/articles/programming/image-programming-algorithms/image-processing-algorithms-part-5-contrast-adjustment/\\nfloat getContrastFactor(float contrast) {\\n\\treturn (1.0158730158730156 * (contrast + 1.0)) / (1.0158730158730156 - contrast);\\n}\\n\\nvec3 getRGB() {\\n\\t\\n\\t#ifdef color_rgba\\n\\t\\tvec3 rgb = rgba.rgb;\\n\\t#else\\t\\n\\t\\tvec3 rgb = color;\\n\\t#endif\\t\\t\\n\\n\\t#if defined(use_rgb_gamma_contrast_brightness)\\n\\t\\trgb = pow(rgb, vec3(rgbGamma));\\n\\t\\trgb = rgb + rgbBrightness;\\n\\t\\trgb = (rgb - 0.5) * getContrastFactor(rgbContrast) + 0.5;\\n\\t\\trgb = clamp(rgb, 0.0, 1.0);\\n\\t\\treturn rgb;\\n\\t#else\\n\\t\\treturn rgb;\\n\\t#endif\\n}\\n\\nfloat getIntensity() {\\n\\tfloat w = (intensity - intensityRange.x) / (intensityRange.y - intensityRange.x);\\n\\tw = pow(w, intensityGamma);\\n\\tw = w + intensityBrightness;\\n\\tw = (w - 0.5) * getContrastFactor(intensityContrast) + 0.5;\\n\\tw = clamp(w, 0.0, 1.0);\\n\\n\\treturn w;\\n}\\n\\nvec3 getElevation() {\\n\\tvec4 world = modelMatrix * vec4( position, 1.0 );\\n\\tfloat w = (world.z - heightMin) / (heightMax-heightMin);\\n\\tvec3 cElevation = texture2D(gradient, vec2(w,1.0-w)).rgb;\\n\\n\\treturn cElevation;\\n}\\n\\nvec4 getClassification() {\\n\\tvec2 uv = vec2(classification / 255.0, 0.5);\\n\\tvec4 classColor = texture2D(classificationLUT, uv);\\n\\n\\treturn classColor;\\n}\\n\\nvec3 getReturnNumber() {\\n\\tif (numberOfReturns == 1.0) {\\n\\t\\treturn vec3(1.0, 1.0, 0.0);\\n\\t} else {\\n\\t\\tif (returnNumber == 1.0) {\\n\\t\\t\\treturn vec3(1.0, 0.0, 0.0);\\n\\t\\t} else if (returnNumber == numberOfReturns) {\\n\\t\\t\\treturn vec3(0.0, 0.0, 1.0);\\n\\t\\t} else {\\n\\t\\t\\treturn vec3(0.0, 1.0, 0.0);\\n\\t\\t}\\n\\t}\\n}\\n\\nvec3 getSourceID() {\\n\\tfloat w = mod(pointSourceID, 10.0) / 10.0;\\n\\treturn texture2D(gradient, vec2(w, 1.0 - w)).rgb;\\n}\\n\\nvec3 getCompositeColor() {\\n\\tvec3 c;\\n\\tfloat w;\\n\\n\\tc += wRGB * getRGB();\\n\\tw += wRGB;\\n\\n\\tc += wIntensity * getIntensity() * vec3(1.0, 1.0, 1.0);\\n\\tw += wIntensity;\\n\\n\\tc += wElevation * getElevation();\\n\\tw += wElevation;\\n\\n\\tc += wReturnNumber * getReturnNumber();\\n\\tw += wReturnNumber;\\n\\n\\tc += wSourceID * getSourceID();\\n\\tw += wSourceID;\\n\\n\\tvec4 cl = wClassification * getClassification();\\n\\tc += cl.a * cl.rgb;\\n\\tw += wClassification * cl.a;\\n\\n\\tc = c / w;\\n\\n\\tif (w == 0.0) {\\n\\t\\tgl_Position = vec4(100.0, 100.0, 100.0, 0.0);\\n\\t}\\n\\n\\treturn c;\\n}\\n\\nvoid main() {\\n\\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\\n\\n\\tgl_Position = projectionMatrix * mvPosition;\\n\\n\\t#if defined(color_type_phong) && (MAX_POINT_LIGHTS > 0 || MAX_DIR_LIGHTS > 0) || defined(paraboloid_point_shape)\\n\\t\\tvViewPosition = mvPosition.xyz;\\n\\t#endif\\n\\n\\t#if defined weighted_splats\\n\\t\\tvLinearDepth = gl_Position.w;\\n\\t#endif\\n\\n\\t#if defined(color_type_phong) && (MAX_POINT_LIGHTS > 0 || MAX_DIR_LIGHTS > 0)\\n\\t\\tvNormal = normalize(normalMatrix * normal);\\n\\t#endif\\n\\n\\t#if !defined(paraboloid_point_shape) && defined(use_edl)\\n\\t\\tvLogDepth = log2(-mvPosition.z);\\n\\t#endif\\n\\n\\t// ---------------------\\n\\t// POINT SIZE\\n\\t// ---------------------\\n\\n\\tfloat pointSize = 1.0;\\n\\tfloat slope = tan(fov / 2.0);\\n\\tfloat projFactor =  -0.5 * screenHeight / (slope * mvPosition.z);\\n\\n\\t#if defined fixed_point_size\\n\\t\\tpointSize = size;\\n\\t#elif defined attenuated_point_size\\n\\t\\tpointSize = size * spacing * projFactor;\\n\\t#elif defined adaptive_point_size\\n\\t\\tfloat worldSpaceSize = 2.0 * size * spacing / getPointSizeAttenuation();\\n\\t\\tpointSize = worldSpaceSize * projFactor;\\n\\t#endif\\n\\n\\tpointSize = max(minSize, pointSize);\\n\\tpointSize = min(maxSize, pointSize);\\n\\n\\t#if defined(weighted_splats) || defined(paraboloid_point_shape)\\n\\t\\tvRadius = pointSize / projFactor;\\n\\t#endif\\n\\n\\tgl_PointSize = pointSize;\\n\\n\\t// ---------------------\\n\\t// HIGHLIGHTING\\n\\t// ---------------------\\n\\n\\t#ifdef highlight_point\\n\\t\\tvec4 mPosition = modelMatrix * vec4(position, 1.0);\\n\\t\\tif (enablePointHighlighting && abs(mPosition.x - highlightedPointCoordinate.x) < 0.0001 &&\\n\\t\\t\\tabs(mPosition.y - highlightedPointCoordinate.y) < 0.0001 &&\\n\\t\\t\\tabs(mPosition.z - highlightedPointCoordinate.z) < 0.0001) {\\n\\t\\t\\tvHighlight = 1.0;\\n\\t\\t\\tgl_PointSize = pointSize * highlightedPointScale;\\n\\t\\t} else {\\n\\t\\t\\tvHighlight = 0.0;\\n\\t\\t}\\n\\t#endif\\n\\n\\t// ---------------------\\n\\t// OPACITY\\n\\t// ---------------------\\n\\n\\t#ifndef color_type_point_index\\n\\t\\t#ifdef attenuated_opacity\\n\\t\\t\\tvOpacity = opacity * exp(-length(-mvPosition.xyz) / opacityAttenuation);\\n\\t\\t#else\\n\\t\\t\\tvOpacity = opacity;\\n\\t\\t#endif\\n\\t#endif\\n\\n\\t// ---------------------\\n\\t// FILTERING\\n\\t// ---------------------\\n\\n\\t#ifdef use_filter_by_normal\\n\\t\\tbool discardPoint = false;\\n\\t\\t// Absolute normal filtering\\n\\t\\tif (normalFilteringMode == 1) {\\n\\t\\t\\tdiscardPoint = (abs((modelViewMatrix * vec4(normal, 0.0)).z) > filterByNormalThreshold);\\n\\t\\t}\\n\\t\\t// less than equal to\\n\\t\\telse if (normalFilteringMode == 2) {\\n\\t\\t\\tdiscardPoint = (modelViewMatrix * vec4(normal, 0.0)).z <= filterByNormalThreshold;\\n\\t\\t\\t}\\n\\t\\t// greater than\\n\\t\\telse if(normalFilteringMode == 3) {\\n\\t\\t\\tdiscardPoint = (modelViewMatrix * vec4(normal, 0.0)).z > filterByNormalThreshold;\\n\\t\\t\\t}\\n\\n\\t\\tif (discardPoint)\\n\\t\\t{\\n\\t\\t\\tgl_Position = vec4(0.0, 0.0, 2.0, 1.0);\\n\\t\\t}\\n\\t#endif\\n\\n\\t// ---------------------\\n\\t// POINT COLOR\\n\\t// ---------------------\\n\\n\\t#ifdef color_type_rgb\\n\\t\\tvColor = getRGB();\\n\\t#elif defined color_type_height\\n\\t\\tvColor = getElevation();\\n\\t#elif defined color_type_rgb_height\\n\\t\\tvec3 cHeight = getElevation();\\n\\t\\tvColor = (1.0 - transition) * getRGB() + transition * cHeight;\\n\\t#elif defined color_type_depth\\n\\t\\tfloat linearDepth = -mvPosition.z ;\\n\\t\\tfloat expDepth = (gl_Position.z / gl_Position.w) * 0.5 + 0.5;\\n\\t\\tvColor = vec3(linearDepth, expDepth, 0.0);\\n\\t#elif defined color_type_intensity\\n\\t\\tfloat w = getIntensity();\\n\\t\\tvColor = vec3(w, w, w);\\n\\t#elif defined color_type_intensity_gradient\\n\\t\\tfloat w = getIntensity();\\n\\t\\tvColor = texture2D(gradient, vec2(w, 1.0 - w)).rgb;\\n\\t#elif defined color_type_color\\n\\t\\tvColor = uColor;\\n\\t#elif defined color_type_lod\\n\\tfloat w = getLOD() / 10.0;\\n\\tvColor = texture2D(gradient, vec2(w, 1.0 - w)).rgb;\\n\\t#elif defined color_type_point_index\\n\\t\\tvColor = indices.rgb;\\n\\t#elif defined color_type_classification\\n\\t  vec4 cl = getClassification();\\n\\t\\tvColor = cl.rgb;\\n\\t#elif defined color_type_return_number\\n\\t\\tvColor = getReturnNumber();\\n\\t#elif defined color_type_source\\n\\t\\tvColor = getSourceID();\\n\\t#elif defined color_type_normal\\n\\t\\tvColor = (modelMatrix * vec4(normal, 0.0)).xyz;\\n\\t#elif defined color_type_phong\\n\\t\\tvColor = color;\\n\\t#elif defined color_type_composite\\n\\t\\tvColor = getCompositeColor();\\n\\t#endif\\n\\n\\t#if !defined color_type_composite && defined color_type_classification\\n\\t\\tif (cl.a == 0.0) {\\n\\t\\t\\tgl_Position = vec4(100.0, 100.0, 100.0, 0.0);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t#endif\\n\\n\\t// ---------------------\\n\\t// CLIPPING\\n\\t// ---------------------\\n\\n\\t#if defined use_clip_box\\n\\t\\tbool insideAny = false;\\n\\t\\tfor (int i = 0; i < max_clip_boxes; i++) {\\n\\t\\t\\tif (i == int(clipBoxCount)) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\n\\t\\t\\tvec4 clipPosition = clipBoxes[i] * modelMatrix * vec4(position, 1.0);\\n\\t\\t\\tbool inside = -0.5 <= clipPosition.x && clipPosition.x <= 0.5;\\n\\t\\t\\tinside = inside && -0.5 <= clipPosition.y && clipPosition.y <= 0.5;\\n\\t\\t\\tinside = inside && -0.5 <= clipPosition.z && clipPosition.z <= 0.5;\\n\\t\\t\\tinsideAny = insideAny || inside;\\n\\t\\t}\\n\\n\\t\\tif (!insideAny) {\\n\\t\\t\\t#if defined clip_outside\\n\\t\\t\\t\\tgl_Position = vec4(1000.0, 1000.0, 1000.0, 1.0);\\n\\t\\t\\t#elif defined clip_highlight_inside && !defined(color_type_depth)\\n\\t\\t\\t\\tfloat c = (vColor.r + vColor.g + vColor.b) / 6.0;\\n\\t\\t\\t#endif\\n\\t\\t} else {\\n\\t\\t\\t#if defined clip_highlight_inside\\n\\t\\t\\t\\tvColor.r += 0.5;\\n\\t\\t\\t#endif\\n\\t\\t}\\n\\t#endif\\n}\\n");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjQ1LmpzIiwibWFwcGluZ3MiOiI7OztBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG90cmVlLy4vc3JjL21hdGVyaWFscy9zaGFkZXJzL3BvaW50Y2xvdWQudmVydD9lZmM4Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbnByZWNpc2lvbiBoaWdocCBpbnQ7XFxuXFxuI2RlZmluZSBtYXhfY2xpcF9ib3hlcyAzMFxcblxcbmF0dHJpYnV0ZSB2ZWMzIHBvc2l0aW9uO1xcbmF0dHJpYnV0ZSB2ZWMzIGNvbG9yO1xcblxcbiNpZmRlZiBjb2xvcl9yZ2JhXFxuXFx0YXR0cmlidXRlIHZlYzQgcmdiYTtcXG4jZW5kaWZcXG5cXG5hdHRyaWJ1dGUgdmVjMyBub3JtYWw7XFxuYXR0cmlidXRlIGZsb2F0IGludGVuc2l0eTtcXG5hdHRyaWJ1dGUgZmxvYXQgY2xhc3NpZmljYXRpb247XFxuYXR0cmlidXRlIGZsb2F0IHJldHVybk51bWJlcjtcXG5hdHRyaWJ1dGUgZmxvYXQgbnVtYmVyT2ZSZXR1cm5zO1xcbmF0dHJpYnV0ZSBmbG9hdCBwb2ludFNvdXJjZUlEO1xcbmF0dHJpYnV0ZSB2ZWM0IGluZGljZXM7XFxuYXR0cmlidXRlIHZlYzIgdXY7XFxuXFxudW5pZm9ybSBtYXQ0IG1vZGVsTWF0cml4O1xcbnVuaWZvcm0gbWF0NCBtb2RlbFZpZXdNYXRyaXg7XFxudW5pZm9ybSBtYXQ0IHByb2plY3Rpb25NYXRyaXg7XFxudW5pZm9ybSBtYXQ0IHZpZXdNYXRyaXg7XFxudW5pZm9ybSBtYXQzIG5vcm1hbE1hdHJpeDtcXG5cXG51bmlmb3JtIGZsb2F0IHBjSW5kZXg7XFxuXFxudW5pZm9ybSBmbG9hdCBzY3JlZW5XaWR0aDtcXG51bmlmb3JtIGZsb2F0IHNjcmVlbkhlaWdodDtcXG51bmlmb3JtIGZsb2F0IGZvdjtcXG51bmlmb3JtIGZsb2F0IHNwYWNpbmc7XFxuXFxuI2lmIGRlZmluZWQgdXNlX2NsaXBfYm94XFxuXFx0dW5pZm9ybSBtYXQ0IGNsaXBCb3hlc1ttYXhfY2xpcF9ib3hlc107XFxuI2VuZGlmXFxuXFxudW5pZm9ybSBmbG9hdCBoZWlnaHRNaW47XFxudW5pZm9ybSBmbG9hdCBoZWlnaHRNYXg7XFxudW5pZm9ybSBmbG9hdCBzaXplOyAvLyBwaXhlbCBzaXplIGZhY3RvclxcbnVuaWZvcm0gZmxvYXQgbWluU2l6ZTsgLy8gbWluaW11bSBwaXhlbCBzaXplXFxudW5pZm9ybSBmbG9hdCBtYXhTaXplOyAvLyBtYXhpbXVtIHBpeGVsIHNpemVcXG51bmlmb3JtIGZsb2F0IG9jdHJlZVNpemU7XFxudW5pZm9ybSB2ZWMzIGJiU2l6ZTtcXG51bmlmb3JtIHZlYzMgdUNvbG9yO1xcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXG51bmlmb3JtIGZsb2F0IGNsaXBCb3hDb3VudDtcXG51bmlmb3JtIGZsb2F0IGxldmVsO1xcbnVuaWZvcm0gZmxvYXQgdm5TdGFydDtcXG51bmlmb3JtIGJvb2wgaXNMZWFmTm9kZTtcXG5cXG51bmlmb3JtIGZsb2F0IGZpbHRlckJ5Tm9ybWFsVGhyZXNob2xkO1xcbnVuaWZvcm0gdmVjMiBpbnRlbnNpdHlSYW5nZTtcXG51bmlmb3JtIGZsb2F0IG9wYWNpdHlBdHRlbnVhdGlvbjtcXG51bmlmb3JtIGZsb2F0IGludGVuc2l0eUdhbW1hO1xcbnVuaWZvcm0gZmxvYXQgaW50ZW5zaXR5Q29udHJhc3Q7XFxudW5pZm9ybSBmbG9hdCBpbnRlbnNpdHlCcmlnaHRuZXNzO1xcbnVuaWZvcm0gZmxvYXQgcmdiR2FtbWE7XFxudW5pZm9ybSBmbG9hdCByZ2JDb250cmFzdDtcXG51bmlmb3JtIGZsb2F0IHJnYkJyaWdodG5lc3M7XFxudW5pZm9ybSBmbG9hdCB0cmFuc2l0aW9uO1xcbnVuaWZvcm0gZmxvYXQgd1JHQjtcXG51bmlmb3JtIGZsb2F0IHdJbnRlbnNpdHk7XFxudW5pZm9ybSBmbG9hdCB3RWxldmF0aW9uO1xcbnVuaWZvcm0gZmxvYXQgd0NsYXNzaWZpY2F0aW9uO1xcbnVuaWZvcm0gZmxvYXQgd1JldHVybk51bWJlcjtcXG51bmlmb3JtIGZsb2F0IHdTb3VyY2VJRDtcXG5cXG51bmlmb3JtIHNhbXBsZXIyRCB2aXNpYmxlTm9kZXM7XFxudW5pZm9ybSBzYW1wbGVyMkQgZ3JhZGllbnQ7XFxudW5pZm9ybSBzYW1wbGVyMkQgY2xhc3NpZmljYXRpb25MVVQ7XFxudW5pZm9ybSBzYW1wbGVyMkQgZGVwdGhNYXA7XFxuXFxuI2lmZGVmIHVzZV90ZXh0dXJlX2JsZW5kaW5nXFxuXFx0dW5pZm9ybSBzYW1wbGVyMkQgYmFja2dyb3VuZE1hcDtcXG4jZW5kaWZcXG5cXG4jaWZkZWYgdXNlX3BvaW50X2Nsb3VkX21peGluZ1xcblxcdHVuaWZvcm0gaW50IHBvaW50Q2xvdWRNaXhpbmdNb2RlO1xcblxcdHVuaWZvcm0gZmxvYXQgcG9pbnRDbG91ZElEO1xcblxcblxcdHVuaWZvcm0gZmxvYXQgcG9pbnRDbG91ZE1peEFuZ2xlO1xcblxcdHVuaWZvcm0gZmxvYXQgc3RyaXBlRGlzdGFuY2VYO1xcblxcdHVuaWZvcm0gZmxvYXQgc3RyaXBlRGlzdGFuY2VZO1xcblxcblxcdHVuaWZvcm0gZmxvYXQgc3RyaXBlRGl2aXNvclg7XFxuXFx0dW5pZm9ybSBmbG9hdCBzdHJpcGVEaXZpc29yWTtcXG4jZW5kaWZcXG5cXG4jaWZkZWYgaGlnaGxpZ2h0X3BvaW50XFxuXFx0dW5pZm9ybSB2ZWMzIGhpZ2hsaWdodGVkUG9pbnRDb29yZGluYXRlO1xcblxcdHVuaWZvcm0gYm9vbCBlbmFibGVQb2ludEhpZ2hsaWdodGluZztcXG5cXHR1bmlmb3JtIGZsb2F0IGhpZ2hsaWdodGVkUG9pbnRTY2FsZTtcXG4jZW5kaWZcXG5cXG4jaWZkZWYgdXNlX2ZpbHRlcl9ieV9ub3JtYWxcXG5cXHR1bmlmb3JtIGludCBub3JtYWxGaWx0ZXJpbmdNb2RlO1xcbiNlbmRpZlxcblxcbnZhcnlpbmcgdmVjMyB2Q29sb3I7XFxuXFxuI2lmICFkZWZpbmVkKGNvbG9yX3R5cGVfcG9pbnRfaW5kZXgpXFxuXFx0dmFyeWluZyBmbG9hdCB2T3BhY2l0eTtcXG4jZW5kaWZcXG5cXG4jaWYgZGVmaW5lZCh3ZWlnaHRlZF9zcGxhdHMpXFxuXFx0dmFyeWluZyBmbG9hdCB2TGluZWFyRGVwdGg7XFxuI2VuZGlmXFxuXFxuI2lmICFkZWZpbmVkKHBhcmFib2xvaWRfcG9pbnRfc2hhcGUpICYmIGRlZmluZWQodXNlX2VkbClcXG5cXHR2YXJ5aW5nIGZsb2F0IHZMb2dEZXB0aDtcXG4jZW5kaWZcXG5cXG4jaWYgZGVmaW5lZChjb2xvcl90eXBlX3Bob25nKSAmJiAoTUFYX1BPSU5UX0xJR0hUUyA+IDAgfHwgTUFYX0RJUl9MSUdIVFMgPiAwKSB8fCBkZWZpbmVkKHBhcmFib2xvaWRfcG9pbnRfc2hhcGUpXFxuXFx0dmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247XFxuI2VuZGlmXFxuXFxuI2lmIGRlZmluZWQod2VpZ2h0ZWRfc3BsYXRzKSB8fCBkZWZpbmVkKHBhcmFib2xvaWRfcG9pbnRfc2hhcGUpXFxuXFx0dmFyeWluZyBmbG9hdCB2UmFkaXVzO1xcbiNlbmRpZlxcblxcbiNpZiBkZWZpbmVkKGNvbG9yX3R5cGVfcGhvbmcpICYmIChNQVhfUE9JTlRfTElHSFRTID4gMCB8fCBNQVhfRElSX0xJR0hUUyA+IDApXFxuXFx0dmFyeWluZyB2ZWMzIHZOb3JtYWw7XFxuI2VuZGlmXFxuXFxuI2lmZGVmIGhpZ2hsaWdodF9wb2ludFxcblxcdHZhcnlpbmcgZmxvYXQgdkhpZ2hsaWdodDtcXG4jZW5kaWZcXG5cXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4vLyBPQ1RSRUVcXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG5cXG4jaWYgKGRlZmluZWQoYWRhcHRpdmVfcG9pbnRfc2l6ZSkgfHwgZGVmaW5lZChjb2xvcl90eXBlX2xvZCkpICYmIGRlZmluZWQodHJlZV90eXBlX29jdHJlZSlcXG5cXG4vKipcXG4gKiBSb3VuZHMgdGhlIHNwZWNpZmllZCBudW1iZXIgdG8gdGhlIGNsb3Nlc3QgaW50ZWdlci5cXG4gKi9cXG5mbG9hdCByb3VuZChmbG9hdCBudW1iZXIpe1xcblxcdHJldHVybiBmbG9vcihudW1iZXIgKyAwLjUpO1xcbn1cXG5cXG4vKipcXG4gKiBHZXRzIHRoZSBudW1iZXIgb2YgMS1iaXRzIHVwIHRvIGluY2x1c2l2ZSBpbmRleCBwb3NpdGlvbi5cXG4gKlxcbiAqIG51bWJlciBpcyB0cmVhdGVkIGFzIGlmIGl0IHdlcmUgYW4gaW50ZWdlciBpbiB0aGUgcmFuZ2UgMC0yNTVcXG4gKi9cXG5pbnQgbnVtYmVyT2ZPbmVzKGludCBudW1iZXIsIGludCBpbmRleCkge1xcblxcdGludCBudW1PbmVzID0gMDtcXG5cXHRpbnQgdG1wID0gMTI4O1xcblxcdGZvciAoaW50IGkgPSA3OyBpID49IDA7IGktLSkge1xcblxcblxcdFxcdGlmIChudW1iZXIgPj0gdG1wKSB7XFxuXFx0XFx0XFx0bnVtYmVyID0gbnVtYmVyIC0gdG1wO1xcblxcblxcdFxcdFxcdGlmIChpIDw9IGluZGV4KSB7XFxuXFx0XFx0XFx0XFx0bnVtT25lcysrO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0dG1wID0gdG1wIC8gMjtcXG5cXHR9XFxuXFxuXFx0cmV0dXJuIG51bU9uZXM7XFxufVxcblxcbi8qKlxcbiAqIENoZWNrcyB3aGV0aGVyIHRoZSBiaXQgYXQgaW5kZXggaXMgMS4wXFxuICpcXG4gKiBudW1iZXIgaXMgdHJlYXRlZCBhcyBpZiBpdCB3ZXJlIGFuIGludGVnZXIgaW4gdGhlIHJhbmdlIDAtMjU1XFxuICovXFxuYm9vbCBpc0JpdFNldChpbnQgbnVtYmVyLCBpbnQgaW5kZXgpe1xcblxcblxcdC8vIHdlaXJkIG11bHRpIGVsc2UgaWYgZHVlIHRvIGxhY2sgb2YgcHJvcGVyIGFycmF5LCBpbnQgYW5kIGJpdHdpc2Ugc3VwcG9ydCBpbiBXZWJHTCAxLjBcXG5cXHRpbnQgcG93aSA9IDE7XFxuXFx0aWYgKGluZGV4ID09IDApIHtcXG5cXHRcXHRwb3dpID0gMTtcXG5cXHR9IGVsc2UgaWYgKGluZGV4ID09IDEpIHtcXG5cXHRcXHRwb3dpID0gMjtcXG5cXHR9IGVsc2UgaWYgKGluZGV4ID09IDIpIHtcXG5cXHRcXHRwb3dpID0gNDtcXG5cXHR9IGVsc2UgaWYgKGluZGV4ID09IDMpIHtcXG5cXHRcXHRwb3dpID0gODtcXG5cXHR9IGVsc2UgaWYgKGluZGV4ID09IDQpIHtcXG5cXHRcXHRwb3dpID0gMTY7XFxuXFx0fSBlbHNlIGlmIChpbmRleCA9PSA1KSB7XFxuXFx0XFx0cG93aSA9IDMyO1xcblxcdH0gZWxzZSBpZiAoaW5kZXggPT0gNikge1xcblxcdFxcdHBvd2kgPSA2NDtcXG5cXHR9IGVsc2UgaWYgKGluZGV4ID09IDcpIHtcXG5cXHRcXHRwb3dpID0gMTI4O1xcblxcdH1cXG5cXG5cXHRpbnQgbmRwID0gbnVtYmVyIC8gcG93aTtcXG5cXG5cXHRyZXR1cm4gbW9kKGZsb2F0KG5kcCksIDIuMCkgIT0gMC4wO1xcbn1cXG5cXG4vKipcXG4gKiBHZXRzIHRoZSB0aGUgTE9EIGF0IHRoZSBwb2ludCBwb3NpdGlvbi5cXG4gKi9cXG5mbG9hdCBnZXRMT0QoKSB7XFxuXFx0dmVjMyBvZmZzZXQgPSB2ZWMzKDAuMCwgMC4wLCAwLjApO1xcblxcdGludCBpT2Zmc2V0ID0gaW50KHZuU3RhcnQpO1xcblxcdGZsb2F0IGRlcHRoID0gbGV2ZWw7XFxuXFxuXFx0Zm9yIChmbG9hdCBpID0gMC4wOyBpIDw9IDMwLjA7IGkrKykge1xcblxcdFxcdGZsb2F0IG5vZGVTaXplQXRMZXZlbCA9IG9jdHJlZVNpemUgIC8gcG93KDIuMCwgaSArIGxldmVsICsgMC4wKTtcXG5cXG5cXHRcXHR2ZWMzIGluZGV4M2QgPSAocG9zaXRpb24tb2Zmc2V0KSAvIG5vZGVTaXplQXRMZXZlbDtcXG5cXHRcXHRpbmRleDNkID0gZmxvb3IoaW5kZXgzZCArIDAuNSk7XFxuXFx0XFx0aW50IGluZGV4ID0gaW50KHJvdW5kKDQuMCAqIGluZGV4M2QueCArIDIuMCAqIGluZGV4M2QueSArIGluZGV4M2QueikpO1xcblxcblxcdFxcdHZlYzQgdmFsdWUgPSB0ZXh0dXJlMkQodmlzaWJsZU5vZGVzLCB2ZWMyKGZsb2F0KGlPZmZzZXQpIC8gMjA0OC4wLCAwLjApKTtcXG5cXHRcXHRpbnQgbWFzayA9IGludChyb3VuZCh2YWx1ZS5yICogMjU1LjApKTtcXG5cXG5cXHRcXHRpZiAoaXNCaXRTZXQobWFzaywgaW5kZXgpKSB7XFxuXFx0XFx0XFx0Ly8gdGhlcmUgYXJlIG1vcmUgdmlzaWJsZSBjaGlsZCBub2RlcyBhdCB0aGlzIHBvc2l0aW9uXFxuXFx0XFx0XFx0aW50IGFkdmFuY2VHID0gaW50KHJvdW5kKHZhbHVlLmcgKiAyNTUuMCkpICogMjU2O1xcblxcdFxcdFxcdGludCBhZHZhbmNlQiA9IGludChyb3VuZCh2YWx1ZS5iICogMjU1LjApKTtcXG5cXHRcXHRcXHRpbnQgYWR2YW5jZUNoaWxkID0gbnVtYmVyT2ZPbmVzKG1hc2ssIGluZGV4IC0gMSk7XFxuXFx0XFx0XFx0aW50IGFkdmFuY2UgPSBhZHZhbmNlRyArIGFkdmFuY2VCICsgYWR2YW5jZUNoaWxkO1xcblxcblxcdFxcdFxcdGlPZmZzZXQgPSBpT2Zmc2V0ICsgYWR2YW5jZTtcXG5cXG5cXHRcXHRcXHRkZXB0aCsrO1xcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0cmV0dXJuIHZhbHVlLmEgKiAyNTUuMDsgLy8gbm8gbW9yZSB2aXNpYmxlIGNoaWxkIG5vZGVzIGF0IHRoaXMgcG9zaXRpb25cXG5cXHRcXHR9XFxuXFxuXFx0XFx0b2Zmc2V0ID0gb2Zmc2V0ICsgKHZlYzMoMS4wLCAxLjAsIDEuMCkgKiBub2RlU2l6ZUF0TGV2ZWwgKiAwLjUpICogaW5kZXgzZDtcXG5cXHR9XFxuXFxuXFx0cmV0dXJuIGRlcHRoO1xcbn1cXG5cXG5mbG9hdCBnZXRQb2ludFNpemVBdHRlbnVhdGlvbigpIHtcXG5cXHRyZXR1cm4gMC41ICogcG93KDIuMCwgZ2V0TE9EKCkpO1xcbn1cXG5cXG4jZW5kaWZcXG5cXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4vLyBLRC1UUkVFXFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXFxuI2lmIChkZWZpbmVkKGFkYXB0aXZlX3BvaW50X3NpemUpIHx8IGRlZmluZWQoY29sb3JfdHlwZV9sb2QpKSAmJiBkZWZpbmVkKHRyZWVfdHlwZV9rZHRyZWUpXFxuXFxuZmxvYXQgZ2V0TE9EKCkge1xcblxcdHZlYzMgb2Zmc2V0ID0gdmVjMygwLjAsIDAuMCwgMC4wKTtcXG5cXHRmbG9hdCBpbnRPZmZzZXQgPSAwLjA7XFxuXFx0ZmxvYXQgZGVwdGggPSAwLjA7XFxuXFxuXFx0dmVjMyBzaXplID0gYmJTaXplO1xcblxcdHZlYzMgcG9zID0gcG9zaXRpb247XFxuXFxuXFx0Zm9yIChmbG9hdCBpID0gMC4wOyBpIDw9IDEwMDAuMDsgaSsrKSB7XFxuXFxuXFx0XFx0dmVjNCB2YWx1ZSA9IHRleHR1cmUyRCh2aXNpYmxlTm9kZXMsIHZlYzIoaW50T2Zmc2V0IC8gMjA0OC4wLCAwLjApKTtcXG5cXG5cXHRcXHRpbnQgY2hpbGRyZW4gPSBpbnQodmFsdWUuciAqIDI1NS4wKTtcXG5cXHRcXHRmbG9hdCBuZXh0ID0gdmFsdWUuZyAqIDI1NS4wO1xcblxcdFxcdGludCBzcGxpdCA9IGludCh2YWx1ZS5iICogMjU1LjApO1xcblxcblxcdFxcdGlmIChuZXh0ID09IDAuMCkge1xcblxcdFxcdCBcXHRyZXR1cm4gZGVwdGg7XFxuXFx0XFx0fVxcblxcblxcdFxcdHZlYzMgc3BsaXR2ID0gdmVjMygwLjAsIDAuMCwgMC4wKTtcXG5cXHRcXHRpZiAoc3BsaXQgPT0gMSkge1xcblxcdFxcdFxcdHNwbGl0di54ID0gMS4wO1xcblxcdFxcdH0gZWxzZSBpZiAoc3BsaXQgPT0gMikge1xcblxcdFxcdCBcXHRzcGxpdHYueSA9IDEuMDtcXG5cXHRcXHR9IGVsc2UgaWYgKHNwbGl0ID09IDQpIHtcXG5cXHRcXHQgXFx0c3BsaXR2LnogPSAxLjA7XFxuXFx0XFx0fVxcblxcblxcdFxcdGludE9mZnNldCA9IGludE9mZnNldCArIG5leHQ7XFxuXFxuXFx0XFx0ZmxvYXQgZmFjdG9yID0gbGVuZ3RoKHBvcyAqIHNwbGl0diAvIHNpemUpO1xcblxcdFxcdGlmIChmYWN0b3IgPCAwLjUpIHtcXG5cXHRcXHQgXFx0Ly8gbGVmdFxcblxcdFxcdFxcdGlmIChjaGlsZHJlbiA9PSAwIHx8IGNoaWxkcmVuID09IDIpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZGVwdGg7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0Ly8gcmlnaHRcXG5cXHRcXHRcXHRwb3MgPSBwb3MgLSBzaXplICogc3BsaXR2ICogMC41O1xcblxcdFxcdFxcdGlmIChjaGlsZHJlbiA9PSAwIHx8IGNoaWxkcmVuID09IDEpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZGVwdGg7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmIChjaGlsZHJlbiA9PSAzKSB7XFxuXFx0XFx0XFx0XFx0aW50T2Zmc2V0ID0gaW50T2Zmc2V0ICsgMS4wO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0XFx0c2l6ZSA9IHNpemUgKiAoKDEuMCAtIChzcGxpdHYgKyAxLjApIC8gMi4wKSArIDAuNSk7XFxuXFxuXFx0XFx0ZGVwdGgrKztcXG5cXHR9XFxuXFxuXFxuXFx0cmV0dXJuIGRlcHRoO1xcbn1cXG5cXG5mbG9hdCBnZXRQb2ludFNpemVBdHRlbnVhdGlvbigpIHtcXG5cXHRyZXR1cm4gMC41ICogcG93KDEuMywgZ2V0TE9EKCkpO1xcbn1cXG5cXG4jZW5kaWZcXG5cXG4vLyBmb3JtdWxhIGFkYXB0ZWQgZnJvbTogaHR0cDovL3d3dy5kZnN0dWRpb3MuY28udWsvYXJ0aWNsZXMvcHJvZ3JhbW1pbmcvaW1hZ2UtcHJvZ3JhbW1pbmctYWxnb3JpdGhtcy9pbWFnZS1wcm9jZXNzaW5nLWFsZ29yaXRobXMtcGFydC01LWNvbnRyYXN0LWFkanVzdG1lbnQvXFxuZmxvYXQgZ2V0Q29udHJhc3RGYWN0b3IoZmxvYXQgY29udHJhc3QpIHtcXG5cXHRyZXR1cm4gKDEuMDE1ODczMDE1ODczMDE1NiAqIChjb250cmFzdCArIDEuMCkpIC8gKDEuMDE1ODczMDE1ODczMDE1NiAtIGNvbnRyYXN0KTtcXG59XFxuXFxudmVjMyBnZXRSR0IoKSB7XFxuXFx0XFxuXFx0I2lmZGVmIGNvbG9yX3JnYmFcXG5cXHRcXHR2ZWMzIHJnYiA9IHJnYmEucmdiO1xcblxcdCNlbHNlXFx0XFxuXFx0XFx0dmVjMyByZ2IgPSBjb2xvcjtcXG5cXHQjZW5kaWZcXHRcXHRcXG5cXG5cXHQjaWYgZGVmaW5lZCh1c2VfcmdiX2dhbW1hX2NvbnRyYXN0X2JyaWdodG5lc3MpXFxuXFx0XFx0cmdiID0gcG93KHJnYiwgdmVjMyhyZ2JHYW1tYSkpO1xcblxcdFxcdHJnYiA9IHJnYiArIHJnYkJyaWdodG5lc3M7XFxuXFx0XFx0cmdiID0gKHJnYiAtIDAuNSkgKiBnZXRDb250cmFzdEZhY3RvcihyZ2JDb250cmFzdCkgKyAwLjU7XFxuXFx0XFx0cmdiID0gY2xhbXAocmdiLCAwLjAsIDEuMCk7XFxuXFx0XFx0cmV0dXJuIHJnYjtcXG5cXHQjZWxzZVxcblxcdFxcdHJldHVybiByZ2I7XFxuXFx0I2VuZGlmXFxufVxcblxcbmZsb2F0IGdldEludGVuc2l0eSgpIHtcXG5cXHRmbG9hdCB3ID0gKGludGVuc2l0eSAtIGludGVuc2l0eVJhbmdlLngpIC8gKGludGVuc2l0eVJhbmdlLnkgLSBpbnRlbnNpdHlSYW5nZS54KTtcXG5cXHR3ID0gcG93KHcsIGludGVuc2l0eUdhbW1hKTtcXG5cXHR3ID0gdyArIGludGVuc2l0eUJyaWdodG5lc3M7XFxuXFx0dyA9ICh3IC0gMC41KSAqIGdldENvbnRyYXN0RmFjdG9yKGludGVuc2l0eUNvbnRyYXN0KSArIDAuNTtcXG5cXHR3ID0gY2xhbXAodywgMC4wLCAxLjApO1xcblxcblxcdHJldHVybiB3O1xcbn1cXG5cXG52ZWMzIGdldEVsZXZhdGlvbigpIHtcXG5cXHR2ZWM0IHdvcmxkID0gbW9kZWxNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XFxuXFx0ZmxvYXQgdyA9ICh3b3JsZC56IC0gaGVpZ2h0TWluKSAvIChoZWlnaHRNYXgtaGVpZ2h0TWluKTtcXG5cXHR2ZWMzIGNFbGV2YXRpb24gPSB0ZXh0dXJlMkQoZ3JhZGllbnQsIHZlYzIodywxLjAtdykpLnJnYjtcXG5cXG5cXHRyZXR1cm4gY0VsZXZhdGlvbjtcXG59XFxuXFxudmVjNCBnZXRDbGFzc2lmaWNhdGlvbigpIHtcXG5cXHR2ZWMyIHV2ID0gdmVjMihjbGFzc2lmaWNhdGlvbiAvIDI1NS4wLCAwLjUpO1xcblxcdHZlYzQgY2xhc3NDb2xvciA9IHRleHR1cmUyRChjbGFzc2lmaWNhdGlvbkxVVCwgdXYpO1xcblxcblxcdHJldHVybiBjbGFzc0NvbG9yO1xcbn1cXG5cXG52ZWMzIGdldFJldHVybk51bWJlcigpIHtcXG5cXHRpZiAobnVtYmVyT2ZSZXR1cm5zID09IDEuMCkge1xcblxcdFxcdHJldHVybiB2ZWMzKDEuMCwgMS4wLCAwLjApO1xcblxcdH0gZWxzZSB7XFxuXFx0XFx0aWYgKHJldHVybk51bWJlciA9PSAxLjApIHtcXG5cXHRcXHRcXHRyZXR1cm4gdmVjMygxLjAsIDAuMCwgMC4wKTtcXG5cXHRcXHR9IGVsc2UgaWYgKHJldHVybk51bWJlciA9PSBudW1iZXJPZlJldHVybnMpIHtcXG5cXHRcXHRcXHRyZXR1cm4gdmVjMygwLjAsIDAuMCwgMS4wKTtcXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdHJldHVybiB2ZWMzKDAuMCwgMS4wLCAwLjApO1xcblxcdFxcdH1cXG5cXHR9XFxufVxcblxcbnZlYzMgZ2V0U291cmNlSUQoKSB7XFxuXFx0ZmxvYXQgdyA9IG1vZChwb2ludFNvdXJjZUlELCAxMC4wKSAvIDEwLjA7XFxuXFx0cmV0dXJuIHRleHR1cmUyRChncmFkaWVudCwgdmVjMih3LCAxLjAgLSB3KSkucmdiO1xcbn1cXG5cXG52ZWMzIGdldENvbXBvc2l0ZUNvbG9yKCkge1xcblxcdHZlYzMgYztcXG5cXHRmbG9hdCB3O1xcblxcblxcdGMgKz0gd1JHQiAqIGdldFJHQigpO1xcblxcdHcgKz0gd1JHQjtcXG5cXG5cXHRjICs9IHdJbnRlbnNpdHkgKiBnZXRJbnRlbnNpdHkoKSAqIHZlYzMoMS4wLCAxLjAsIDEuMCk7XFxuXFx0dyArPSB3SW50ZW5zaXR5O1xcblxcblxcdGMgKz0gd0VsZXZhdGlvbiAqIGdldEVsZXZhdGlvbigpO1xcblxcdHcgKz0gd0VsZXZhdGlvbjtcXG5cXG5cXHRjICs9IHdSZXR1cm5OdW1iZXIgKiBnZXRSZXR1cm5OdW1iZXIoKTtcXG5cXHR3ICs9IHdSZXR1cm5OdW1iZXI7XFxuXFxuXFx0YyArPSB3U291cmNlSUQgKiBnZXRTb3VyY2VJRCgpO1xcblxcdHcgKz0gd1NvdXJjZUlEO1xcblxcblxcdHZlYzQgY2wgPSB3Q2xhc3NpZmljYXRpb24gKiBnZXRDbGFzc2lmaWNhdGlvbigpO1xcblxcdGMgKz0gY2wuYSAqIGNsLnJnYjtcXG5cXHR3ICs9IHdDbGFzc2lmaWNhdGlvbiAqIGNsLmE7XFxuXFxuXFx0YyA9IGMgLyB3O1xcblxcblxcdGlmICh3ID09IDAuMCkge1xcblxcdFxcdGdsX1Bvc2l0aW9uID0gdmVjNCgxMDAuMCwgMTAwLjAsIDEwMC4wLCAwLjApO1xcblxcdH1cXG5cXG5cXHRyZXR1cm4gYztcXG59XFxuXFxudm9pZCBtYWluKCkge1xcblxcdHZlYzQgbXZQb3NpdGlvbiA9IG1vZGVsVmlld01hdHJpeCAqIHZlYzQocG9zaXRpb24sIDEuMCk7XFxuXFxuXFx0Z2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbXZQb3NpdGlvbjtcXG5cXG5cXHQjaWYgZGVmaW5lZChjb2xvcl90eXBlX3Bob25nKSAmJiAoTUFYX1BPSU5UX0xJR0hUUyA+IDAgfHwgTUFYX0RJUl9MSUdIVFMgPiAwKSB8fCBkZWZpbmVkKHBhcmFib2xvaWRfcG9pbnRfc2hhcGUpXFxuXFx0XFx0dlZpZXdQb3NpdGlvbiA9IG12UG9zaXRpb24ueHl6O1xcblxcdCNlbmRpZlxcblxcblxcdCNpZiBkZWZpbmVkIHdlaWdodGVkX3NwbGF0c1xcblxcdFxcdHZMaW5lYXJEZXB0aCA9IGdsX1Bvc2l0aW9uLnc7XFxuXFx0I2VuZGlmXFxuXFxuXFx0I2lmIGRlZmluZWQoY29sb3JfdHlwZV9waG9uZykgJiYgKE1BWF9QT0lOVF9MSUdIVFMgPiAwIHx8IE1BWF9ESVJfTElHSFRTID4gMClcXG5cXHRcXHR2Tm9ybWFsID0gbm9ybWFsaXplKG5vcm1hbE1hdHJpeCAqIG5vcm1hbCk7XFxuXFx0I2VuZGlmXFxuXFxuXFx0I2lmICFkZWZpbmVkKHBhcmFib2xvaWRfcG9pbnRfc2hhcGUpICYmIGRlZmluZWQodXNlX2VkbClcXG5cXHRcXHR2TG9nRGVwdGggPSBsb2cyKC1tdlBvc2l0aW9uLnopO1xcblxcdCNlbmRpZlxcblxcblxcdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcblxcdC8vIFBPSU5UIFNJWkVcXG5cXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG5cXG5cXHRmbG9hdCBwb2ludFNpemUgPSAxLjA7XFxuXFx0ZmxvYXQgc2xvcGUgPSB0YW4oZm92IC8gMi4wKTtcXG5cXHRmbG9hdCBwcm9qRmFjdG9yID0gIC0wLjUgKiBzY3JlZW5IZWlnaHQgLyAoc2xvcGUgKiBtdlBvc2l0aW9uLnopO1xcblxcblxcdCNpZiBkZWZpbmVkIGZpeGVkX3BvaW50X3NpemVcXG5cXHRcXHRwb2ludFNpemUgPSBzaXplO1xcblxcdCNlbGlmIGRlZmluZWQgYXR0ZW51YXRlZF9wb2ludF9zaXplXFxuXFx0XFx0cG9pbnRTaXplID0gc2l6ZSAqIHNwYWNpbmcgKiBwcm9qRmFjdG9yO1xcblxcdCNlbGlmIGRlZmluZWQgYWRhcHRpdmVfcG9pbnRfc2l6ZVxcblxcdFxcdGZsb2F0IHdvcmxkU3BhY2VTaXplID0gMi4wICogc2l6ZSAqIHNwYWNpbmcgLyBnZXRQb2ludFNpemVBdHRlbnVhdGlvbigpO1xcblxcdFxcdHBvaW50U2l6ZSA9IHdvcmxkU3BhY2VTaXplICogcHJvakZhY3RvcjtcXG5cXHQjZW5kaWZcXG5cXG5cXHRwb2ludFNpemUgPSBtYXgobWluU2l6ZSwgcG9pbnRTaXplKTtcXG5cXHRwb2ludFNpemUgPSBtaW4obWF4U2l6ZSwgcG9pbnRTaXplKTtcXG5cXG5cXHQjaWYgZGVmaW5lZCh3ZWlnaHRlZF9zcGxhdHMpIHx8IGRlZmluZWQocGFyYWJvbG9pZF9wb2ludF9zaGFwZSlcXG5cXHRcXHR2UmFkaXVzID0gcG9pbnRTaXplIC8gcHJvakZhY3RvcjtcXG5cXHQjZW5kaWZcXG5cXG5cXHRnbF9Qb2ludFNpemUgPSBwb2ludFNpemU7XFxuXFxuXFx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXFx0Ly8gSElHSExJR0hUSU5HXFxuXFx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXFxuXFx0I2lmZGVmIGhpZ2hsaWdodF9wb2ludFxcblxcdFxcdHZlYzQgbVBvc2l0aW9uID0gbW9kZWxNYXRyaXggKiB2ZWM0KHBvc2l0aW9uLCAxLjApO1xcblxcdFxcdGlmIChlbmFibGVQb2ludEhpZ2hsaWdodGluZyAmJiBhYnMobVBvc2l0aW9uLnggLSBoaWdobGlnaHRlZFBvaW50Q29vcmRpbmF0ZS54KSA8IDAuMDAwMSAmJlxcblxcdFxcdFxcdGFicyhtUG9zaXRpb24ueSAtIGhpZ2hsaWdodGVkUG9pbnRDb29yZGluYXRlLnkpIDwgMC4wMDAxICYmXFxuXFx0XFx0XFx0YWJzKG1Qb3NpdGlvbi56IC0gaGlnaGxpZ2h0ZWRQb2ludENvb3JkaW5hdGUueikgPCAwLjAwMDEpIHtcXG5cXHRcXHRcXHR2SGlnaGxpZ2h0ID0gMS4wO1xcblxcdFxcdFxcdGdsX1BvaW50U2l6ZSA9IHBvaW50U2l6ZSAqIGhpZ2hsaWdodGVkUG9pbnRTY2FsZTtcXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdHZIaWdobGlnaHQgPSAwLjA7XFxuXFx0XFx0fVxcblxcdCNlbmRpZlxcblxcblxcdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcblxcdC8vIE9QQUNJVFlcXG5cXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG5cXG5cXHQjaWZuZGVmIGNvbG9yX3R5cGVfcG9pbnRfaW5kZXhcXG5cXHRcXHQjaWZkZWYgYXR0ZW51YXRlZF9vcGFjaXR5XFxuXFx0XFx0XFx0dk9wYWNpdHkgPSBvcGFjaXR5ICogZXhwKC1sZW5ndGgoLW12UG9zaXRpb24ueHl6KSAvIG9wYWNpdHlBdHRlbnVhdGlvbik7XFxuXFx0XFx0I2Vsc2VcXG5cXHRcXHRcXHR2T3BhY2l0eSA9IG9wYWNpdHk7XFxuXFx0XFx0I2VuZGlmXFxuXFx0I2VuZGlmXFxuXFxuXFx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXFx0Ly8gRklMVEVSSU5HXFxuXFx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXFxuXFx0I2lmZGVmIHVzZV9maWx0ZXJfYnlfbm9ybWFsXFxuXFx0XFx0Ym9vbCBkaXNjYXJkUG9pbnQgPSBmYWxzZTtcXG5cXHRcXHQvLyBBYnNvbHV0ZSBub3JtYWwgZmlsdGVyaW5nXFxuXFx0XFx0aWYgKG5vcm1hbEZpbHRlcmluZ01vZGUgPT0gMSkge1xcblxcdFxcdFxcdGRpc2NhcmRQb2ludCA9IChhYnMoKG1vZGVsVmlld01hdHJpeCAqIHZlYzQobm9ybWFsLCAwLjApKS56KSA+IGZpbHRlckJ5Tm9ybWFsVGhyZXNob2xkKTtcXG5cXHRcXHR9XFxuXFx0XFx0Ly8gbGVzcyB0aGFuIGVxdWFsIHRvXFxuXFx0XFx0ZWxzZSBpZiAobm9ybWFsRmlsdGVyaW5nTW9kZSA9PSAyKSB7XFxuXFx0XFx0XFx0ZGlzY2FyZFBvaW50ID0gKG1vZGVsVmlld01hdHJpeCAqIHZlYzQobm9ybWFsLCAwLjApKS56IDw9IGZpbHRlckJ5Tm9ybWFsVGhyZXNob2xkO1xcblxcdFxcdFxcdH1cXG5cXHRcXHQvLyBncmVhdGVyIHRoYW5cXG5cXHRcXHRlbHNlIGlmKG5vcm1hbEZpbHRlcmluZ01vZGUgPT0gMykge1xcblxcdFxcdFxcdGRpc2NhcmRQb2ludCA9IChtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KG5vcm1hbCwgMC4wKSkueiA+IGZpbHRlckJ5Tm9ybWFsVGhyZXNob2xkO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRpZiAoZGlzY2FyZFBvaW50KVxcblxcdFxcdHtcXG5cXHRcXHRcXHRnbF9Qb3NpdGlvbiA9IHZlYzQoMC4wLCAwLjAsIDIuMCwgMS4wKTtcXG5cXHRcXHR9XFxuXFx0I2VuZGlmXFxuXFxuXFx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXFx0Ly8gUE9JTlQgQ09MT1JcXG5cXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG5cXG5cXHQjaWZkZWYgY29sb3JfdHlwZV9yZ2JcXG5cXHRcXHR2Q29sb3IgPSBnZXRSR0IoKTtcXG5cXHQjZWxpZiBkZWZpbmVkIGNvbG9yX3R5cGVfaGVpZ2h0XFxuXFx0XFx0dkNvbG9yID0gZ2V0RWxldmF0aW9uKCk7XFxuXFx0I2VsaWYgZGVmaW5lZCBjb2xvcl90eXBlX3JnYl9oZWlnaHRcXG5cXHRcXHR2ZWMzIGNIZWlnaHQgPSBnZXRFbGV2YXRpb24oKTtcXG5cXHRcXHR2Q29sb3IgPSAoMS4wIC0gdHJhbnNpdGlvbikgKiBnZXRSR0IoKSArIHRyYW5zaXRpb24gKiBjSGVpZ2h0O1xcblxcdCNlbGlmIGRlZmluZWQgY29sb3JfdHlwZV9kZXB0aFxcblxcdFxcdGZsb2F0IGxpbmVhckRlcHRoID0gLW12UG9zaXRpb24ueiA7XFxuXFx0XFx0ZmxvYXQgZXhwRGVwdGggPSAoZ2xfUG9zaXRpb24ueiAvIGdsX1Bvc2l0aW9uLncpICogMC41ICsgMC41O1xcblxcdFxcdHZDb2xvciA9IHZlYzMobGluZWFyRGVwdGgsIGV4cERlcHRoLCAwLjApO1xcblxcdCNlbGlmIGRlZmluZWQgY29sb3JfdHlwZV9pbnRlbnNpdHlcXG5cXHRcXHRmbG9hdCB3ID0gZ2V0SW50ZW5zaXR5KCk7XFxuXFx0XFx0dkNvbG9yID0gdmVjMyh3LCB3LCB3KTtcXG5cXHQjZWxpZiBkZWZpbmVkIGNvbG9yX3R5cGVfaW50ZW5zaXR5X2dyYWRpZW50XFxuXFx0XFx0ZmxvYXQgdyA9IGdldEludGVuc2l0eSgpO1xcblxcdFxcdHZDb2xvciA9IHRleHR1cmUyRChncmFkaWVudCwgdmVjMih3LCAxLjAgLSB3KSkucmdiO1xcblxcdCNlbGlmIGRlZmluZWQgY29sb3JfdHlwZV9jb2xvclxcblxcdFxcdHZDb2xvciA9IHVDb2xvcjtcXG5cXHQjZWxpZiBkZWZpbmVkIGNvbG9yX3R5cGVfbG9kXFxuXFx0ZmxvYXQgdyA9IGdldExPRCgpIC8gMTAuMDtcXG5cXHR2Q29sb3IgPSB0ZXh0dXJlMkQoZ3JhZGllbnQsIHZlYzIodywgMS4wIC0gdykpLnJnYjtcXG5cXHQjZWxpZiBkZWZpbmVkIGNvbG9yX3R5cGVfcG9pbnRfaW5kZXhcXG5cXHRcXHR2Q29sb3IgPSBpbmRpY2VzLnJnYjtcXG5cXHQjZWxpZiBkZWZpbmVkIGNvbG9yX3R5cGVfY2xhc3NpZmljYXRpb25cXG5cXHQgIHZlYzQgY2wgPSBnZXRDbGFzc2lmaWNhdGlvbigpO1xcblxcdFxcdHZDb2xvciA9IGNsLnJnYjtcXG5cXHQjZWxpZiBkZWZpbmVkIGNvbG9yX3R5cGVfcmV0dXJuX251bWJlclxcblxcdFxcdHZDb2xvciA9IGdldFJldHVybk51bWJlcigpO1xcblxcdCNlbGlmIGRlZmluZWQgY29sb3JfdHlwZV9zb3VyY2VcXG5cXHRcXHR2Q29sb3IgPSBnZXRTb3VyY2VJRCgpO1xcblxcdCNlbGlmIGRlZmluZWQgY29sb3JfdHlwZV9ub3JtYWxcXG5cXHRcXHR2Q29sb3IgPSAobW9kZWxNYXRyaXggKiB2ZWM0KG5vcm1hbCwgMC4wKSkueHl6O1xcblxcdCNlbGlmIGRlZmluZWQgY29sb3JfdHlwZV9waG9uZ1xcblxcdFxcdHZDb2xvciA9IGNvbG9yO1xcblxcdCNlbGlmIGRlZmluZWQgY29sb3JfdHlwZV9jb21wb3NpdGVcXG5cXHRcXHR2Q29sb3IgPSBnZXRDb21wb3NpdGVDb2xvcigpO1xcblxcdCNlbmRpZlxcblxcblxcdCNpZiAhZGVmaW5lZCBjb2xvcl90eXBlX2NvbXBvc2l0ZSAmJiBkZWZpbmVkIGNvbG9yX3R5cGVfY2xhc3NpZmljYXRpb25cXG5cXHRcXHRpZiAoY2wuYSA9PSAwLjApIHtcXG5cXHRcXHRcXHRnbF9Qb3NpdGlvbiA9IHZlYzQoMTAwLjAsIDEwMC4wLCAxMDAuMCwgMC4wKTtcXG5cXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0fVxcblxcdCNlbmRpZlxcblxcblxcdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcblxcdC8vIENMSVBQSU5HXFxuXFx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXFxuXFx0I2lmIGRlZmluZWQgdXNlX2NsaXBfYm94XFxuXFx0XFx0Ym9vbCBpbnNpZGVBbnkgPSBmYWxzZTtcXG5cXHRcXHRmb3IgKGludCBpID0gMDsgaSA8IG1heF9jbGlwX2JveGVzOyBpKyspIHtcXG5cXHRcXHRcXHRpZiAoaSA9PSBpbnQoY2xpcEJveENvdW50KSkge1xcblxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR2ZWM0IGNsaXBQb3NpdGlvbiA9IGNsaXBCb3hlc1tpXSAqIG1vZGVsTWF0cml4ICogdmVjNChwb3NpdGlvbiwgMS4wKTtcXG5cXHRcXHRcXHRib29sIGluc2lkZSA9IC0wLjUgPD0gY2xpcFBvc2l0aW9uLnggJiYgY2xpcFBvc2l0aW9uLnggPD0gMC41O1xcblxcdFxcdFxcdGluc2lkZSA9IGluc2lkZSAmJiAtMC41IDw9IGNsaXBQb3NpdGlvbi55ICYmIGNsaXBQb3NpdGlvbi55IDw9IDAuNTtcXG5cXHRcXHRcXHRpbnNpZGUgPSBpbnNpZGUgJiYgLTAuNSA8PSBjbGlwUG9zaXRpb24ueiAmJiBjbGlwUG9zaXRpb24ueiA8PSAwLjU7XFxuXFx0XFx0XFx0aW5zaWRlQW55ID0gaW5zaWRlQW55IHx8IGluc2lkZTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKCFpbnNpZGVBbnkpIHtcXG5cXHRcXHRcXHQjaWYgZGVmaW5lZCBjbGlwX291dHNpZGVcXG5cXHRcXHRcXHRcXHRnbF9Qb3NpdGlvbiA9IHZlYzQoMTAwMC4wLCAxMDAwLjAsIDEwMDAuMCwgMS4wKTtcXG5cXHRcXHRcXHQjZWxpZiBkZWZpbmVkIGNsaXBfaGlnaGxpZ2h0X2luc2lkZSAmJiAhZGVmaW5lZChjb2xvcl90eXBlX2RlcHRoKVxcblxcdFxcdFxcdFxcdGZsb2F0IGMgPSAodkNvbG9yLnIgKyB2Q29sb3IuZyArIHZDb2xvci5iKSAvIDYuMDtcXG5cXHRcXHRcXHQjZW5kaWZcXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdCNpZiBkZWZpbmVkIGNsaXBfaGlnaGxpZ2h0X2luc2lkZVxcblxcdFxcdFxcdFxcdHZDb2xvci5yICs9IDAuNTtcXG5cXHRcXHRcXHQjZW5kaWZcXG5cXHRcXHR9XFxuXFx0I2VuZGlmXFxufVxcblwiOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///245\n')},599:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  BlurMaterial: () => (/* reexport */ BlurMaterial),\n  ClipMode: () => (/* reexport */ ClipMode),\n  GRAYSCALE: () => (/* reexport */ GRAYSCALE),\n  INFERNO: () => (/* reexport */ INFERNO),\n  NormalFilteringMode: () => (/* reexport */ NormalFilteringMode),\n  PLASMA: () => (/* reexport */ PLASMA),\n  POINT_ATTRIBUTES: () => (/* reexport */ POINT_ATTRIBUTES),\n  POINT_ATTRIBUTE_TYPES: () => (/* reexport */ POINT_ATTRIBUTE_TYPES),\n  PointAttributeName: () => (/* reexport */ PointAttributeName),\n  PointAttributes: () => (/* reexport */ PointAttributes),\n  PointCloudMaterial: () => (/* reexport */ PointCloudMaterial),\n  PointCloudMixingMode: () => (/* reexport */ PointCloudMixingMode),\n  PointCloudOctree: () => (/* reexport */ PointCloudOctree),\n  PointCloudOctreeGeometry: () => (/* reexport */ PointCloudOctreeGeometry),\n  PointCloudOctreeGeometryNode: () => (/* reexport */ PointCloudOctreeGeometryNode),\n  PointCloudOctreeNode: () => (/* reexport */ PointCloudOctreeNode),\n  PointCloudOctreePicker: () => (/* reexport */ PointCloudOctreePicker),\n  PointCloudTree: () => (/* reexport */ PointCloudTree),\n  PointColorType: () => (/* reexport */ PointColorType),\n  PointOpacityType: () => (/* reexport */ PointOpacityType),\n  PointShape: () => (/* reexport */ PointShape),\n  PointSizeType: () => (/* reexport */ PointSizeType),\n  Potree: () => (/* reexport */ Potree),\n  QueueItem: () => (/* reexport */ QueueItem),\n  RAINBOW: () => (/* reexport */ RAINBOW),\n  SPECTRAL: () => (/* reexport */ SPECTRAL),\n  TreeType: () => (/* reexport */ TreeType),\n  V1_LOADER: () => (/* reexport */ loadPOC),\n  V2_LOADER: () => (/* reexport */ loadOctree),\n  VIRIDIS: () => (/* reexport */ VIRIDIS),\n  Version: () => (/* reexport */ Version),\n  YELLOW_GREEN: () => (/* reexport */ YELLOW_GREEN),\n  generateClassificationTexture: () => (/* reexport */ generateClassificationTexture),\n  generateDataTexture: () => (/* reexport */ generateDataTexture),\n  generateGradientTexture: () => (/* reexport */ generateGradientTexture)\n});\n\n// EXTERNAL MODULE: external \"three\"\nvar external_three_ = __webpack_require__(604);\n;// CONCATENATED MODULE: ./src/materials/blur-material.ts\n\nclass BlurMaterial extends external_three_.ShaderMaterial {\n    constructor() {\n        super(...arguments);\n        this.vertexShader = __webpack_require__(575);\n        this.fragmentShader = __webpack_require__(414);\n        this.uniforms = {\n            screenWidth: { type: 'f', value: 0 },\n            screenHeight: { type: 'f', value: 0 },\n            map: { type: 't', value: null },\n        };\n    }\n}\n\n;// CONCATENATED MODULE: ./src/materials/clipping.ts\nvar ClipMode;\n(function (ClipMode) {\n    ClipMode[ClipMode[\"DISABLED\"] = 0] = \"DISABLED\";\n    ClipMode[ClipMode[\"CLIP_OUTSIDE\"] = 1] = \"CLIP_OUTSIDE\";\n    ClipMode[ClipMode[\"HIGHLIGHT_INSIDE\"] = 2] = \"HIGHLIGHT_INSIDE\";\n    ClipMode[ClipMode[\"CLIP_HORIZONTALLY\"] = 3] = \"CLIP_HORIZONTALLY\";\n    ClipMode[ClipMode[\"CLIP_VERTICALLY\"] = 4] = \"CLIP_VERTICALLY\";\n})(ClipMode || (ClipMode = {}));\n\n;// CONCATENATED MODULE: ./src/materials/enums.ts\nvar PointSizeType;\n(function (PointSizeType) {\n    PointSizeType[PointSizeType[\"FIXED\"] = 0] = \"FIXED\";\n    PointSizeType[PointSizeType[\"ATTENUATED\"] = 1] = \"ATTENUATED\";\n    PointSizeType[PointSizeType[\"ADAPTIVE\"] = 2] = \"ADAPTIVE\";\n})(PointSizeType || (PointSizeType = {}));\nvar PointShape;\n(function (PointShape) {\n    PointShape[PointShape[\"SQUARE\"] = 0] = \"SQUARE\";\n    PointShape[PointShape[\"CIRCLE\"] = 1] = \"CIRCLE\";\n    PointShape[PointShape[\"PARABOLOID\"] = 2] = \"PARABOLOID\";\n})(PointShape || (PointShape = {}));\nvar TreeType;\n(function (TreeType) {\n    TreeType[TreeType[\"OCTREE\"] = 0] = \"OCTREE\";\n    TreeType[TreeType[\"KDTREE\"] = 1] = \"KDTREE\";\n})(TreeType || (TreeType = {}));\nvar PointOpacityType;\n(function (PointOpacityType) {\n    PointOpacityType[PointOpacityType[\"FIXED\"] = 0] = \"FIXED\";\n    PointOpacityType[PointOpacityType[\"ATTENUATED\"] = 1] = \"ATTENUATED\";\n})(PointOpacityType || (PointOpacityType = {}));\nvar PointColorType;\n(function (PointColorType) {\n    PointColorType[PointColorType[\"RGB\"] = 0] = \"RGB\";\n    PointColorType[PointColorType[\"COLOR\"] = 1] = \"COLOR\";\n    PointColorType[PointColorType[\"DEPTH\"] = 2] = \"DEPTH\";\n    PointColorType[PointColorType[\"HEIGHT\"] = 3] = \"HEIGHT\";\n    PointColorType[PointColorType[\"ELEVATION\"] = 3] = \"ELEVATION\";\n    PointColorType[PointColorType[\"INTENSITY\"] = 4] = \"INTENSITY\";\n    PointColorType[PointColorType[\"INTENSITY_GRADIENT\"] = 5] = \"INTENSITY_GRADIENT\";\n    PointColorType[PointColorType[\"LOD\"] = 6] = \"LOD\";\n    PointColorType[PointColorType[\"LEVEL_OF_DETAIL\"] = 6] = \"LEVEL_OF_DETAIL\";\n    PointColorType[PointColorType[\"POINT_INDEX\"] = 7] = \"POINT_INDEX\";\n    PointColorType[PointColorType[\"CLASSIFICATION\"] = 8] = \"CLASSIFICATION\";\n    PointColorType[PointColorType[\"RETURN_NUMBER\"] = 9] = \"RETURN_NUMBER\";\n    PointColorType[PointColorType[\"SOURCE\"] = 10] = \"SOURCE\";\n    PointColorType[PointColorType[\"NORMAL\"] = 11] = \"NORMAL\";\n    PointColorType[PointColorType[\"PHONG\"] = 12] = \"PHONG\";\n    PointColorType[PointColorType[\"RGB_HEIGHT\"] = 13] = \"RGB_HEIGHT\";\n    PointColorType[PointColorType[\"COMPOSITE\"] = 50] = \"COMPOSITE\";\n})(PointColorType || (PointColorType = {}));\nvar NormalFilteringMode;\n(function (NormalFilteringMode) {\n    NormalFilteringMode[NormalFilteringMode[\"ABSOLUTE_NORMAL_FILTERING_MODE\"] = 1] = \"ABSOLUTE_NORMAL_FILTERING_MODE\";\n    NormalFilteringMode[NormalFilteringMode[\"LESS_EQUAL_NORMAL_FILTERING_MODE\"] = 2] = \"LESS_EQUAL_NORMAL_FILTERING_MODE\";\n    NormalFilteringMode[NormalFilteringMode[\"GREATER_NORMAL_FILTERING_MODE\"] = 3] = \"GREATER_NORMAL_FILTERING_MODE\";\n})(NormalFilteringMode || (NormalFilteringMode = {}));\nvar PointCloudMixingMode;\n(function (PointCloudMixingMode) {\n    PointCloudMixingMode[PointCloudMixingMode[\"CHECKBOARD\"] = 1] = \"CHECKBOARD\";\n    PointCloudMixingMode[PointCloudMixingMode[\"STRIPES\"] = 2] = \"STRIPES\";\n})(PointCloudMixingMode || (PointCloudMixingMode = {}));\n\n;// CONCATENATED MODULE: ./src/constants.ts\n\nconst DEFAULT_RGB_BRIGHTNESS = 0;\nconst DEFAULT_RGB_CONTRAST = 0;\nconst DEFAULT_RGB_GAMMA = 1;\nconst DEFAULT_MAX_POINT_SIZE = 50;\nconst DEFAULT_MIN_NODE_PIXEL_SIZE = 50;\nconst DEFAULT_MIN_POINT_SIZE = 2;\nconst DEFAULT_PICK_WINDOW_SIZE = 15;\nconst DEFAULT_POINT_BUDGET = 1000000;\nconst MAX_LOADS_TO_GPU = 2;\nconst MAX_NUM_NODES_LOADING = 4;\nconst PERSPECTIVE_CAMERA = 'PerspectiveCamera';\nconst COLOR_BLACK = new external_three_.Color(0, 0, 0);\nconst DEFAULT_HIGHLIGHT_COLOR = new external_three_.Vector4(1, 0, 0, 1);\n\n;// CONCATENATED MODULE: ./src/utils/utils.ts\nfunction getIndexFromName(name) {\n    return parseInt(name.charAt(name.length - 1), 10);\n}\n/**\n * When passed to `[].sort`, sorts the array by level and index: r, r0, r3, r4, r01, r07, r30, ...\n */\nfunction byLevelAndIndex(a, b) {\n    const na = a.name;\n    const nb = b.name;\n    if (na.length !== nb.length) {\n        return na.length - nb.length;\n    }\n    else if (na < nb) {\n        return -1;\n    }\n    else if (na > nb) {\n        return 1;\n    }\n    else {\n        return 0;\n    }\n}\nfunction handleFailedRequest(response) {\n    if (response.status !== 200) {\n        throw Error('Response error');\n    }\n    return response;\n}\nfunction handleEmptyBuffer(buffer) {\n    if (!buffer || buffer.byteLength === 0) {\n        throw Error('Empty buffer');\n    }\n    return buffer;\n}\n\n;// CONCATENATED MODULE: ./src/materials/classification.ts\n\nconst DEFAULT_CLASSIFICATION = {\n    0: new external_three_.Vector4(0.5, 0.5, 0.5, 1.0),\n    1: new external_three_.Vector4(0.5, 0.5, 0.5, 1.0),\n    2: new external_three_.Vector4(0.63, 0.32, 0.18, 1.0),\n    3: new external_three_.Vector4(0.0, 1.0, 0.0, 1.0),\n    4: new external_three_.Vector4(0.0, 0.8, 0.0, 1.0),\n    5: new external_three_.Vector4(0.0, 0.6, 0.0, 1.0),\n    6: new external_three_.Vector4(1.0, 0.66, 0.0, 1.0),\n    7: new external_three_.Vector4(1.0, 0, 1.0, 1.0),\n    8: new external_three_.Vector4(1.0, 0, 0.0, 1.0),\n    9: new external_three_.Vector4(0.0, 0.0, 1.0, 1.0),\n    12: new external_three_.Vector4(1.0, 1.0, 0.0, 1.0),\n    DEFAULT: new external_three_.Vector4(0.3, 0.6, 0.6, 0.5),\n};\n\n;// CONCATENATED MODULE: ./src/materials/gradients/grayscale.ts\n\nconst GRAYSCALE = [\n    [0, new external_three_.Color(0, 0, 0)],\n    [1, new external_three_.Color(1, 1, 1)],\n];\n\n;// CONCATENATED MODULE: ./src/materials/gradients/inferno.ts\n\nconst INFERNO = [\n    [0.0, new external_three_.Color(0.077, 0.042, 0.206)],\n    [0.1, new external_three_.Color(0.225, 0.036, 0.388)],\n    [0.2, new external_three_.Color(0.373, 0.074, 0.432)],\n    [0.3, new external_three_.Color(0.522, 0.128, 0.42)],\n    [0.4, new external_three_.Color(0.665, 0.182, 0.37)],\n    [0.5, new external_three_.Color(0.797, 0.255, 0.287)],\n    [0.6, new external_three_.Color(0.902, 0.364, 0.184)],\n    [0.7, new external_three_.Color(0.969, 0.516, 0.063)],\n    [0.8, new external_three_.Color(0.988, 0.683, 0.072)],\n    [0.9, new external_three_.Color(0.961, 0.859, 0.298)],\n    [1.0, new external_three_.Color(0.988, 0.998, 0.645)],\n];\n\n;// CONCATENATED MODULE: ./src/materials/gradients/plasma.ts\n\nconst PLASMA = [\n    [0.0, new external_three_.Color(0.241, 0.015, 0.61)],\n    [0.1, new external_three_.Color(0.387, 0.001, 0.654)],\n    [0.2, new external_three_.Color(0.524, 0.025, 0.653)],\n    [0.3, new external_three_.Color(0.651, 0.125, 0.596)],\n    [0.4, new external_three_.Color(0.752, 0.227, 0.513)],\n    [0.5, new external_three_.Color(0.837, 0.329, 0.431)],\n    [0.6, new external_three_.Color(0.907, 0.435, 0.353)],\n    [0.7, new external_three_.Color(0.963, 0.554, 0.272)],\n    [0.8, new external_three_.Color(0.992, 0.681, 0.195)],\n    [0.9, new external_three_.Color(0.987, 0.822, 0.144)],\n    [1.0, new external_three_.Color(0.94, 0.975, 0.131)],\n];\n\n;// CONCATENATED MODULE: ./src/materials/gradients/rainbow.ts\n\nconst RAINBOW = [\n    [0, new external_three_.Color(0.278, 0, 0.714)],\n    [1 / 6, new external_three_.Color(0, 0, 1)],\n    [2 / 6, new external_three_.Color(0, 1, 1)],\n    [3 / 6, new external_three_.Color(0, 1, 0)],\n    [4 / 6, new external_three_.Color(1, 1, 0)],\n    [5 / 6, new external_three_.Color(1, 0.64, 0)],\n    [1, new external_three_.Color(1, 0, 0)],\n];\n\n;// CONCATENATED MODULE: ./src/materials/gradients/spectral.ts\n\n// From chroma spectral http://gka.github.io/chroma.js/\nconst SPECTRAL = [\n    [0, new external_three_.Color(0.3686, 0.3098, 0.6353)],\n    [0.1, new external_three_.Color(0.1961, 0.5333, 0.7412)],\n    [0.2, new external_three_.Color(0.4, 0.7608, 0.6471)],\n    [0.3, new external_three_.Color(0.6706, 0.8667, 0.6431)],\n    [0.4, new external_three_.Color(0.902, 0.9608, 0.5961)],\n    [0.5, new external_three_.Color(1.0, 1.0, 0.749)],\n    [0.6, new external_three_.Color(0.9961, 0.8784, 0.5451)],\n    [0.7, new external_three_.Color(0.9922, 0.6824, 0.3804)],\n    [0.8, new external_three_.Color(0.9569, 0.4275, 0.2627)],\n    [0.9, new external_three_.Color(0.8353, 0.2431, 0.3098)],\n    [1, new external_three_.Color(0.6196, 0.0039, 0.2588)],\n];\n\n;// CONCATENATED MODULE: ./src/materials/gradients/vidris.ts\n\nconst VIRIDIS = [\n    [0.0, new external_three_.Color(0.267, 0.005, 0.329)],\n    [0.1, new external_three_.Color(0.283, 0.141, 0.458)],\n    [0.2, new external_three_.Color(0.254, 0.265, 0.53)],\n    [0.3, new external_three_.Color(0.207, 0.372, 0.553)],\n    [0.4, new external_three_.Color(0.164, 0.471, 0.558)],\n    [0.5, new external_three_.Color(0.128, 0.567, 0.551)],\n    [0.6, new external_three_.Color(0.135, 0.659, 0.518)],\n    [0.7, new external_three_.Color(0.267, 0.749, 0.441)],\n    [0.8, new external_three_.Color(0.478, 0.821, 0.318)],\n    [0.9, new external_three_.Color(0.741, 0.873, 0.15)],\n    [1.0, new external_three_.Color(0.993, 0.906, 0.144)],\n];\n\n;// CONCATENATED MODULE: ./src/materials/gradients/yellow-green.ts\n\nconst YELLOW_GREEN = [\n    [0, new external_three_.Color(0.1647, 0.2824, 0.3451)],\n    [0.1, new external_three_.Color(0.1338, 0.3555, 0.4227)],\n    [0.2, new external_three_.Color(0.061, 0.4319, 0.4864)],\n    [0.3, new external_three_.Color(0.0, 0.5099, 0.5319)],\n    [0.4, new external_three_.Color(0.0, 0.5881, 0.5569)],\n    [0.5, new external_three_.Color(0.137, 0.665, 0.5614)],\n    [0.6, new external_three_.Color(0.2906, 0.7395, 0.5477)],\n    [0.7, new external_three_.Color(0.4453, 0.8099, 0.5201)],\n    [0.8, new external_three_.Color(0.6102, 0.8748, 0.485)],\n    [0.9, new external_three_.Color(0.7883, 0.9323, 0.4514)],\n    [1, new external_three_.Color(0.9804, 0.9804, 0.4314)],\n];\n\n;// CONCATENATED MODULE: ./src/materials/gradients/index.ts\n\n\n\n\n\n\n\n\n;// CONCATENATED MODULE: ./src/materials/texture-generation.ts\n\nfunction generateDataTexture(width, height, color) {\n    const size = width * height;\n    const data = new Uint8Array(4 * size);\n    const r = Math.floor(color.r * 255);\n    const g = Math.floor(color.g * 255);\n    const b = Math.floor(color.b * 255);\n    for (let i = 0; i < size; i++) {\n        data[i * 3] = r;\n        data[i * 3 + 1] = g;\n        data[i * 3 + 2] = b;\n    }\n    const texture = new external_three_.DataTexture(data, width, height, external_three_.RGBAFormat);\n    texture.needsUpdate = true;\n    texture.magFilter = external_three_.NearestFilter;\n    return texture;\n}\nfunction generateGradientTexture(gradient) {\n    const size = 64;\n    const canvas = document.createElement('canvas');\n    canvas.width = size;\n    canvas.height = size;\n    const context = canvas.getContext('2d');\n    context.rect(0, 0, size, size);\n    const ctxGradient = context.createLinearGradient(0, 0, size, size);\n    for (let i = 0; i < gradient.length; i++) {\n        const step = gradient[i];\n        ctxGradient.addColorStop(step[0], `#${step[1].getHexString()}`);\n    }\n    context.fillStyle = ctxGradient;\n    context.fill();\n    const texture = new external_three_.CanvasTexture(canvas);\n    texture.needsUpdate = true;\n    texture.minFilter = external_three_.LinearFilter;\n    // textureImage = texture.image;\n    return texture;\n}\nfunction generateClassificationTexture(classification) {\n    const width = 256;\n    const height = 256;\n    const size = width * height;\n    const data = new Uint8Array(4 * size);\n    for (let x = 0; x < width; x++) {\n        for (let y = 0; y < height; y++) {\n            const i = x + width * y;\n            let color;\n            if (classification[x]) {\n                color = classification[x];\n            }\n            else if (classification[x % 32]) {\n                color = classification[x % 32];\n            }\n            else {\n                color = classification.DEFAULT;\n            }\n            data[4 * i + 0] = 255 * color.x;\n            data[4 * i + 1] = 255 * color.y;\n            data[4 * i + 2] = 255 * color.z;\n            data[4 * i + 3] = 255 * color.w;\n        }\n    }\n    const texture = new external_three_.DataTexture(data, width, height, external_three_.RGBAFormat);\n    texture.magFilter = external_three_.NearestFilter;\n    texture.needsUpdate = true;\n    return texture;\n}\n\n;// CONCATENATED MODULE: ./src/materials/point-cloud-material.ts\nvar __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n\n\n\n\n\n\n\nconst TREE_TYPE_DEFS = {\n    [TreeType.OCTREE]: 'tree_type_octree',\n    [TreeType.KDTREE]: 'tree_type_kdtree',\n};\nconst SIZE_TYPE_DEFS = {\n    [PointSizeType.FIXED]: 'fixed_point_size',\n    [PointSizeType.ATTENUATED]: 'attenuated_point_size',\n    [PointSizeType.ADAPTIVE]: 'adaptive_point_size',\n};\nconst OPACITY_DEFS = {\n    [PointOpacityType.ATTENUATED]: 'attenuated_opacity',\n    [PointOpacityType.FIXED]: 'fixed_opacity',\n};\nconst SHAPE_DEFS = {\n    [PointShape.SQUARE]: 'square_point_shape',\n    [PointShape.CIRCLE]: 'circle_point_shape',\n    [PointShape.PARABOLOID]: 'paraboloid_point_shape',\n};\nconst COLOR_DEFS = {\n    [PointColorType.RGB]: 'color_type_rgb',\n    [PointColorType.COLOR]: 'color_type_color',\n    [PointColorType.DEPTH]: 'color_type_depth',\n    [PointColorType.HEIGHT]: 'color_type_height',\n    [PointColorType.INTENSITY]: 'color_type_intensity',\n    [PointColorType.INTENSITY_GRADIENT]: 'color_type_intensity_gradient',\n    [PointColorType.LOD]: 'color_type_lod',\n    [PointColorType.POINT_INDEX]: 'color_type_point_index',\n    [PointColorType.CLASSIFICATION]: 'color_type_classification',\n    [PointColorType.RETURN_NUMBER]: 'color_type_return_number',\n    [PointColorType.SOURCE]: 'color_type_source',\n    [PointColorType.NORMAL]: 'color_type_normal',\n    [PointColorType.PHONG]: 'color_type_phong',\n    [PointColorType.RGB_HEIGHT]: 'color_type_rgb_height',\n    [PointColorType.COMPOSITE]: 'color_type_composite',\n};\nconst CLIP_MODE_DEFS = {\n    [ClipMode.DISABLED]: 'clip_disabled',\n    [ClipMode.CLIP_OUTSIDE]: 'clip_outside',\n    [ClipMode.HIGHLIGHT_INSIDE]: 'clip_highlight_inside',\n    [ClipMode.CLIP_HORIZONTALLY]: 'clip_horizontally',\n    [ClipMode.CLIP_VERTICALLY]: 'clip_vertically',\n};\nclass PointCloudMaterial extends external_three_.RawShaderMaterial {\n    constructor(parameters = {}) {\n        super();\n        /**\n         * Use the drawing buffer size instead of the dom client width and height when passing the screen height and screen width uniforms to the\n         * shader. This is useful if you have offscreen canvases (which in some browsers return 0 as client width and client height).\n         */\n        this.useDrawingBufferSize = false;\n        this.lights = false;\n        this.fog = false;\n        this.colorRgba = false;\n        this.numClipBoxes = 0;\n        this.clipBoxes = [];\n        this.visibleNodeTextureOffsets = new Map();\n        this._gradient = SPECTRAL;\n        this.gradientTexture = generateGradientTexture(this._gradient);\n        this._classification = DEFAULT_CLASSIFICATION;\n        this.classificationTexture = generateClassificationTexture(this._classification);\n        this.uniforms = {\n            bbSize: makeUniform('fv', [0, 0, 0]),\n            blendDepthSupplement: makeUniform('f', 0.0),\n            blendHardness: makeUniform('f', 2.0),\n            classificationLUT: makeUniform('t', this.classificationTexture || new external_three_.Texture()),\n            clipBoxCount: makeUniform('f', 0),\n            clipBoxes: makeUniform('Matrix4fv', []),\n            clipExtent: makeUniform('fv', [0.0, 0.0, 1.0, 1.0]),\n            depthMap: makeUniform('t', null),\n            diffuse: makeUniform('fv', [1, 1, 1]),\n            fov: makeUniform('f', 1.0),\n            gradient: makeUniform('t', this.gradientTexture || new external_three_.Texture()),\n            heightMax: makeUniform('f', 1.0),\n            heightMin: makeUniform('f', 0.0),\n            intensityBrightness: makeUniform('f', 0),\n            intensityContrast: makeUniform('f', 0),\n            intensityGamma: makeUniform('f', 1),\n            intensityRange: makeUniform('fv', [0, 65000]),\n            isLeafNode: makeUniform('b', 0),\n            level: makeUniform('f', 0.0),\n            maxSize: makeUniform('f', DEFAULT_MAX_POINT_SIZE),\n            minSize: makeUniform('f', DEFAULT_MIN_POINT_SIZE),\n            octreeSize: makeUniform('f', 0),\n            opacity: makeUniform('f', 1.0),\n            pcIndex: makeUniform('f', 0),\n            rgbBrightness: makeUniform('f', DEFAULT_RGB_BRIGHTNESS),\n            rgbContrast: makeUniform('f', DEFAULT_RGB_CONTRAST),\n            rgbGamma: makeUniform('f', DEFAULT_RGB_GAMMA),\n            screenHeight: makeUniform('f', 1.0),\n            screenWidth: makeUniform('f', 1.0),\n            size: makeUniform('f', 1),\n            spacing: makeUniform('f', 1.0),\n            toModel: makeUniform('Matrix4f', []),\n            transition: makeUniform('f', 0.5),\n            uColor: makeUniform('c', new external_three_.Color(0xffffff)),\n            // @ts-ignore\n            visibleNodes: makeUniform('t', this.visibleNodesTexture || new external_three_.Texture()),\n            vnStart: makeUniform('f', 0.0),\n            wClassification: makeUniform('f', 0),\n            wElevation: makeUniform('f', 0),\n            wIntensity: makeUniform('f', 0),\n            wReturnNumber: makeUniform('f', 0),\n            wRGB: makeUniform('f', 1),\n            wSourceID: makeUniform('f', 0),\n            opacityAttenuation: makeUniform('f', 1),\n            filterByNormalThreshold: makeUniform('f', 0),\n            highlightedPointCoordinate: makeUniform('fv', new external_three_.Vector3()),\n            highlightedPointColor: makeUniform('fv', DEFAULT_HIGHLIGHT_COLOR.clone()),\n            enablePointHighlighting: makeUniform('b', true),\n            highlightedPointScale: makeUniform('f', 2.0),\n            backgroundMap: makeUniform('t', null),\n            normalFilteringMode: makeUniform('i', NormalFilteringMode.ABSOLUTE_NORMAL_FILTERING_MODE),\n            pointCloudID: makeUniform('f', 2),\n            pointCloudMixingMode: makeUniform('i', PointCloudMixingMode.CHECKBOARD),\n            stripeDistanceX: makeUniform('f', 5),\n            stripeDistanceY: makeUniform('f', 5),\n            stripeDivisorX: makeUniform('f', 2),\n            stripeDivisorY: makeUniform('f', 2),\n            pointCloudMixAngle: makeUniform('f', 31),\n        };\n        this.useClipBox = false;\n        this.weighted = false;\n        this.pointColorType = PointColorType.RGB;\n        this.pointSizeType = PointSizeType.ADAPTIVE;\n        this.clipMode = ClipMode.DISABLED;\n        this.useEDL = false;\n        this.shape = PointShape.SQUARE;\n        this.treeType = TreeType.OCTREE;\n        this.pointOpacityType = PointOpacityType.FIXED;\n        this.useFilterByNormal = false;\n        this.useTextureBlending = false;\n        this.usePointCloudMixing = false;\n        this.highlightPoint = false;\n        this.attributes = {\n            position: { type: 'fv', value: [] },\n            color: { type: 'fv', value: [] },\n            normal: { type: 'fv', value: [] },\n            intensity: { type: 'f', value: [] },\n            classification: { type: 'f', value: [] },\n            returnNumber: { type: 'f', value: [] },\n            numberOfReturns: { type: 'f', value: [] },\n            pointSourceID: { type: 'f', value: [] },\n            indices: { type: 'fv', value: [] },\n        };\n        const tex = (this.visibleNodesTexture = generateDataTexture(2048, 1, new external_three_.Color(0xffffff)));\n        tex.minFilter = external_three_.NearestFilter;\n        tex.magFilter = external_three_.NearestFilter;\n        this.setUniform('visibleNodes', tex);\n        this.treeType = getValid(parameters.treeType, TreeType.OCTREE);\n        this.size = getValid(parameters.size, 1.0);\n        this.minSize = getValid(parameters.minSize, 2.0);\n        this.maxSize = getValid(parameters.maxSize, 50.0);\n        this.colorRgba = Boolean(parameters.colorRgba);\n        this.classification = DEFAULT_CLASSIFICATION;\n        this.defaultAttributeValues.normal = [0, 0, 0];\n        this.defaultAttributeValues.classification = [0, 0, 0];\n        this.defaultAttributeValues.indices = [0, 0, 0, 0];\n        this.vertexColors = true;\n        this.updateShaderSource();\n    }\n    dispose() {\n        super.dispose();\n        if (this.gradientTexture) {\n            this.gradientTexture.dispose();\n            this.gradientTexture = undefined;\n        }\n        if (this.visibleNodesTexture) {\n            this.visibleNodesTexture.dispose();\n            this.visibleNodesTexture = undefined;\n        }\n        this.clearVisibleNodeTextureOffsets();\n        if (this.classificationTexture) {\n            this.classificationTexture.dispose();\n            this.classificationTexture = undefined;\n        }\n        if (this.depthMap) {\n            this.depthMap.dispose();\n            this.depthMap = undefined;\n        }\n        if (this.backgroundMap) {\n            this.backgroundMap.dispose();\n            this.backgroundMap = undefined;\n        }\n    }\n    clearVisibleNodeTextureOffsets() {\n        this.visibleNodeTextureOffsets.clear();\n    }\n    updateShaderSource() {\n        this.vertexShader = this.applyDefines((__webpack_require__(245)/* [\"default\"] */ .A));\n        this.fragmentShader = this.applyDefines((__webpack_require__(168)/* [\"default\"] */ .A));\n        if (this.opacity === 1.0) {\n            this.blending = external_three_.NoBlending;\n            this.transparent = false;\n            this.depthTest = true;\n            this.depthWrite = true;\n            this.depthFunc = external_three_.LessEqualDepth;\n        }\n        else if (this.opacity < 1.0 && !this.useEDL) {\n            this.blending = external_three_.AdditiveBlending;\n            this.transparent = true;\n            this.depthTest = false;\n            this.depthWrite = true;\n        }\n        if (this.weighted) {\n            this.blending = external_three_.AdditiveBlending;\n            this.transparent = true;\n            this.depthTest = true;\n            this.depthWrite = false;\n            this.depthFunc = external_three_.LessEqualDepth;\n        }\n        this.needsUpdate = true;\n    }\n    applyDefines(shaderSrc) {\n        const parts = [];\n        function define(value) {\n            if (value) {\n                parts.push(`#define ${value}`);\n            }\n        }\n        define(TREE_TYPE_DEFS[this.treeType]);\n        define(SIZE_TYPE_DEFS[this.pointSizeType]);\n        define(SHAPE_DEFS[this.shape]);\n        define(COLOR_DEFS[this.pointColorType]);\n        define(CLIP_MODE_DEFS[this.clipMode]);\n        define(OPACITY_DEFS[this.pointOpacityType]);\n        // We only perform gamma and brightness/contrast calculations per point if values are specified.\n        if (this.rgbGamma !== DEFAULT_RGB_GAMMA ||\n            this.rgbBrightness !== DEFAULT_RGB_BRIGHTNESS ||\n            this.rgbContrast !== DEFAULT_RGB_CONTRAST) {\n            define('use_rgb_gamma_contrast_brightness');\n        }\n        if (this.useFilterByNormal) {\n            define('use_filter_by_normal');\n        }\n        if (this.useEDL) {\n            define('use_edl');\n        }\n        if (this.weighted) {\n            define('weighted_splats');\n        }\n        if (this.numClipBoxes > 0) {\n            define('use_clip_box');\n        }\n        if (this.highlightPoint) {\n            define('highlight_point');\n        }\n        if (this.useTextureBlending) {\n            define('use_texture_blending');\n        }\n        if (this.usePointCloudMixing) {\n            define('use_point_cloud_mixing');\n        }\n        if (this.colorRgba) {\n            define('color_rgba');\n        }\n        define('MAX_POINT_LIGHTS 0');\n        define('MAX_DIR_LIGHTS 0');\n        parts.push(shaderSrc);\n        return parts.join('\\n');\n    }\n    setPointCloudMixingMode(mode) {\n        this.pointCloudMixingMode = mode;\n    }\n    getPointCloudMixingMode() {\n        if (this.pointCloudMixingMode === PointCloudMixingMode.STRIPES) {\n            return PointCloudMixingMode.STRIPES;\n        }\n        return PointCloudMixingMode.CHECKBOARD;\n    }\n    setClipBoxes(clipBoxes) {\n        if (!clipBoxes) {\n            return;\n        }\n        this.clipBoxes = clipBoxes;\n        const doUpdate = this.numClipBoxes !== clipBoxes.length && (clipBoxes.length === 0 || this.numClipBoxes === 0);\n        this.numClipBoxes = clipBoxes.length;\n        this.setUniform('clipBoxCount', this.numClipBoxes);\n        if (doUpdate) {\n            this.updateShaderSource();\n        }\n        const clipBoxesLength = this.numClipBoxes * 16;\n        const clipBoxesArray = new Float32Array(clipBoxesLength);\n        for (let i = 0; i < this.numClipBoxes; i++) {\n            clipBoxesArray.set(clipBoxes[i].inverse.elements, 16 * i);\n        }\n        for (let i = 0; i < clipBoxesLength; i++) {\n            if (isNaN(clipBoxesArray[i])) {\n                clipBoxesArray[i] = Infinity;\n            }\n        }\n        this.setUniform('clipBoxes', clipBoxesArray);\n    }\n    get gradient() {\n        return this._gradient;\n    }\n    set gradient(value) {\n        if (this._gradient !== value) {\n            this._gradient = value;\n            this.gradientTexture = generateGradientTexture(this._gradient);\n            this.setUniform('gradient', this.gradientTexture);\n        }\n    }\n    get classification() {\n        return this._classification;\n    }\n    set classification(value) {\n        const copy = {};\n        for (const key of Object.keys(value)) {\n            copy[key] = value[key].clone();\n        }\n        let isEqual = false;\n        if (this._classification === undefined) {\n            isEqual = false;\n        }\n        else {\n            isEqual = Object.keys(copy).length === Object.keys(this._classification).length;\n            for (const key of Object.keys(copy)) {\n                isEqual = isEqual && this._classification[key] !== undefined;\n                isEqual = isEqual && copy[key].equals(this._classification[key]);\n            }\n        }\n        if (!isEqual) {\n            this._classification = copy;\n            this.recomputeClassification();\n        }\n    }\n    recomputeClassification() {\n        this.classificationTexture = generateClassificationTexture(this._classification);\n        this.setUniform('classificationLUT', this.classificationTexture);\n    }\n    get elevationRange() {\n        return [this.heightMin, this.heightMax];\n    }\n    set elevationRange(value) {\n        this.heightMin = value[0];\n        this.heightMax = value[1];\n    }\n    getUniform(name) {\n        return this.uniforms === undefined ? undefined : this.uniforms[name].value;\n    }\n    setUniform(name, value) {\n        if (this.uniforms === undefined) {\n            return;\n        }\n        const uObj = this.uniforms[name];\n        if (uObj.type === 'c') {\n            uObj.value.copy(value);\n        }\n        else if (value !== uObj.value) {\n            uObj.value = value;\n        }\n    }\n    updateMaterial(octree, visibleNodes, camera, renderer) {\n        const pixelRatio = renderer.getPixelRatio();\n        if (camera.type === PERSPECTIVE_CAMERA) {\n            this.fov = camera.fov * (Math.PI / 180);\n        }\n        else {\n            this.fov = Math.PI / 2; // will result in slope = 1 in the shader\n        }\n        const renderTarget = renderer.getRenderTarget();\n        if (renderTarget !== null) {\n            this.screenWidth = renderTarget.width;\n            this.screenHeight = renderTarget.height;\n        }\n        else {\n            this.screenWidth = renderer.domElement.clientWidth * pixelRatio;\n            this.screenHeight = renderer.domElement.clientHeight * pixelRatio;\n        }\n        if (this.useDrawingBufferSize) {\n            renderer.getDrawingBufferSize(PointCloudMaterial.helperVec2);\n            this.screenWidth = PointCloudMaterial.helperVec2.width;\n            this.screenHeight = PointCloudMaterial.helperVec2.height;\n        }\n        const maxScale = Math.max(octree.scale.x, octree.scale.y, octree.scale.z);\n        this.spacing = octree.pcoGeometry.spacing * maxScale;\n        this.octreeSize = octree.pcoGeometry.boundingBox.getSize(PointCloudMaterial.helperVec3).x;\n        if (this.pointSizeType === PointSizeType.ADAPTIVE ||\n            this.pointColorType === PointColorType.LOD) {\n            this.updateVisibilityTextureData(visibleNodes);\n        }\n    }\n    updateVisibilityTextureData(nodes) {\n        nodes.sort(byLevelAndIndex);\n        const data = new Uint8Array(nodes.length * 4);\n        const offsetsToChild = new Array(nodes.length).fill(Infinity);\n        this.visibleNodeTextureOffsets.clear();\n        for (let i = 0; i < nodes.length; i++) {\n            const node = nodes[i];\n            this.visibleNodeTextureOffsets.set(node.name, i);\n            if (i > 0) {\n                const parentName = node.name.slice(0, -1);\n                const parentOffset = this.visibleNodeTextureOffsets.get(parentName);\n                const parentOffsetToChild = i - parentOffset;\n                offsetsToChild[parentOffset] = Math.min(offsetsToChild[parentOffset], parentOffsetToChild);\n                // tslint:disable:no-bitwise\n                const offset = parentOffset * 4;\n                data[offset] = data[offset] | (1 << node.index);\n                data[offset + 1] = offsetsToChild[parentOffset] >> 8;\n                data[offset + 2] = offsetsToChild[parentOffset] % 256;\n                // tslint:enable:no-bitwise\n            }\n            data[i * 4 + 3] = node.name.length;\n        }\n        const texture = this.visibleNodesTexture;\n        if (texture) {\n            texture.image.data.set(data);\n            texture.needsUpdate = true;\n        }\n    }\n    static makeOnBeforeRender(octree, node, pcIndex) {\n        return (_renderer, _scene, _camera, _geometry, material) => {\n            const pointCloudMaterial = material;\n            const materialUniforms = pointCloudMaterial.uniforms;\n            materialUniforms.level.value = node.level;\n            materialUniforms.isLeafNode.value = node.isLeafNode;\n            const vnStart = pointCloudMaterial.visibleNodeTextureOffsets.get(node.name);\n            if (vnStart !== undefined) {\n                materialUniforms.vnStart.value = vnStart;\n            }\n            materialUniforms.pcIndex.value =\n                pcIndex !== undefined ? pcIndex : octree.visibleNodes.indexOf(node);\n            // Note: when changing uniforms in onBeforeRender, the flag uniformsNeedUpdate has to be\n            // set to true to instruct ThreeJS to upload them. See also\n            // https://github.com/mrdoob/three.js/issues/9870#issuecomment-368750182.\n            // Remove the cast to any after updating to Three.JS >= r113\n            material /*ShaderMaterial*/.uniformsNeedUpdate = true;\n        };\n    }\n}\nPointCloudMaterial.helperVec3 = new external_three_.Vector3();\nPointCloudMaterial.helperVec2 = new external_three_.Vector2();\n__decorate([\n    uniform('bbSize')\n], PointCloudMaterial.prototype, \"bbSize\", void 0);\n__decorate([\n    uniform('clipExtent')\n], PointCloudMaterial.prototype, \"clipExtent\", void 0);\n__decorate([\n    uniform('depthMap')\n], PointCloudMaterial.prototype, \"depthMap\", void 0);\n__decorate([\n    uniform('fov')\n], PointCloudMaterial.prototype, \"fov\", void 0);\n__decorate([\n    uniform('heightMax')\n], PointCloudMaterial.prototype, \"heightMax\", void 0);\n__decorate([\n    uniform('heightMin')\n], PointCloudMaterial.prototype, \"heightMin\", void 0);\n__decorate([\n    uniform('intensityBrightness')\n], PointCloudMaterial.prototype, \"intensityBrightness\", void 0);\n__decorate([\n    uniform('intensityContrast')\n], PointCloudMaterial.prototype, \"intensityContrast\", void 0);\n__decorate([\n    uniform('intensityGamma')\n], PointCloudMaterial.prototype, \"intensityGamma\", void 0);\n__decorate([\n    uniform('intensityRange')\n], PointCloudMaterial.prototype, \"intensityRange\", void 0);\n__decorate([\n    uniform('maxSize')\n], PointCloudMaterial.prototype, \"maxSize\", void 0);\n__decorate([\n    uniform('minSize')\n], PointCloudMaterial.prototype, \"minSize\", void 0);\n__decorate([\n    uniform('octreeSize')\n], PointCloudMaterial.prototype, \"octreeSize\", void 0);\n__decorate([\n    uniform('opacity', true)\n], PointCloudMaterial.prototype, \"opacity\", void 0);\n__decorate([\n    uniform('rgbBrightness', true)\n], PointCloudMaterial.prototype, \"rgbBrightness\", void 0);\n__decorate([\n    uniform('rgbContrast', true)\n], PointCloudMaterial.prototype, \"rgbContrast\", void 0);\n__decorate([\n    uniform('rgbGamma', true)\n], PointCloudMaterial.prototype, \"rgbGamma\", void 0);\n__decorate([\n    uniform('screenHeight')\n], PointCloudMaterial.prototype, \"screenHeight\", void 0);\n__decorate([\n    uniform('screenWidth')\n], PointCloudMaterial.prototype, \"screenWidth\", void 0);\n__decorate([\n    uniform('size')\n], PointCloudMaterial.prototype, \"size\", void 0);\n__decorate([\n    uniform('spacing')\n], PointCloudMaterial.prototype, \"spacing\", void 0);\n__decorate([\n    uniform('transition')\n], PointCloudMaterial.prototype, \"transition\", void 0);\n__decorate([\n    uniform('uColor')\n], PointCloudMaterial.prototype, \"color\", void 0);\n__decorate([\n    uniform('wClassification')\n], PointCloudMaterial.prototype, \"weightClassification\", void 0);\n__decorate([\n    uniform('wElevation')\n], PointCloudMaterial.prototype, \"weightElevation\", void 0);\n__decorate([\n    uniform('wIntensity')\n], PointCloudMaterial.prototype, \"weightIntensity\", void 0);\n__decorate([\n    uniform('wReturnNumber')\n], PointCloudMaterial.prototype, \"weightReturnNumber\", void 0);\n__decorate([\n    uniform('wRGB')\n], PointCloudMaterial.prototype, \"weightRGB\", void 0);\n__decorate([\n    uniform('wSourceID')\n], PointCloudMaterial.prototype, \"weightSourceID\", void 0);\n__decorate([\n    uniform('opacityAttenuation')\n], PointCloudMaterial.prototype, \"opacityAttenuation\", void 0);\n__decorate([\n    uniform('filterByNormalThreshold')\n], PointCloudMaterial.prototype, \"filterByNormalThreshold\", void 0);\n__decorate([\n    uniform('highlightedPointCoordinate')\n], PointCloudMaterial.prototype, \"highlightedPointCoordinate\", void 0);\n__decorate([\n    uniform('highlightedPointColor')\n], PointCloudMaterial.prototype, \"highlightedPointColor\", void 0);\n__decorate([\n    uniform('enablePointHighlighting')\n], PointCloudMaterial.prototype, \"enablePointHighlighting\", void 0);\n__decorate([\n    uniform('highlightedPointScale')\n], PointCloudMaterial.prototype, \"highlightedPointScale\", void 0);\n__decorate([\n    uniform('normalFilteringMode')\n], PointCloudMaterial.prototype, \"normalFilteringMode\", void 0);\n__decorate([\n    uniform('backgroundMap')\n], PointCloudMaterial.prototype, \"backgroundMap\", void 0);\n__decorate([\n    uniform('pointCloudID')\n], PointCloudMaterial.prototype, \"pointCloudID\", void 0);\n__decorate([\n    uniform('pointCloudMixingMode')\n], PointCloudMaterial.prototype, \"pointCloudMixingMode\", void 0);\n__decorate([\n    uniform('stripeDistanceX')\n], PointCloudMaterial.prototype, \"stripeDistanceX\", void 0);\n__decorate([\n    uniform('stripeDistanceY')\n], PointCloudMaterial.prototype, \"stripeDistanceY\", void 0);\n__decorate([\n    uniform('stripeDivisorX')\n], PointCloudMaterial.prototype, \"stripeDivisorX\", void 0);\n__decorate([\n    uniform('stripeDivisorY')\n], PointCloudMaterial.prototype, \"stripeDivisorY\", void 0);\n__decorate([\n    uniform('pointCloudMixAngle')\n], PointCloudMaterial.prototype, \"pointCloudMixAngle\", void 0);\n__decorate([\n    requiresShaderUpdate()\n], PointCloudMaterial.prototype, \"useClipBox\", void 0);\n__decorate([\n    requiresShaderUpdate()\n], PointCloudMaterial.prototype, \"weighted\", void 0);\n__decorate([\n    requiresShaderUpdate()\n], PointCloudMaterial.prototype, \"pointColorType\", void 0);\n__decorate([\n    requiresShaderUpdate()\n], PointCloudMaterial.prototype, \"pointSizeType\", void 0);\n__decorate([\n    requiresShaderUpdate()\n], PointCloudMaterial.prototype, \"clipMode\", void 0);\n__decorate([\n    requiresShaderUpdate()\n], PointCloudMaterial.prototype, \"useEDL\", void 0);\n__decorate([\n    requiresShaderUpdate()\n], PointCloudMaterial.prototype, \"shape\", void 0);\n__decorate([\n    requiresShaderUpdate()\n], PointCloudMaterial.prototype, \"treeType\", void 0);\n__decorate([\n    requiresShaderUpdate()\n], PointCloudMaterial.prototype, \"pointOpacityType\", void 0);\n__decorate([\n    requiresShaderUpdate()\n], PointCloudMaterial.prototype, \"useFilterByNormal\", void 0);\n__decorate([\n    requiresShaderUpdate()\n], PointCloudMaterial.prototype, \"useTextureBlending\", void 0);\n__decorate([\n    requiresShaderUpdate()\n], PointCloudMaterial.prototype, \"usePointCloudMixing\", void 0);\n__decorate([\n    requiresShaderUpdate()\n], PointCloudMaterial.prototype, \"highlightPoint\", void 0);\nfunction makeUniform(type, value) {\n    return { type, value };\n}\nfunction getValid(a, b) {\n    return a === undefined ? b : a;\n}\n// tslint:disable:no-invalid-this\nfunction uniform(uniformName, requireSrcUpdate = false) {\n    return (target, propertyKey) => {\n        Object.defineProperty(target, propertyKey, {\n            get() {\n                return this.getUniform(uniformName);\n            },\n            set(value) {\n                if (value !== this.getUniform(uniformName)) {\n                    this.setUniform(uniformName, value);\n                    if (requireSrcUpdate) {\n                        this.updateShaderSource();\n                    }\n                }\n            },\n        });\n    };\n}\nfunction requiresShaderUpdate() {\n    return (target, propertyKey) => {\n        const fieldName = `_${propertyKey.toString()}`;\n        Object.defineProperty(target, propertyKey, {\n            get() {\n                return this[fieldName];\n            },\n            set(value) {\n                if (value !== this[fieldName]) {\n                    this[fieldName] = value;\n                    this.updateShaderSource();\n                }\n            },\n        });\n    };\n}\n\n;// CONCATENATED MODULE: ./src/materials/index.ts\n\n\n\n\n\n\n\n\n;// CONCATENATED MODULE: ./src/point-attributes.ts\n// -------------------------------------------------------------------------------------------------\n// Converted to Typescript and adapted from https://github.com/potree/potree\n// -------------------------------------------------------------------------------------------------\nvar PointAttributeName;\n(function (PointAttributeName) {\n    PointAttributeName[PointAttributeName[\"POSITION_CARTESIAN\"] = 0] = \"POSITION_CARTESIAN\";\n    PointAttributeName[PointAttributeName[\"COLOR_PACKED\"] = 1] = \"COLOR_PACKED\";\n    PointAttributeName[PointAttributeName[\"COLOR_FLOATS_1\"] = 2] = \"COLOR_FLOATS_1\";\n    PointAttributeName[PointAttributeName[\"COLOR_FLOATS_255\"] = 3] = \"COLOR_FLOATS_255\";\n    PointAttributeName[PointAttributeName[\"NORMAL_FLOATS\"] = 4] = \"NORMAL_FLOATS\";\n    PointAttributeName[PointAttributeName[\"FILLER\"] = 5] = \"FILLER\";\n    PointAttributeName[PointAttributeName[\"INTENSITY\"] = 6] = \"INTENSITY\";\n    PointAttributeName[PointAttributeName[\"CLASSIFICATION\"] = 7] = \"CLASSIFICATION\";\n    PointAttributeName[PointAttributeName[\"NORMAL_SPHEREMAPPED\"] = 8] = \"NORMAL_SPHEREMAPPED\";\n    PointAttributeName[PointAttributeName[\"NORMAL_OCT16\"] = 9] = \"NORMAL_OCT16\";\n    PointAttributeName[PointAttributeName[\"NORMAL\"] = 10] = \"NORMAL\";\n})(PointAttributeName || (PointAttributeName = {}));\nconst POINT_ATTRIBUTE_TYPES = {\n    DATA_TYPE_DOUBLE: { ordinal: 0, size: 8 },\n    DATA_TYPE_FLOAT: { ordinal: 1, size: 4 },\n    DATA_TYPE_INT8: { ordinal: 2, size: 1 },\n    DATA_TYPE_UINT8: { ordinal: 3, size: 1 },\n    DATA_TYPE_INT16: { ordinal: 4, size: 2 },\n    DATA_TYPE_UINT16: { ordinal: 5, size: 2 },\n    DATA_TYPE_INT32: { ordinal: 6, size: 4 },\n    DATA_TYPE_UINT32: { ordinal: 7, size: 4 },\n    DATA_TYPE_INT64: { ordinal: 8, size: 8 },\n    DATA_TYPE_UINT64: { ordinal: 9, size: 8 },\n};\nfunction makePointAttribute(name, type, numElements) {\n    return {\n        name,\n        type,\n        numElements,\n        byteSize: numElements * type.size,\n    };\n}\nconst RGBA_PACKED = makePointAttribute(PointAttributeName.COLOR_PACKED, POINT_ATTRIBUTE_TYPES.DATA_TYPE_INT8, 4);\nconst POINT_ATTRIBUTES = {\n    POSITION_CARTESIAN: makePointAttribute(PointAttributeName.POSITION_CARTESIAN, POINT_ATTRIBUTE_TYPES.DATA_TYPE_FLOAT, 3),\n    RGBA_PACKED,\n    COLOR_PACKED: RGBA_PACKED,\n    RGB_PACKED: makePointAttribute(PointAttributeName.COLOR_PACKED, POINT_ATTRIBUTE_TYPES.DATA_TYPE_INT8, 3),\n    NORMAL_FLOATS: makePointAttribute(PointAttributeName.NORMAL_FLOATS, POINT_ATTRIBUTE_TYPES.DATA_TYPE_FLOAT, 3),\n    FILLER_1B: makePointAttribute(PointAttributeName.FILLER, POINT_ATTRIBUTE_TYPES.DATA_TYPE_UINT8, 1),\n    INTENSITY: makePointAttribute(PointAttributeName.INTENSITY, POINT_ATTRIBUTE_TYPES.DATA_TYPE_UINT16, 1),\n    CLASSIFICATION: makePointAttribute(PointAttributeName.CLASSIFICATION, POINT_ATTRIBUTE_TYPES.DATA_TYPE_UINT8, 1),\n    NORMAL_SPHEREMAPPED: makePointAttribute(PointAttributeName.NORMAL_SPHEREMAPPED, POINT_ATTRIBUTE_TYPES.DATA_TYPE_UINT8, 2),\n    NORMAL_OCT16: makePointAttribute(PointAttributeName.NORMAL_OCT16, POINT_ATTRIBUTE_TYPES.DATA_TYPE_UINT8, 2),\n    NORMAL: makePointAttribute(PointAttributeName.NORMAL, POINT_ATTRIBUTE_TYPES.DATA_TYPE_FLOAT, 3),\n};\nclass PointAttributes {\n    constructor(pointAttributeNames = []) {\n        this.attributes = [];\n        this.byteSize = 0;\n        this.size = 0;\n        for (let i = 0; i < pointAttributeNames.length; i++) {\n            const pointAttributeName = pointAttributeNames[i];\n            const pointAttribute = POINT_ATTRIBUTES[pointAttributeName];\n            this.attributes.push(pointAttribute);\n            this.byteSize += pointAttribute.byteSize;\n            this.size++;\n        }\n    }\n    add(pointAttribute) {\n        this.attributes.push(pointAttribute);\n        this.byteSize += pointAttribute.byteSize;\n        this.size++;\n    }\n    hasColors() {\n        return this.attributes.find(isColorAttribute) !== undefined;\n    }\n    hasNormals() {\n        return this.attributes.find(isNormalAttribute) !== undefined;\n    }\n}\nfunction isColorAttribute({ name }) {\n    return name === PointAttributeName.COLOR_PACKED;\n}\nfunction isNormalAttribute({ name }) {\n    return (name === PointAttributeName.NORMAL_SPHEREMAPPED ||\n        name === PointAttributeName.NORMAL_FLOATS ||\n        name === PointAttributeName.NORMAL ||\n        name === PointAttributeName.NORMAL_OCT16);\n}\n\n;// CONCATENATED MODULE: ./src/utils/bounds.ts\n\n/**\n * adapted from mhluska at https://github.com/mrdoob/three.js/issues/1561\n */\nfunction computeTransformedBoundingBox(box, transform) {\n    return new external_three_.Box3().setFromPoints([\n        new external_three_.Vector3(box.min.x, box.min.y, box.min.z).applyMatrix4(transform),\n        new external_three_.Vector3(box.min.x, box.min.y, box.min.z).applyMatrix4(transform),\n        new external_three_.Vector3(box.max.x, box.min.y, box.min.z).applyMatrix4(transform),\n        new external_three_.Vector3(box.min.x, box.max.y, box.min.z).applyMatrix4(transform),\n        new external_three_.Vector3(box.min.x, box.min.y, box.max.z).applyMatrix4(transform),\n        new external_three_.Vector3(box.min.x, box.max.y, box.max.z).applyMatrix4(transform),\n        new external_three_.Vector3(box.max.x, box.max.y, box.min.z).applyMatrix4(transform),\n        new external_three_.Vector3(box.max.x, box.min.y, box.max.z).applyMatrix4(transform),\n        new external_three_.Vector3(box.max.x, box.max.y, box.max.z).applyMatrix4(transform),\n    ]);\n}\nfunction createChildAABB(aabb, index) {\n    const min = aabb.min.clone();\n    const max = aabb.max.clone();\n    const size = new external_three_.Vector3().subVectors(max, min);\n    // tslint:disable-next-line:no-bitwise\n    if ((index & 0b0001) > 0) {\n        min.z += size.z / 2;\n    }\n    else {\n        max.z -= size.z / 2;\n    }\n    // tslint:disable-next-line:no-bitwise\n    if ((index & 0b0010) > 0) {\n        min.y += size.y / 2;\n    }\n    else {\n        max.y -= size.y / 2;\n    }\n    // tslint:disable-next-line:no-bitwise\n    if ((index & 0b0100) > 0) {\n        min.x += size.x / 2;\n    }\n    else {\n        max.x -= size.x / 2;\n    }\n    return new external_three_.Box3(min, max);\n}\n\n;// CONCATENATED MODULE: ./src/point-cloud-octree-geometry-node.ts\n/**\n * Adapted from Potree.js http://potree.org\n * Potree License: https://github.com/potree/potree/blob/1.5/LICENSE\n */\n\n\n\nconst NODE_STRIDE = 5;\nclass PointCloudOctreeGeometryNode extends external_three_.EventDispatcher {\n    constructor(name, pcoGeometry, boundingBox) {\n        super();\n        this.id = PointCloudOctreeGeometryNode.idCount++;\n        this.level = 0;\n        this.spacing = 0;\n        this.hasChildren = false;\n        this.children = [\n            null,\n            null,\n            null,\n            null,\n            null,\n            null,\n            null,\n            null,\n        ];\n        this.mean = new external_three_.Vector3();\n        this.numPoints = 0;\n        this.loaded = false;\n        this.loading = false;\n        this.failed = false;\n        this.parent = null;\n        this.oneTimeDisposeHandlers = [];\n        this.isLeafNode = true;\n        this.isTreeNode = false;\n        this.isGeometryNode = true;\n        this.name = name;\n        this.index = getIndexFromName(name);\n        this.pcoGeometry = pcoGeometry;\n        this.boundingBox = boundingBox;\n        this.tightBoundingBox = boundingBox.clone();\n        this.boundingSphere = boundingBox.getBoundingSphere(new external_three_.Sphere());\n    }\n    dispose() {\n        if (!this.geometry || !this.parent) {\n            return;\n        }\n        this.geometry.dispose();\n        this.geometry = undefined;\n        this.loaded = false;\n        this.oneTimeDisposeHandlers.forEach(handler => handler());\n        this.oneTimeDisposeHandlers = [];\n    }\n    /**\n     * Gets the url of the binary file for this node.\n     */\n    getUrl() {\n        const geometry = this.pcoGeometry;\n        const version = geometry.loader.version;\n        const pathParts = [geometry.octreeDir];\n        if (geometry.loader && version.equalOrHigher('1.5')) {\n            pathParts.push(this.getHierarchyBaseUrl());\n            pathParts.push(this.name);\n        }\n        else if (version.equalOrHigher('1.4')) {\n            pathParts.push(this.name);\n        }\n        else if (version.upTo('1.3')) {\n            pathParts.push(this.name);\n        }\n        return pathParts.join('/');\n    }\n    /**\n     * Gets the url of the hierarchy file for this node.\n     */\n    getHierarchyUrl() {\n        return `${this.pcoGeometry.octreeDir}/${this.getHierarchyBaseUrl()}/${this.name}.hrc`;\n    }\n    /**\n     * Adds the specified node as a child of the current node.\n     *\n     * @param child\n     *    The node which is to be added as a child.\n     */\n    addChild(child) {\n        this.children[child.index] = child;\n        this.isLeafNode = false;\n        child.parent = this;\n    }\n    /**\n     * Calls the specified callback for the current node (if includeSelf is set to true) and all its\n     * children.\n     *\n     * @param cb\n     *    The function which is to be called for each node.\n     */\n    traverse(cb, includeSelf = true) {\n        const stack = includeSelf ? [this] : [];\n        let current;\n        while ((current = stack.pop()) !== undefined) {\n            cb(current);\n            for (const child of current.children) {\n                if (child !== null) {\n                    stack.push(child);\n                }\n            }\n        }\n    }\n    load() {\n        if (!this.canLoad()) {\n            return Promise.resolve();\n        }\n        this.loading = true;\n        this.pcoGeometry.numNodesLoading++;\n        this.pcoGeometry.needsUpdate = true;\n        let promise;\n        if (this.pcoGeometry.loader.version.equalOrHigher('1.5') &&\n            this.level % this.pcoGeometry.hierarchyStepSize === 0 &&\n            this.hasChildren) {\n            promise = this.loadHierachyThenPoints();\n        }\n        else {\n            promise = this.loadPoints();\n        }\n        return promise.catch(reason => {\n            this.loading = false;\n            this.failed = true;\n            this.pcoGeometry.numNodesLoading--;\n            throw reason;\n        });\n    }\n    canLoad() {\n        return (!this.loading &&\n            !this.loaded &&\n            !this.pcoGeometry.disposed &&\n            !this.pcoGeometry.loader.disposed &&\n            this.pcoGeometry.numNodesLoading < this.pcoGeometry.maxNumNodesLoading);\n    }\n    loadPoints() {\n        this.pcoGeometry.needsUpdate = true;\n        return this.pcoGeometry.loader.load(this);\n    }\n    loadHierachyThenPoints() {\n        if (this.level % this.pcoGeometry.hierarchyStepSize !== 0) {\n            return Promise.resolve();\n        }\n        return Promise.resolve(this.pcoGeometry.loader.getUrl(this.getHierarchyUrl()))\n            .then(url => this.pcoGeometry.xhrRequest(url, { mode: 'cors' }))\n            .then(res => handleFailedRequest(res))\n            .then(okRes => okRes.arrayBuffer())\n            .then(buffer => handleEmptyBuffer(buffer))\n            .then(okBuffer => this.loadHierarchy(this, okBuffer));\n    }\n    /**\n     * Gets the url of the folder where the hierarchy is, relative to the octreeDir.\n     */\n    getHierarchyBaseUrl() {\n        const hierarchyStepSize = this.pcoGeometry.hierarchyStepSize;\n        const indices = this.name.substr(1);\n        const numParts = Math.floor(indices.length / hierarchyStepSize);\n        let path = 'r/';\n        for (let i = 0; i < numParts; i++) {\n            path += `${indices.substr(i * hierarchyStepSize, hierarchyStepSize)}/`;\n        }\n        return path.slice(0, -1);\n    }\n    // tslint:disable:no-bitwise\n    loadHierarchy(node, buffer) {\n        const view = new DataView(buffer);\n        const firstNodeData = this.getNodeData(node.name, 0, view);\n        node.numPoints = firstNodeData.numPoints;\n        // Nodes which need be visited.\n        const stack = [firstNodeData];\n        // Nodes which have already been decoded. We will take nodes from the stack and place them here.\n        const decoded = [];\n        let offset = NODE_STRIDE;\n        while (stack.length > 0) {\n            const stackNodeData = stack.shift();\n            // From the last bit, all the way to the 8th one from the right.\n            let mask = 1;\n            for (let i = 0; i < 8 && offset + 1 < buffer.byteLength; i++) {\n                if ((stackNodeData.children & mask) !== 0) {\n                    const nodeData = this.getNodeData(stackNodeData.name + i, offset, view);\n                    decoded.push(nodeData); // Node is decoded.\n                    stack.push(nodeData); // Need to check its children.\n                    offset += NODE_STRIDE; // Move over to the next node in the buffer.\n                }\n                mask = mask * 2;\n            }\n        }\n        node.pcoGeometry.needsUpdate = true;\n        // Map containing all the nodes.\n        const nodes = new Map();\n        nodes.set(node.name, node);\n        decoded.forEach(nodeData => this.addNode(nodeData, node.pcoGeometry, nodes));\n        node.loadPoints();\n    }\n    // tslint:enable:no-bitwise\n    getNodeData(name, offset, view) {\n        const children = view.getUint8(offset);\n        const numPoints = view.getUint32(offset + 1, true);\n        return { children: children, numPoints: numPoints, name };\n    }\n    addNode({ name, numPoints, children }, pco, nodes) {\n        const index = getIndexFromName(name);\n        const parentName = name.substring(0, name.length - 1);\n        const parentNode = nodes.get(parentName);\n        const level = name.length - 1;\n        const boundingBox = createChildAABB(parentNode.boundingBox, index);\n        const node = new PointCloudOctreeGeometryNode(name, pco, boundingBox);\n        node.level = level;\n        node.numPoints = numPoints;\n        node.hasChildren = children > 0;\n        node.spacing = pco.spacing / Math.pow(2, level);\n        parentNode.addChild(node);\n        nodes.set(name, node);\n    }\n}\nPointCloudOctreeGeometryNode.idCount = 0;\n\n;// CONCATENATED MODULE: ./src/point-cloud-octree-geometry.ts\n\nclass PointCloudOctreeGeometry {\n    constructor(loader, boundingBox, tightBoundingBox, offset, xhrRequest) {\n        this.loader = loader;\n        this.boundingBox = boundingBox;\n        this.tightBoundingBox = tightBoundingBox;\n        this.offset = offset;\n        this.xhrRequest = xhrRequest;\n        this.disposed = false;\n        this.needsUpdate = true;\n        this.octreeDir = '';\n        this.hierarchyStepSize = -1;\n        this.nodes = {};\n        this.numNodesLoading = 0;\n        this.maxNumNodesLoading = 3;\n        this.spacing = 0;\n        this.pointAttributes = new PointAttributes([]);\n        this.projection = null;\n        this.url = null;\n    }\n    dispose() {\n        this.loader.dispose();\n        this.root.traverse(node => node.dispose());\n        this.disposed = true;\n    }\n    addNodeLoadedCallback(callback) {\n        this.loader.callbacks.push(callback);\n    }\n    clearNodeLoadedCallbacks() {\n        this.loader.callbacks = [];\n    }\n}\n\n;// CONCATENATED MODULE: ./src/point-cloud-octree-node.ts\n\nclass PointCloudOctreeNode extends external_three_.EventDispatcher {\n    constructor(geometryNode, sceneNode) {\n        super();\n        this.pcIndex = undefined;\n        this.boundingBoxNode = null;\n        this.loaded = true;\n        this.isTreeNode = true;\n        this.isGeometryNode = false;\n        this.geometryNode = geometryNode;\n        this.sceneNode = sceneNode;\n        this.children = geometryNode.children.slice();\n    }\n    dispose() {\n        this.geometryNode.dispose();\n    }\n    disposeSceneNode() {\n        const node = this.sceneNode;\n        if (node.geometry instanceof external_three_.BufferGeometry) {\n            const attributes = node.geometry.attributes;\n            // tslint:disable-next-line:forin\n            for (const key in attributes) {\n                if (key === 'position') {\n                    delete attributes[key].array;\n                }\n                delete attributes[key];\n            }\n            node.geometry.dispose();\n            node.geometry = undefined;\n        }\n    }\n    traverse(cb, includeSelf) {\n        this.geometryNode.traverse(cb, includeSelf);\n    }\n    get id() {\n        return this.geometryNode.id;\n    }\n    get name() {\n        return this.geometryNode.name;\n    }\n    get level() {\n        return this.geometryNode.level;\n    }\n    get isLeafNode() {\n        return this.geometryNode.isLeafNode;\n    }\n    get numPoints() {\n        return this.geometryNode.numPoints;\n    }\n    get index() {\n        return this.geometryNode.index;\n    }\n    get boundingSphere() {\n        return this.geometryNode.boundingSphere;\n    }\n    get boundingBox() {\n        return this.geometryNode.boundingBox;\n    }\n    get spacing() {\n        return this.geometryNode.spacing;\n    }\n}\n\n;// CONCATENATED MODULE: ./src/utils/math.ts\nfunction clamp(value, min, max) {\n    return Math.min(Math.max(min, value), max);\n}\n\n;// CONCATENATED MODULE: ./src/point-cloud-octree-picker.ts\n\n\n\n\nclass PointCloudOctreePicker {\n    dispose() {\n        if (this.pickState) {\n            this.pickState.material.dispose();\n            this.pickState.renderTarget.dispose();\n        }\n    }\n    pick(renderer, camera, ray, octrees, params = {}) {\n        if (octrees.length === 0) {\n            return null;\n        }\n        const pickState = this.pickState\n            ? this.pickState\n            : (this.pickState = PointCloudOctreePicker.getPickState());\n        const pickMaterial = pickState.material;\n        const pixelRatio = renderer.getPixelRatio();\n        const width = Math.ceil(renderer.domElement.clientWidth * pixelRatio);\n        const height = Math.ceil(renderer.domElement.clientHeight * pixelRatio);\n        PointCloudOctreePicker.updatePickRenderTarget(this.pickState, width, height);\n        const pixelPosition = PointCloudOctreePicker.helperVec3; // Use helper vector to prevent extra allocations.\n        if (params.pixelPosition) {\n            pixelPosition.copy(params.pixelPosition);\n        }\n        else {\n            pixelPosition.addVectors(camera.position, ray.direction).project(camera);\n            pixelPosition.x = (pixelPosition.x + 1) * width * 0.5;\n            pixelPosition.y = (pixelPosition.y + 1) * height * 0.5;\n        }\n        const pickWndSize = Math.floor((params.pickWindowSize || DEFAULT_PICK_WINDOW_SIZE) * pixelRatio);\n        const halfPickWndSize = (pickWndSize - 1) / 2;\n        const x = Math.floor(clamp(pixelPosition.x - halfPickWndSize, 0, width));\n        const y = Math.floor(clamp(pixelPosition.y - halfPickWndSize, 0, height));\n        PointCloudOctreePicker.prepareRender(renderer, x, y, pickWndSize, pickMaterial, pickState);\n        const renderedNodes = PointCloudOctreePicker.render(renderer, camera, pickMaterial, octrees, ray, pickState, params);\n        // Cleanup\n        pickMaterial.clearVisibleNodeTextureOffsets();\n        // Read back image and decode hit point\n        const pixels = PointCloudOctreePicker.readPixels(renderer, x, y, pickWndSize);\n        const hit = PointCloudOctreePicker.findHit(pixels, pickWndSize);\n        return PointCloudOctreePicker.getPickPoint(hit, renderedNodes);\n    }\n    static prepareRender(renderer, x, y, pickWndSize, pickMaterial, pickState) {\n        // Render the intersected nodes onto the pick render target, clipping to a small pick window.\n        renderer.setScissor(x, y, pickWndSize, pickWndSize);\n        renderer.setScissorTest(true);\n        renderer.state.buffers.depth.setTest(pickMaterial.depthTest);\n        renderer.state.buffers.depth.setMask(pickMaterial.depthWrite);\n        renderer.state.setBlending(external_three_.NoBlending);\n        renderer.setRenderTarget(pickState.renderTarget);\n        // Save the current clear color and clear the renderer with black color and alpha 0.\n        renderer.getClearColor(this.clearColor);\n        const oldClearAlpha = renderer.getClearAlpha();\n        renderer.setClearColor(COLOR_BLACK, 0);\n        renderer.clear(true, true, true);\n        renderer.setClearColor(this.clearColor, oldClearAlpha);\n    }\n    static render(renderer, camera, pickMaterial, octrees, ray, pickState, params) {\n        const renderedNodes = [];\n        for (const octree of octrees) {\n            // Get all the octree nodes which intersect the picking ray. We only need to render those.\n            const nodes = PointCloudOctreePicker.nodesOnRay(octree, ray);\n            if (!nodes.length) {\n                continue;\n            }\n            PointCloudOctreePicker.updatePickMaterial(pickMaterial, octree.material, params);\n            pickMaterial.updateMaterial(octree, nodes, camera, renderer);\n            if (params.onBeforePickRender) {\n                params.onBeforePickRender(pickMaterial, pickState.renderTarget);\n            }\n            // Create copies of the nodes so we can render them differently than in the normal point cloud.\n            pickState.scene.children = PointCloudOctreePicker.createTempNodes(octree, nodes, pickMaterial, renderedNodes.length);\n            renderer.render(pickState.scene, camera);\n            nodes.forEach(node => renderedNodes.push({ node, octree }));\n        }\n        return renderedNodes;\n    }\n    static nodesOnRay(octree, ray) {\n        const nodesOnRay = [];\n        const rayClone = ray.clone();\n        for (const node of octree.visibleNodes) {\n            const sphere = PointCloudOctreePicker.helperSphere\n                .copy(node.boundingSphere)\n                .applyMatrix4(octree.matrixWorld);\n            if (rayClone.intersectsSphere(sphere)) {\n                nodesOnRay.push(node);\n            }\n        }\n        return nodesOnRay;\n    }\n    static readPixels(renderer, x, y, pickWndSize) {\n        // Read the pixel from the pick render target.\n        const pixels = new Uint8Array(4 * pickWndSize * pickWndSize);\n        renderer.readRenderTargetPixels(renderer.getRenderTarget(), x, y, pickWndSize, pickWndSize, pixels);\n        renderer.setScissorTest(false);\n        renderer.setRenderTarget(null);\n        return pixels;\n    }\n    static createTempNodes(octree, nodes, pickMaterial, nodeIndexOffset) {\n        const tempNodes = [];\n        for (let i = 0; i < nodes.length; i++) {\n            const node = nodes[i];\n            const sceneNode = node.sceneNode;\n            const tempNode = new external_three_.Points(sceneNode.geometry, pickMaterial);\n            tempNode.matrix = sceneNode.matrix;\n            tempNode.matrixWorld = sceneNode.matrixWorld;\n            tempNode.matrixAutoUpdate = false;\n            tempNode.frustumCulled = false;\n            const nodeIndex = nodeIndexOffset + i + 1;\n            if (nodeIndex > 255) {\n                console.error('More than 255 nodes for pick are not supported.');\n            }\n            tempNode.onBeforeRender = PointCloudMaterial.makeOnBeforeRender(octree, node, nodeIndex);\n            tempNodes.push(tempNode);\n        }\n        return tempNodes;\n    }\n    static updatePickMaterial(pickMaterial, nodeMaterial, params) {\n        pickMaterial.pointSizeType = nodeMaterial.pointSizeType;\n        pickMaterial.shape = nodeMaterial.shape;\n        pickMaterial.size = nodeMaterial.size;\n        pickMaterial.minSize = nodeMaterial.minSize;\n        pickMaterial.maxSize = nodeMaterial.maxSize;\n        pickMaterial.classification = nodeMaterial.classification;\n        pickMaterial.useFilterByNormal = nodeMaterial.useFilterByNormal;\n        pickMaterial.filterByNormalThreshold = nodeMaterial.filterByNormalThreshold;\n        if (params.pickOutsideClipRegion) {\n            pickMaterial.clipMode = ClipMode.DISABLED;\n        }\n        else {\n            pickMaterial.clipMode = nodeMaterial.clipMode;\n            pickMaterial.setClipBoxes(nodeMaterial.clipMode === ClipMode.CLIP_OUTSIDE ? nodeMaterial.clipBoxes : []);\n        }\n    }\n    static updatePickRenderTarget(pickState, width, height) {\n        if (pickState.renderTarget.width === width && pickState.renderTarget.height === height) {\n            return;\n        }\n        pickState.renderTarget.dispose();\n        pickState.renderTarget = PointCloudOctreePicker.makePickRenderTarget();\n        pickState.renderTarget.setSize(width, height);\n    }\n    static makePickRenderTarget() {\n        return new external_three_.WebGLRenderTarget(1, 1, {\n            minFilter: external_three_.LinearFilter,\n            magFilter: external_three_.NearestFilter,\n            format: external_three_.RGBAFormat,\n        });\n    }\n    static findHit(pixels, pickWndSize) {\n        const ibuffer = new Uint32Array(pixels.buffer);\n        // Find closest hit inside pixelWindow boundaries\n        let min = Number.MAX_VALUE;\n        let hit = null;\n        for (let u = 0; u < pickWndSize; u++) {\n            for (let v = 0; v < pickWndSize; v++) {\n                const offset = u + v * pickWndSize;\n                const distance = Math.pow(u - (pickWndSize - 1) / 2, 2) + Math.pow(v - (pickWndSize - 1) / 2, 2);\n                const pcIndex = pixels[4 * offset + 3];\n                pixels[4 * offset + 3] = 0;\n                const pIndex = ibuffer[offset];\n                if (pcIndex > 0 && distance < min) {\n                    hit = {\n                        pIndex: pIndex,\n                        pcIndex: pcIndex - 1,\n                    };\n                    min = distance;\n                }\n            }\n        }\n        return hit;\n    }\n    static getPickPoint(hit, nodes) {\n        if (!hit) {\n            return null;\n        }\n        const point = {};\n        const points = nodes[hit.pcIndex] && nodes[hit.pcIndex].node.sceneNode;\n        if (!points) {\n            return null;\n        }\n        point.pointCloud = nodes[hit.pcIndex].octree;\n        const attributes = points.geometry.attributes;\n        for (const property in attributes) {\n            if (!attributes.hasOwnProperty(property)) {\n                continue;\n            }\n            const values = attributes[property];\n            // tslint:disable-next-line:prefer-switch\n            if (property === 'position') {\n                PointCloudOctreePicker.addPositionToPickPoint(point, hit, values, points);\n            }\n            else if (property === 'normal') {\n                PointCloudOctreePicker.addNormalToPickPoint(point, hit, values, points);\n            }\n            else if (property === 'indices') {\n                // TODO\n            }\n            else {\n                if (values.itemSize === 1) {\n                    point[property] = values.array[hit.pIndex];\n                }\n                else {\n                    const value = [];\n                    for (let j = 0; j < values.itemSize; j++) {\n                        value.push(values.array[values.itemSize * hit.pIndex + j]);\n                    }\n                    point[property] = value;\n                }\n            }\n        }\n        return point;\n    }\n    static addPositionToPickPoint(point, hit, values, points) {\n        point.position = new external_three_.Vector3()\n            .fromBufferAttribute(values, hit.pIndex)\n            .applyMatrix4(points.matrixWorld);\n    }\n    static addNormalToPickPoint(point, hit, values, points) {\n        const normal = new external_three_.Vector3().fromBufferAttribute(values, hit.pIndex);\n        const normal4 = new external_three_.Vector4(normal.x, normal.y, normal.z, 0).applyMatrix4(points.matrixWorld);\n        normal.set(normal4.x, normal4.y, normal4.z);\n        point.normal = normal;\n    }\n    static getPickState() {\n        const scene = new external_three_.Scene();\n        scene.matrixAutoUpdate = false;\n        const material = new PointCloudMaterial();\n        material.pointColorType = PointColorType.POINT_INDEX;\n        return {\n            renderTarget: PointCloudOctreePicker.makePickRenderTarget(),\n            material: material,\n            scene: scene,\n        };\n    }\n}\nPointCloudOctreePicker.helperVec3 = new external_three_.Vector3();\nPointCloudOctreePicker.helperSphere = new external_three_.Sphere();\nPointCloudOctreePicker.clearColor = new external_three_.Color();\n\n;// CONCATENATED MODULE: ./src/loading2/octree-geometry.ts\n\nclass OctreeGeometry {\n    constructor(loader, boundingBox) {\n        this.loader = loader;\n        this.boundingBox = boundingBox;\n        this.maxNumNodesLoading = 3;\n        this.numNodesLoading = 0;\n        this.disposed = false;\n        this.pointAttributes = null;\n        this.spacing = 0;\n        this.url = null;\n        this.tightBoundingBox = this.boundingBox.clone();\n        this.boundingSphere = this.boundingBox.getBoundingSphere(new external_three_.Sphere());\n        this.tightBoundingSphere = this.boundingSphere.clone();\n    }\n    dispose() {\n        this.root.traverse((node) => node.dispose());\n        this.disposed = true;\n    }\n}\n\n;// CONCATENATED MODULE: ./src/point-cloud-tree.ts\n\nclass PointCloudTree extends external_three_.Object3D {\n    constructor() {\n        super(...arguments);\n        this.root = null;\n    }\n    initialized() {\n        return this.root !== null;\n    }\n}\n\n;// CONCATENATED MODULE: ./src/point-cloud-octree.ts\n\n\n\n\n\n\n\n\nclass PointCloudOctree extends PointCloudTree {\n    constructor(potree, pcoGeometry, material) {\n        super();\n        this.disposed = false;\n        this.level = 0;\n        this.maxLevel = Infinity;\n        /**\n         * The minimum radius of a node's bounding sphere on the screen in order to be displayed.\n         */\n        this.minNodePixelSize = DEFAULT_MIN_NODE_PIXEL_SIZE;\n        this.root = null;\n        this.boundingBoxNodes = [];\n        this.visibleNodes = [];\n        this.visibleGeometry = [];\n        this.numVisiblePoints = 0;\n        this.showBoundingBox = false;\n        this.visibleBounds = new external_three_.Box3();\n        this.name = '';\n        this.potree = potree;\n        this.root = pcoGeometry.root;\n        this.pcoGeometry = pcoGeometry;\n        this.boundingBox = pcoGeometry.boundingBox;\n        this.boundingSphere = this.boundingBox.getBoundingSphere(new external_three_.Sphere());\n        this.position.copy(pcoGeometry.offset);\n        this.updateMatrix();\n        this.material = material || pcoGeometry instanceof OctreeGeometry ? new PointCloudMaterial({ colorRgba: true }) : new PointCloudMaterial();\n        this.initMaterial(this.material);\n    }\n    initMaterial(material) {\n        this.updateMatrixWorld(true);\n        const { min, max } = computeTransformedBoundingBox(this.pcoGeometry.tightBoundingBox || this.getBoundingBoxWorld(), this.matrixWorld);\n        const bWidth = max.z - min.z;\n        material.heightMin = min.z - 0.2 * bWidth;\n        material.heightMax = max.z + 0.2 * bWidth;\n    }\n    dispose() {\n        if (this.root) {\n            this.root.dispose();\n        }\n        this.pcoGeometry.root.traverse(n => this.potree.lru.remove(n));\n        this.pcoGeometry.dispose();\n        this.material.dispose();\n        this.visibleNodes = [];\n        this.visibleGeometry = [];\n        if (this.picker) {\n            this.picker.dispose();\n            this.picker = undefined;\n        }\n        this.disposed = true;\n    }\n    get pointSizeType() {\n        return this.material.pointSizeType;\n    }\n    set pointSizeType(value) {\n        this.material.pointSizeType = value;\n    }\n    toTreeNode(geometryNode, parent) {\n        const points = new external_three_.Points(geometryNode.geometry, this.material);\n        const node = new PointCloudOctreeNode(geometryNode, points);\n        points.name = geometryNode.name;\n        points.position.copy(geometryNode.boundingBox.min);\n        points.frustumCulled = false;\n        points.onBeforeRender = PointCloudMaterial.makeOnBeforeRender(this, node);\n        if (parent) {\n            parent.sceneNode.add(points);\n            parent.children[geometryNode.index] = node;\n            geometryNode.oneTimeDisposeHandlers.push(() => {\n                node.disposeSceneNode();\n                parent.sceneNode.remove(node.sceneNode);\n                // Replace the tree node (rendered and in the GPU) with the geometry node.\n                parent.children[geometryNode.index] = geometryNode;\n            });\n        }\n        else {\n            this.root = node;\n            this.add(points);\n        }\n        return node;\n    }\n    updateVisibleBounds() {\n        const bounds = this.visibleBounds;\n        bounds.min.set(Infinity, Infinity, Infinity);\n        bounds.max.set(-Infinity, -Infinity, -Infinity);\n        for (const node of this.visibleNodes) {\n            if (node.isLeafNode) {\n                bounds.expandByPoint(node.boundingBox.min);\n                bounds.expandByPoint(node.boundingBox.max);\n            }\n        }\n    }\n    updateBoundingBoxes() {\n        if (!this.showBoundingBox || !this.parent) {\n            return;\n        }\n        let bbRoot = this.parent.getObjectByName('bbroot');\n        if (!bbRoot) {\n            bbRoot = new external_three_.Object3D();\n            bbRoot.name = 'bbroot';\n            this.parent.add(bbRoot);\n        }\n        const visibleBoxes = [];\n        for (const node of this.visibleNodes) {\n            if (node.boundingBoxNode !== undefined && node.isLeafNode) {\n                visibleBoxes.push(node.boundingBoxNode);\n            }\n        }\n        bbRoot.children = visibleBoxes;\n    }\n    updateMatrixWorld(force) {\n        if (this.matrixAutoUpdate === true) {\n            this.updateMatrix();\n        }\n        if (this.matrixWorldNeedsUpdate === true || force === true) {\n            if (!this.parent) {\n                this.matrixWorld.copy(this.matrix);\n            }\n            else {\n                this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);\n            }\n            this.matrixWorldNeedsUpdate = false;\n            force = true;\n        }\n    }\n    hideDescendants(object) {\n        const toHide = [];\n        addVisibleChildren(object);\n        while (toHide.length > 0) {\n            const objToHide = toHide.shift();\n            objToHide.visible = false;\n            addVisibleChildren(objToHide);\n        }\n        function addVisibleChildren(obj) {\n            for (const child of obj.children) {\n                if (child.visible) {\n                    toHide.push(child);\n                }\n            }\n        }\n    }\n    moveToOrigin() {\n        this.position.set(0, 0, 0); // Reset, then the matrix will be updated in getBoundingBoxWorld()\n        this.position.set(0, 0, 0).sub(this.getBoundingBoxWorld().getCenter(new external_three_.Vector3()));\n    }\n    moveToGroundPlane() {\n        this.position.y += -this.getBoundingBoxWorld().min.y;\n    }\n    getBoundingBoxWorld() {\n        this.updateMatrixWorld(true);\n        return computeTransformedBoundingBox(this.boundingBox, this.matrixWorld);\n    }\n    getVisibleExtent() {\n        return this.visibleBounds.applyMatrix4(this.matrixWorld);\n    }\n    pick(renderer, camera, ray, params = {}) {\n        this.picker = this.picker || new PointCloudOctreePicker();\n        return this.picker.pick(renderer, camera, ray, [this], params);\n    }\n    get progress() {\n        return this.visibleGeometry.length === 0\n            ? 0\n            : this.visibleNodes.length / this.visibleGeometry.length;\n    }\n}\n\n;// CONCATENATED MODULE: ./src/features.ts\nconst canvas = document.createElement('canvas');\nconst gl = canvas.getContext('webgl');\nconst FEATURES = {\n    SHADER_INTERPOLATION: hasExtension('EXT_frag_depth') && hasMinVaryingVectors(8),\n    SHADER_SPLATS: hasExtension('EXT_frag_depth') && hasExtension('OES_texture_float') && hasMinVaryingVectors(8),\n    SHADER_EDL: hasExtension('OES_texture_float') && hasMinVaryingVectors(8),\n    precision: getPrecision(),\n};\nfunction hasExtension(ext) {\n    return gl !== null && Boolean(gl.getExtension(ext));\n}\nfunction hasMinVaryingVectors(value) {\n    return gl !== null && gl.getParameter(gl.MAX_VARYING_VECTORS) >= value;\n}\nfunction getPrecision() {\n    if (gl === null) {\n        return '';\n    }\n    const vsHighpFloat = gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT);\n    const vsMediumpFloat = gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT);\n    const fsHighpFloat = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);\n    const fsMediumpFloat = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT);\n    const highpAvailable = vsHighpFloat && fsHighpFloat && vsHighpFloat.precision > 0 && fsHighpFloat.precision > 0;\n    const mediumpAvailable = vsMediumpFloat &&\n        fsMediumpFloat &&\n        vsMediumpFloat.precision > 0 &&\n        fsMediumpFloat.precision > 0;\n    return highpAvailable ? 'highp' : mediumpAvailable ? 'mediump' : 'lowp';\n}\n\n;// CONCATENATED MODULE: ./src/utils/async-blocking-queue.ts\nclass AsyncBlockingQueue {\n    constructor() {\n        this.resolvers = [];\n        this.promises = [];\n    }\n    enqueue(t) {\n        if (!this.resolvers.length) {\n            this.add();\n        }\n        const resolve = this.resolvers.shift();\n        resolve(t);\n    }\n    dequeue() {\n        if (!this.promises.length) {\n            this.add();\n        }\n        return this.promises.shift();\n    }\n    add() {\n        this.promises.push(new Promise(resolve => {\n            this.resolvers.push(resolve);\n        }));\n    }\n}\n\n;// CONCATENATED MODULE: ./src/utils/worker-pool.ts\n\nclass AutoTerminatingWorker {\n    constructor(wrappedWorker, maxIdle) {\n        this.wrappedWorker = wrappedWorker;\n        this.maxIdle = maxIdle;\n        this.timeoutId = undefined;\n        this.terminated = false;\n    }\n    get worker() {\n        return this.wrappedWorker;\n    }\n    get isTerminated() {\n        return this.terminated;\n    }\n    markIdle() {\n        this.timeoutId = window.setTimeout(() => {\n            this.terminated = true;\n            this.wrappedWorker.terminate();\n        }, this.maxIdle);\n    }\n    markInUse() {\n        if (this.timeoutId) {\n            window.clearTimeout(this.timeoutId);\n        }\n    }\n}\nclass WorkerPool {\n    constructor(maxWorkers, workerType) {\n        this.maxWorkers = maxWorkers;\n        this.workerType = workerType;\n        this.pool = new AsyncBlockingQueue();\n        this.poolSize = 0;\n    }\n    /**\n     * Returns a worker promise which is resolved when one is available.\n     */\n    getWorker() {\n        // If the number of active workers is smaller than the maximum, return a new one.\n        // Otherwise, return a promise for worker from the pool.\n        if (this.poolSize < this.maxWorkers) {\n            this.poolSize++;\n            return Promise.resolve(new AutoTerminatingWorker(new this.workerType(), WorkerPool.POOL_MAX_IDLE));\n        }\n        else {\n            return this.pool.dequeue().then(worker => {\n                worker.markInUse();\n                // If the dequeued worker has been terminated, decrease the pool size and make a recursive call to get a new worker\n                if (worker.isTerminated) {\n                    this.poolSize--;\n                    return this.getWorker();\n                }\n                return worker;\n            });\n        }\n    }\n    /**\n     * Releases a Worker back into the pool\n     * @param worker\n     */\n    releaseWorker(worker) {\n        worker.markIdle();\n        this.pool.enqueue(worker);\n    }\n}\n/**\n * The maximum amount of idle time that can elapse before a worker from this pool is automatically terminated\n */\nWorkerPool.POOL_MAX_IDLE = 7000;\n\n;// CONCATENATED MODULE: ./src/version.ts\nclass Version {\n    constructor(version) {\n        this.versionMinor = 0;\n        this.version = version;\n        const vmLength = version.indexOf('.') === -1 ? version.length : version.indexOf('.');\n        this.versionMajor = parseInt(version.substr(0, vmLength), 10);\n        this.versionMinor = parseInt(version.substr(vmLength + 1), 10);\n        if (isNaN(this.versionMinor)) {\n            this.versionMinor = 0;\n        }\n    }\n    newerThan(version) {\n        const v = new Version(version);\n        if (this.versionMajor > v.versionMajor) {\n            return true;\n        }\n        else if (this.versionMajor === v.versionMajor && this.versionMinor > v.versionMinor) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    equalOrHigher(version) {\n        const v = new Version(version);\n        if (this.versionMajor > v.versionMajor) {\n            return true;\n        }\n        else if (this.versionMajor === v.versionMajor && this.versionMinor >= v.versionMinor) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    upTo(version) {\n        return !this.newerThan(version);\n    }\n}\n\n;// CONCATENATED MODULE: ./src/loading/binary-loader.ts\n// -------------------------------------------------------------------------------------------------\n// Converted to Typescript and adapted from https://github.com/potree/potree\n// -------------------------------------------------------------------------------------------------\n\n\n\n\n\nclass BinaryLoader {\n    constructor({ getUrl = s => Promise.resolve(s), version, boundingBox, scale, xhrRequest, }) {\n        this.disposed = false;\n        if (typeof version === 'string') {\n            this.version = new Version(version);\n        }\n        else {\n            this.version = version;\n        }\n        this.xhrRequest = xhrRequest;\n        this.getUrl = getUrl;\n        this.boundingBox = boundingBox;\n        this.scale = scale;\n        this.callbacks = [];\n    }\n    dispose() {\n        this.disposed = true;\n    }\n    load(node) {\n        if (node.loaded || this.disposed) {\n            return Promise.resolve();\n        }\n        return Promise.resolve(this.getUrl(this.getNodeUrl(node)))\n            .then(url => this.xhrRequest(url, { mode: 'cors' }))\n            .then(res => handleFailedRequest(res))\n            .then(okRes => okRes.arrayBuffer())\n            .then(buffer => handleEmptyBuffer(buffer))\n            .then(okBuffer => {\n            return new Promise(resolve => this.parse(node, okBuffer, resolve));\n        });\n    }\n    getNodeUrl(node) {\n        let url = node.getUrl();\n        if (this.version.equalOrHigher('1.4')) {\n            url += '.bin';\n        }\n        return url;\n    }\n    parse(node, buffer, resolve) {\n        if (this.disposed) {\n            resolve();\n            return;\n        }\n        BinaryLoader.WORKER_POOL.getWorker().then(autoTerminatingWorker => {\n            const pointAttributes = node.pcoGeometry.pointAttributes;\n            const numPoints = buffer.byteLength / pointAttributes.byteSize;\n            if (this.version.upTo('1.5')) {\n                node.numPoints = numPoints;\n            }\n            autoTerminatingWorker.worker.onmessage = (e) => {\n                if (this.disposed) {\n                    resolve();\n                    BinaryLoader.WORKER_POOL.releaseWorker(autoTerminatingWorker);\n                    return;\n                }\n                const data = e.data;\n                const geometry = (node.geometry = node.geometry || new external_three_.BufferGeometry());\n                geometry.boundingBox = node.boundingBox;\n                this.addBufferAttributes(geometry, data.attributeBuffers);\n                this.addIndices(geometry, data.indices);\n                this.addNormalAttribute(geometry, numPoints);\n                node.mean = new external_three_.Vector3().fromArray(data.mean);\n                node.tightBoundingBox = this.getTightBoundingBox(data.tightBoundingBox);\n                node.loaded = true;\n                node.loading = false;\n                node.failed = false;\n                node.pcoGeometry.numNodesLoading--;\n                node.pcoGeometry.needsUpdate = true;\n                this.callbacks.forEach(callback => callback(node));\n                resolve();\n                BinaryLoader.WORKER_POOL.releaseWorker(autoTerminatingWorker);\n            };\n            const message = {\n                buffer,\n                pointAttributes,\n                version: this.version.version,\n                min: node.boundingBox.min.toArray(),\n                offset: node.pcoGeometry.offset.toArray(),\n                scale: this.scale,\n                spacing: node.spacing,\n                hasChildren: node.hasChildren,\n            };\n            autoTerminatingWorker.worker.postMessage(message, [message.buffer]);\n        });\n    }\n    getTightBoundingBox({ min, max }) {\n        const box = new external_three_.Box3(new external_three_.Vector3().fromArray(min), new external_three_.Vector3().fromArray(max));\n        box.max.sub(box.min);\n        box.min.set(0, 0, 0);\n        return box;\n    }\n    addBufferAttributes(geometry, buffers) {\n        Object.keys(buffers).forEach(property => {\n            const buffer = buffers[property].buffer;\n            if (this.isAttribute(property, PointAttributeName.POSITION_CARTESIAN)) {\n                geometry.setAttribute('position', new external_three_.BufferAttribute(new Float32Array(buffer), 3));\n            }\n            else if (this.isAttribute(property, PointAttributeName.COLOR_PACKED)) {\n                geometry.setAttribute('color', new external_three_.BufferAttribute(new Uint8Array(buffer), 3, true));\n            }\n            else if (this.isAttribute(property, PointAttributeName.INTENSITY)) {\n                geometry.setAttribute('intensity', new external_three_.BufferAttribute(new Float32Array(buffer), 1));\n            }\n            else if (this.isAttribute(property, PointAttributeName.CLASSIFICATION)) {\n                geometry.setAttribute('classification', new external_three_.BufferAttribute(new Uint8Array(buffer), 1));\n            }\n            else if (this.isAttribute(property, PointAttributeName.NORMAL_SPHEREMAPPED)) {\n                geometry.setAttribute('normal', new external_three_.BufferAttribute(new Float32Array(buffer), 3));\n            }\n            else if (this.isAttribute(property, PointAttributeName.NORMAL_OCT16)) {\n                geometry.setAttribute('normal', new external_three_.BufferAttribute(new Float32Array(buffer), 3));\n            }\n            else if (this.isAttribute(property, PointAttributeName.NORMAL)) {\n                geometry.setAttribute('normal', new external_three_.BufferAttribute(new Float32Array(buffer), 3));\n            }\n        });\n    }\n    addIndices(geometry, indices) {\n        const indicesAttribute = new external_three_.Uint8BufferAttribute(indices, 4);\n        indicesAttribute.normalized = true;\n        geometry.setAttribute('indices', indicesAttribute);\n    }\n    addNormalAttribute(geometry, numPoints) {\n        if (!geometry.getAttribute('normal')) {\n            const buffer = new Float32Array(numPoints * 3);\n            geometry.setAttribute('normal', new external_three_.BufferAttribute(new Float32Array(buffer), 3));\n        }\n    }\n    isAttribute(property, name) {\n        return parseInt(property, 10) === name;\n    }\n}\nBinaryLoader.WORKER_POOL = new WorkerPool(32, (__webpack_require__(91)/* [\"default\"] */ .A));\n\n;// CONCATENATED MODULE: ./src/loading/load-poc.ts\n// -------------------------------------------------------------------------------------------------\n// Converted to Typescript and adapted from https://github.com/potree/potree\n// -------------------------------------------------------------------------------------------------\n\n\n\n\n\n\n\n\n/**\n *\n * @param url\n *    The url of the point cloud file (usually cloud.js).\n * @param getUrl\n *    Function which receives the relative URL of a point cloud chunk file which is to be loaded\n *    and shoud return a new url (e.g. signed) in the form of a string or a promise.\n * @param xhrRequest An arrow function for a fetch request\n * @returns\n *    An observable which emits once when the first LOD of the point cloud is loaded.\n */\nfunction loadPOC(url, getUrl, xhrRequest) {\n    return Promise.resolve(getUrl(url)).then(transformedUrl => {\n        return xhrRequest(transformedUrl, { mode: 'cors' })\n            .then(res => handleFailedRequest(res))\n            .then(okRes => okRes.json())\n            .then(parse(transformedUrl, getUrl, xhrRequest));\n    });\n}\nfunction parse(url, getUrl, xhrRequest) {\n    return (data) => {\n        const { offset, boundingBox, tightBoundingBox } = getBoundingBoxes(data);\n        const loader = new BinaryLoader({\n            getUrl,\n            version: data.version,\n            boundingBox,\n            scale: data.scale,\n            xhrRequest,\n        });\n        const pco = new PointCloudOctreeGeometry(loader, boundingBox, tightBoundingBox, offset, xhrRequest);\n        pco.url = url;\n        pco.octreeDir = data.octreeDir;\n        pco.needsUpdate = true;\n        pco.spacing = data.spacing;\n        pco.hierarchyStepSize = data.hierarchyStepSize;\n        pco.projection = data.projection;\n        pco.offset = offset;\n        pco.pointAttributes = new PointAttributes(data.pointAttributes);\n        const nodes = {};\n        const version = new Version(data.version);\n        return loadRoot(pco, data, nodes, version).then(() => {\n            if (version.upTo('1.4')) {\n                loadRemainingHierarchy(pco, data, nodes);\n            }\n            pco.nodes = nodes;\n            return pco;\n        });\n    };\n}\nfunction getBoundingBoxes(data) {\n    const min = new external_three_.Vector3(data.boundingBox.lx, data.boundingBox.ly, data.boundingBox.lz);\n    const max = new external_three_.Vector3(data.boundingBox.ux, data.boundingBox.uy, data.boundingBox.uz);\n    const boundingBox = new external_three_.Box3(min, max);\n    const tightBoundingBox = boundingBox.clone();\n    const offset = min.clone();\n    if (data.tightBoundingBox) {\n        const { lx, ly, lz, ux, uy, uz } = data.tightBoundingBox;\n        tightBoundingBox.min.set(lx, ly, lz);\n        tightBoundingBox.max.set(ux, uy, uz);\n    }\n    boundingBox.min.sub(offset);\n    boundingBox.max.sub(offset);\n    tightBoundingBox.min.sub(offset);\n    tightBoundingBox.max.sub(offset);\n    return { offset, boundingBox, tightBoundingBox };\n}\nfunction loadRoot(pco, data, nodes, version) {\n    const name = 'r';\n    const root = new PointCloudOctreeGeometryNode(name, pco, pco.boundingBox);\n    root.hasChildren = true;\n    root.spacing = pco.spacing;\n    if (version.upTo('1.5')) {\n        root.numPoints = data.hierarchy[0][1];\n    }\n    else {\n        root.numPoints = 0;\n    }\n    pco.root = root;\n    nodes[name] = root;\n    return pco.root.load();\n}\nfunction loadRemainingHierarchy(pco, data, nodes) {\n    for (let i = 1; i < data.hierarchy.length; i++) {\n        const [name, numPoints] = data.hierarchy[i];\n        const { index, parentName, level } = parseName(name);\n        const parentNode = nodes[parentName];\n        const boundingBox = createChildAABB(parentNode.boundingBox, index);\n        const node = new PointCloudOctreeGeometryNode(name, pco, boundingBox);\n        node.level = level;\n        node.numPoints = numPoints;\n        node.spacing = pco.spacing / Math.pow(2, node.level);\n        nodes[name] = node;\n        parentNode.addChild(node);\n    }\n}\nfunction parseName(name) {\n    return {\n        index: getIndexFromName(name),\n        parentName: name.substring(0, name.length - 1),\n        level: name.length - 1,\n    };\n}\n\n;// CONCATENATED MODULE: ./src/loading/index.ts\n\n\n\n\n;// CONCATENATED MODULE: ./src/loading2/octree-geometry-node.ts\n\nclass OctreeGeometryNode {\n    constructor(name, octreeGeometry, boundingBox) {\n        this.name = name;\n        this.octreeGeometry = octreeGeometry;\n        this.boundingBox = boundingBox;\n        this.loaded = false;\n        this.loading = false;\n        this.parent = null;\n        this.geometry = null;\n        this.hasChildren = false;\n        this.isLeafNode = true;\n        this.isTreeNode = false;\n        this.isGeometryNode = true;\n        this.children = [\n            null,\n            null,\n            null,\n            null,\n            null,\n            null,\n            null,\n            null\n        ];\n        this.id = OctreeGeometryNode.IDCount++;\n        this.index = parseInt(name.charAt(name.length - 1));\n        this.boundingSphere = boundingBox.getBoundingSphere(new external_three_.Sphere());\n        this.numPoints = 0;\n        this.oneTimeDisposeHandlers = [];\n    }\n    getLevel() {\n        return this.level;\n    }\n    isLoaded() {\n        return this.loaded;\n    }\n    getBoundingSphere() {\n        return this.boundingSphere;\n    }\n    getBoundingBox() {\n        return this.boundingBox;\n    }\n    load() {\n        if (this.octreeGeometry.numNodesLoading >= this.octreeGeometry.maxNumNodesLoading) {\n            return;\n        }\n        if (this.octreeGeometry.loader) {\n            this.octreeGeometry.loader.load(this);\n        }\n    }\n    getNumPoints() {\n        return this.numPoints;\n    }\n    dispose() {\n        if (this.geometry && this.parent != null) {\n            this.geometry.dispose();\n            this.geometry = null;\n            this.loaded = false;\n            for (let i = 0; i < this.oneTimeDisposeHandlers.length; i++) {\n                const handler = this.oneTimeDisposeHandlers[i];\n                handler();\n            }\n            this.oneTimeDisposeHandlers = [];\n        }\n    }\n    traverse(cb, includeSelf = true) {\n        const stack = includeSelf ? [this] : [];\n        let current;\n        while ((current = stack.pop()) !== undefined) {\n            cb(current);\n            for (const child of current.children) {\n                if (child !== null) {\n                    stack.push(child);\n                }\n            }\n        }\n    }\n}\nOctreeGeometryNode.IDCount = 0;\nOctreeGeometryNode.IDCount = 0;\n\n;// CONCATENATED MODULE: ./src/loading2/point-attributes.ts\n/**\n * Some types of possible point attribute data formats\n *\n * @class\n */\nconst PointAttributeTypes = {\n    DATA_TYPE_DOUBLE: { ordinal: 0, name: 'double', size: 8 },\n    DATA_TYPE_FLOAT: { ordinal: 1, name: 'float', size: 4 },\n    DATA_TYPE_INT8: { ordinal: 2, name: 'int8', size: 1 },\n    DATA_TYPE_UINT8: { ordinal: 3, name: 'uint8', size: 1 },\n    DATA_TYPE_INT16: { ordinal: 4, name: 'int16', size: 2 },\n    DATA_TYPE_UINT16: { ordinal: 5, name: 'uint16', size: 2 },\n    DATA_TYPE_INT32: { ordinal: 6, name: 'int32', size: 4 },\n    DATA_TYPE_UINT32: { ordinal: 7, name: 'uint32', size: 4 },\n    DATA_TYPE_INT64: { ordinal: 8, name: 'int64', size: 8 },\n    DATA_TYPE_UINT64: { ordinal: 9, name: 'uint64', size: 8 }\n};\nlet i = 0;\nfor (const obj in PointAttributeTypes) {\n    PointAttributeTypes[i] = PointAttributeTypes[obj];\n    i++;\n}\n\nclass PointAttribute {\n    constructor(name, type, numElements, range = [Infinity, -Infinity]) {\n        this.name = name;\n        this.type = type;\n        this.numElements = numElements;\n        this.range = range;\n        this.byteSize = this.numElements * this.type.size;\n        this.description = '';\n    }\n}\n\nconst point_attributes_POINT_ATTRIBUTES = {\n    POSITION_CARTESIAN: new PointAttribute('POSITION_CARTESIAN', PointAttributeTypes.DATA_TYPE_FLOAT, 3),\n    RGBA_PACKED: new PointAttribute('COLOR_PACKED', PointAttributeTypes.DATA_TYPE_INT8, 4),\n    COLOR_PACKED: new PointAttribute('COLOR_PACKED', PointAttributeTypes.DATA_TYPE_INT8, 4),\n    RGB_PACKED: new PointAttribute('COLOR_PACKED', PointAttributeTypes.DATA_TYPE_INT8, 3),\n    NORMAL_FLOATS: new PointAttribute('NORMAL_FLOATS', PointAttributeTypes.DATA_TYPE_FLOAT, 3),\n    INTENSITY: new PointAttribute('INTENSITY', PointAttributeTypes.DATA_TYPE_UINT16, 1),\n    CLASSIFICATION: new PointAttribute('CLASSIFICATION', PointAttributeTypes.DATA_TYPE_UINT8, 1),\n    NORMAL_SPHEREMAPPED: new PointAttribute('NORMAL_SPHEREMAPPED', PointAttributeTypes.DATA_TYPE_UINT8, 2),\n    NORMAL_OCT16: new PointAttribute('NORMAL_OCT16', PointAttributeTypes.DATA_TYPE_UINT8, 2),\n    NORMAL: new PointAttribute('NORMAL', PointAttributeTypes.DATA_TYPE_FLOAT, 3),\n    RETURN_NUMBER: new PointAttribute('RETURN_NUMBER', PointAttributeTypes.DATA_TYPE_UINT8, 1),\n    NUMBER_OF_RETURNS: new PointAttribute('NUMBER_OF_RETURNS', PointAttributeTypes.DATA_TYPE_UINT8, 1),\n    SOURCE_ID: new PointAttribute('SOURCE_ID', PointAttributeTypes.DATA_TYPE_UINT16, 1),\n    INDICES: new PointAttribute('INDICES', PointAttributeTypes.DATA_TYPE_UINT32, 1),\n    SPACING: new PointAttribute('SPACING', PointAttributeTypes.DATA_TYPE_FLOAT, 1),\n    GPS_TIME: new PointAttribute('GPS_TIME', PointAttributeTypes.DATA_TYPE_DOUBLE, 1)\n};\nclass point_attributes_PointAttributes {\n    constructor(pointAttributes, attributes = [], byteSize = 0, size = 0, vectors = []) {\n        this.attributes = attributes;\n        this.byteSize = byteSize;\n        this.size = size;\n        this.vectors = vectors;\n        if (pointAttributes != null) {\n            for (let i = 0; i < pointAttributes.length; i++) {\n                const pointAttributeName = pointAttributes[i];\n                const pointAttribute = point_attributes_POINT_ATTRIBUTES[pointAttributeName];\n                this.attributes.push(pointAttribute);\n                this.byteSize += pointAttribute.byteSize;\n                this.size++;\n            }\n        }\n    }\n    add(pointAttribute) {\n        this.attributes.push(pointAttribute);\n        this.byteSize += pointAttribute.byteSize;\n        this.size++;\n    }\n    addVector(vector) {\n        this.vectors.push(vector);\n    }\n    hasNormals() {\n        for (const name in this.attributes) {\n            const pointAttribute = this.attributes[name];\n            if (pointAttribute === point_attributes_POINT_ATTRIBUTES.NORMAL_SPHEREMAPPED ||\n                pointAttribute === point_attributes_POINT_ATTRIBUTES.NORMAL_FLOATS ||\n                pointAttribute === point_attributes_POINT_ATTRIBUTES.NORMAL ||\n                pointAttribute === point_attributes_POINT_ATTRIBUTES.NORMAL_OCT16) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n\n;// CONCATENATED MODULE: ./src/loading2/worker-pool.ts\nconst DecoderWorker = (__webpack_require__(300)/* [\"default\"] */ .A);\n// Create enums for different types of workers\nvar WorkerType;\n(function (WorkerType) {\n    WorkerType[\"DECODER_WORKER\"] = \"DECODER_WORKER\";\n})(WorkerType || (WorkerType = {}));\n// Worker JS names: 'BinaryDecoderWorker.js', 'DEMWorker.js', 'EptBinaryDecoderWorker.js', 'EptLaszipDecoderWorker.js',\n// EptZstandardDecoder_preamble.js', 'EptZstandardDecoderWorker.js', 'LASDecoderWorker.js', 'LASLAZWorker.js', 'LazLoaderWorker.js'\nfunction createWorker(type) {\n    // console.log(type)\n    switch (type) {\n        case WorkerType.DECODER_WORKER: {\n            return new DecoderWorker();\n        }\n        default:\n            throw new Error('Unknown worker type');\n    }\n}\nclass worker_pool_WorkerPool {\n    constructor() {\n        // Workers will be an object that has a key for each worker type and the value is an array of Workers that can be empty\n        this.workers = { DECODER_WORKER: [] };\n    }\n    getWorker(workerType) {\n        // Throw error if workerType is not recognized\n        if (this.workers[workerType] === undefined) {\n            throw new Error('Unknown worker type');\n        }\n        // Given a worker URL, if URL does not exist in the worker object, create a new array with the URL as a key\n        if (this.workers[workerType].length === 0) {\n            const worker = createWorker(workerType);\n            this.workers[workerType].push(worker);\n        }\n        const worker = this.workers[workerType].pop();\n        if (worker === undefined) { // Typescript needs this\n            throw new Error('No workers available');\n        }\n        // Return the last worker in the array and remove it from the array\n        return worker;\n    }\n    returnWorker(workerType, worker) {\n        this.workers[workerType].push(worker);\n    }\n}\n\n;// CONCATENATED MODULE: ./src/loading2/octree-loader.ts\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\n\nclass NodeLoader {\n    constructor(url, workerPool, metadata) {\n        this.url = url;\n        this.workerPool = workerPool;\n        this.metadata = metadata;\n    }\n    load(node) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (node.loaded || node.loading) {\n                return;\n            }\n            node.loading = true;\n            node.octreeGeometry.numNodesLoading++;\n            try {\n                if (node.nodeType === 2) {\n                    yield this.loadHierarchy(node);\n                }\n                const { byteOffset, byteSize } = node;\n                if (byteOffset === undefined || byteSize === undefined) {\n                    throw new Error('byteOffset and byteSize are required');\n                }\n                const urlOctree = this.url.replace('/metadata.json', '/octree.bin');\n                const first = byteOffset;\n                const last = byteOffset + byteSize - BigInt(1);\n                let buffer;\n                if (byteSize === BigInt(0)) {\n                    buffer = new ArrayBuffer(0);\n                    console.warn(`loaded node with 0 bytes: ${node.name}`);\n                }\n                else {\n                    const response = yield fetch(urlOctree, {\n                        headers: {\n                            'content-type': 'multipart/byteranges',\n                            Range: `bytes=${first}-${last}`\n                        }\n                    });\n                    buffer = yield response.arrayBuffer();\n                }\n                const workerType = WorkerType.DECODER_WORKER;\n                const worker = this.workerPool.getWorker(workerType);\n                worker.onmessage = (e) => {\n                    const data = e.data;\n                    const buffers = data.attributeBuffers;\n                    this.workerPool.returnWorker(workerType, worker);\n                    const geometry = new external_three_.BufferGeometry();\n                    for (const property in buffers) {\n                        const buffer = buffers[property].buffer;\n                        if (property === 'position') {\n                            geometry.setAttribute('position', new external_three_.BufferAttribute(new Float32Array(buffer), 3));\n                        }\n                        else if (property === 'rgba') {\n                            geometry.setAttribute('rgba', new external_three_.BufferAttribute(new Uint8Array(buffer), 4, true));\n                        }\n                        else if (property === 'NORMAL') {\n                            geometry.setAttribute('normal', new external_three_.BufferAttribute(new Float32Array(buffer), 3));\n                        }\n                        else if (property === 'INDICES') {\n                            const bufferAttribute = new external_three_.BufferAttribute(new Uint8Array(buffer), 4);\n                            bufferAttribute.normalized = true;\n                            geometry.setAttribute('indices', bufferAttribute);\n                        }\n                        else {\n                            const bufferAttribute = new external_three_.BufferAttribute(new Float32Array(buffer), 1);\n                            const batchAttribute = buffers[property].attribute;\n                            bufferAttribute.potree = {\n                                offset: buffers[property].offset,\n                                scale: buffers[property].scale,\n                                preciseBuffer: buffers[property].preciseBuffer,\n                                range: batchAttribute.range\n                            };\n                            geometry.setAttribute(property, bufferAttribute);\n                        }\n                    }\n                    node.density = data.density;\n                    node.geometry = geometry;\n                    node.loaded = true;\n                    node.loading = false;\n                    node.octreeGeometry.numNodesLoading--;\n                };\n                const pointAttributes = node.octreeGeometry.pointAttributes;\n                const scale = node.octreeGeometry.scale;\n                const box = node.boundingBox;\n                const min = node.octreeGeometry.offset.clone().add(box.min);\n                const size = box.max.clone().sub(box.min);\n                const max = min.clone().add(size);\n                const numPoints = node.numPoints;\n                const offset = node.octreeGeometry.loader.offset;\n                const message = {\n                    name: node.name,\n                    buffer: buffer,\n                    pointAttributes: pointAttributes,\n                    scale: scale,\n                    min: min,\n                    max: max,\n                    size: size,\n                    offset: offset,\n                    numPoints: numPoints\n                };\n                worker.postMessage(message, [message.buffer]);\n            }\n            catch (e) {\n                node.loaded = false;\n                node.loading = false;\n                node.octreeGeometry.numNodesLoading--;\n            }\n        });\n    }\n    parseHierarchy(node, buffer) {\n        const view = new DataView(buffer);\n        const bytesPerNode = 22;\n        const numNodes = buffer.byteLength / bytesPerNode;\n        const octree = node.octreeGeometry;\n        const nodes = new Array(numNodes);\n        nodes[0] = node;\n        let nodePos = 1;\n        for (let i = 0; i < numNodes; i++) {\n            const current = nodes[i];\n            const type = view.getUint8(i * bytesPerNode + 0);\n            const childMask = view.getUint8(i * bytesPerNode + 1);\n            const numPoints = view.getUint32(i * bytesPerNode + 2, true);\n            const byteOffset = view.getBigInt64(i * bytesPerNode + 6, true);\n            const byteSize = view.getBigInt64(i * bytesPerNode + 14, true);\n            if (current.nodeType === 2) {\n                // replace proxy with real node\n                current.byteOffset = byteOffset;\n                current.byteSize = byteSize;\n                current.numPoints = numPoints;\n            }\n            else if (type === 2) {\n                // load proxy\n                current.hierarchyByteOffset = byteOffset;\n                current.hierarchyByteSize = byteSize;\n                current.numPoints = numPoints;\n            }\n            else {\n                // load real node\n                current.byteOffset = byteOffset;\n                current.byteSize = byteSize;\n                current.numPoints = numPoints;\n            }\n            current.nodeType = type;\n            if (current.nodeType === 2) {\n                continue;\n            }\n            for (let childIndex = 0; childIndex < 8; childIndex++) {\n                const childExists = (1 << childIndex & childMask) !== 0;\n                if (!childExists) {\n                    continue;\n                }\n                const childName = current.name + childIndex;\n                const childAABB = octree_loader_createChildAABB(current.boundingBox, childIndex);\n                const child = new OctreeGeometryNode(childName, octree, childAABB);\n                child.name = childName;\n                child.spacing = current.spacing / 2;\n                child.level = current.level + 1;\n                current.children[childIndex] = child;\n                child.parent = current;\n                nodes[nodePos] = child;\n                nodePos++;\n            }\n        }\n    }\n    loadHierarchy(node) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { hierarchyByteOffset, hierarchyByteSize } = node;\n            if (hierarchyByteOffset === undefined || hierarchyByteSize === undefined) {\n                throw new Error(`hierarchyByteOffset and hierarchyByteSize are undefined for node ${node.name}`);\n            }\n            const hierarchyPath = this.url.replace('/metadata.json', '/hierarchy.bin');\n            const first = hierarchyByteOffset;\n            const last = first + hierarchyByteSize - BigInt(1);\n            const response = yield fetch(hierarchyPath, {\n                headers: {\n                    'content-type': 'multipart/byteranges',\n                    Range: `bytes=${first}-${last}`\n                }\n            });\n            const buffer = yield response.arrayBuffer();\n            this.parseHierarchy(node, buffer);\n        });\n    }\n}\nconst tmpVec3 = new external_three_.Vector3();\nfunction octree_loader_createChildAABB(aabb, index) {\n    const min = aabb.min.clone();\n    const max = aabb.max.clone();\n    const size = tmpVec3.subVectors(max, min);\n    if ((index & 0b0001) > 0) {\n        min.z += size.z / 2;\n    }\n    else {\n        max.z -= size.z / 2;\n    }\n    if ((index & 0b0010) > 0) {\n        min.y += size.y / 2;\n    }\n    else {\n        max.y -= size.y / 2;\n    }\n    if ((index & 0b0100) > 0) {\n        min.x += size.x / 2;\n    }\n    else {\n        max.x -= size.x / 2;\n    }\n    return new external_three_.Box3(min, max);\n}\nconst typenameTypeattributeMap = {\n    double: PointAttributeTypes.DATA_TYPE_DOUBLE,\n    float: PointAttributeTypes.DATA_TYPE_FLOAT,\n    int8: PointAttributeTypes.DATA_TYPE_INT8,\n    uint8: PointAttributeTypes.DATA_TYPE_UINT8,\n    int16: PointAttributeTypes.DATA_TYPE_INT16,\n    uint16: PointAttributeTypes.DATA_TYPE_UINT16,\n    int32: PointAttributeTypes.DATA_TYPE_INT32,\n    uint32: PointAttributeTypes.DATA_TYPE_UINT32,\n    int64: PointAttributeTypes.DATA_TYPE_INT64,\n    uint64: PointAttributeTypes.DATA_TYPE_UINT64\n};\nclass OctreeLoader {\n    constructor() {\n        this.workerPool = new worker_pool_WorkerPool();\n    }\n    static parseAttributes(jsonAttributes) {\n        const attributes = new point_attributes_PointAttributes();\n        const replacements = { rgb: 'rgba' };\n        for (const jsonAttribute of jsonAttributes) {\n            const { name, numElements, min, max } = jsonAttribute;\n            const type = typenameTypeattributeMap[jsonAttribute.type];\n            const potreeAttributeName = replacements[name] ? replacements[name] : name;\n            const attribute = new PointAttribute(potreeAttributeName, type, numElements);\n            if (numElements === 1) {\n                attribute.range = [min[0], max[0]];\n            }\n            else {\n                attribute.range = [min, max];\n            }\n            if (name === 'gps-time') { // HACK: Guard against bad gpsTime range in metadata, see potree/potree#909\n                if (typeof attribute.range[0] === 'number' && attribute.range[0] === attribute.range[1]) {\n                    attribute.range[1] += 1;\n                }\n            }\n            attribute.initialRange = attribute.range;\n            attributes.add(attribute);\n        }\n        {\n            const hasNormals = attributes.attributes.find((a) => a.name === 'NormalX') !== undefined &&\n                attributes.attributes.find((a) => a.name === 'NormalY') !== undefined &&\n                attributes.attributes.find((a) => a.name === 'NormalZ') !== undefined;\n            if (hasNormals) {\n                const vector = {\n                    name: 'NORMAL',\n                    attributes: ['NormalX', 'NormalY', 'NormalZ']\n                };\n                attributes.addVector(vector);\n            }\n        }\n        return attributes;\n    }\n    load(url, xhrRequest) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield xhrRequest(url);\n            const metadata = yield response.json();\n            const attributes = OctreeLoader.parseAttributes(metadata.attributes);\n            const loader = new NodeLoader(url, this.workerPool, metadata);\n            loader.attributes = attributes;\n            loader.scale = metadata.scale;\n            loader.offset = metadata.offset;\n            const octree = new OctreeGeometry(loader, new external_three_.Box3(new external_three_.Vector3(...metadata.boundingBox.min), new external_three_.Vector3(...metadata.boundingBox.max)));\n            octree.url = url;\n            octree.spacing = metadata.spacing;\n            octree.scale = metadata.scale;\n            const min = new external_three_.Vector3(...metadata.boundingBox.min);\n            const max = new external_three_.Vector3(...metadata.boundingBox.max);\n            const boundingBox = new external_three_.Box3(min, max);\n            const offset = min.clone();\n            boundingBox.min.sub(offset);\n            boundingBox.max.sub(offset);\n            octree.projection = metadata.projection;\n            octree.boundingBox = boundingBox;\n            octree.tightBoundingBox = boundingBox.clone();\n            octree.boundingSphere = boundingBox.getBoundingSphere(new external_three_.Sphere());\n            octree.tightBoundingSphere = boundingBox.getBoundingSphere(new external_three_.Sphere());\n            octree.offset = offset;\n            octree.pointAttributes = OctreeLoader.parseAttributes(metadata.attributes);\n            const root = new OctreeGeometryNode('r', octree, boundingBox);\n            root.level = 0;\n            root.nodeType = 2;\n            root.hierarchyByteOffset = BigInt(0);\n            root.hierarchyByteSize = BigInt(metadata.hierarchy.firstChunkSize);\n            root.spacing = octree.spacing;\n            root.byteOffset = BigInt(0);\n            octree.root = root;\n            loader.load(root);\n            const result = { geometry: octree };\n            return result;\n        });\n    }\n}\n\n;// CONCATENATED MODULE: ./src/loading2/load-octree.ts\nvar load_octree_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\nfunction loadOctree(url, getUrl, xhrRequest) {\n    return load_octree_awaiter(this, void 0, void 0, function* () {\n        const trueUrl = yield getUrl(url);\n        const loader = new OctreeLoader();\n        const { geometry } = yield loader.load(trueUrl, xhrRequest);\n        return geometry;\n    });\n}\n\n;// CONCATENATED MODULE: ./src/type-predicates.ts\nfunction isGeometryNode(node) {\n    return node !== undefined && node !== null && node.isGeometryNode;\n}\nfunction isTreeNode(node) {\n    return node !== undefined && node !== null && node.isTreeNode;\n}\n\n;// CONCATENATED MODULE: ./src/utils/binary-heap.js\n/**\n * from: http://eloquentjavascript.net/1st_edition/appendix2.html\n *\n */\n\nfunction BinaryHeap(scoreFunction) {\n  this.content = [];\n  this.scoreFunction = scoreFunction;\n}\nBinaryHeap.prototype = {\n  push: function push(element) {\n    // Add the new element to the end of the array.\n    this.content.push(element);\n    // Allow it to bubble up.\n    this.bubbleUp(this.content.length - 1);\n  },\n  pop: function pop() {\n    // Store the first element so we can return it later.\n    var result = this.content[0];\n    // Get the element at the end of the array.\n    var end = this.content.pop();\n    // If there are any elements left, put the end element at the\n    // start, and let it sink down.\n    if (this.content.length > 0) {\n      this.content[0] = end;\n      this.sinkDown(0);\n    }\n    return result;\n  },\n  remove: function remove(node) {\n    var length = this.content.length;\n    // To remove a value, we must search through the array to find\n    // it.\n    for (var i = 0; i < length; i++) {\n      if (this.content[i] != node) continue;\n      // When it is found, the process seen in 'pop' is repeated\n      // to fill up the hole.\n      var end = this.content.pop();\n      // If the element we popped was the one we needed to remove,\n      // we're done.\n      if (i == length - 1) break;\n      // Otherwise, we replace the removed element with the popped\n      // one, and allow it to float up or sink down as appropriate.\n      this.content[i] = end;\n      this.bubbleUp(i);\n      this.sinkDown(i);\n      break;\n    }\n  },\n  size: function size() {\n    return this.content.length;\n  },\n  bubbleUp: function bubbleUp(n) {\n    // Fetch the element that has to be moved.\n    var element = this.content[n],\n      score = this.scoreFunction(element);\n    // When at 0, an element can not go up any further.\n    while (n > 0) {\n      // Compute the parent element's index, and fetch it.\n      var parentN = Math.floor((n + 1) / 2) - 1,\n        parent = this.content[parentN];\n      // If the parent has a lesser score, things are in order and we\n      // are done.\n      if (score >= this.scoreFunction(parent)) break;\n\n      // Otherwise, swap the parent with the current element and\n      // continue.\n      this.content[parentN] = element;\n      this.content[n] = parent;\n      n = parentN;\n    }\n  },\n  sinkDown: function sinkDown(n) {\n    // Look up the target element and its score.\n    var length = this.content.length,\n      element = this.content[n],\n      elemScore = this.scoreFunction(element);\n    while (true) {\n      // Compute the indices of the child elements.\n      var child2N = (n + 1) * 2,\n        child1N = child2N - 1;\n      // This is used to store the new position of the element,\n      // if any.\n      var swap = null;\n      // If the first child exists (is inside the array)...\n      if (child1N < length) {\n        // Look it up and compute its score.\n        var child1 = this.content[child1N],\n          child1Score = this.scoreFunction(child1);\n        // If the score is less than our element's, we need to swap.\n        if (child1Score < elemScore) swap = child1N;\n      }\n      // Do the same checks for the other child.\n      if (child2N < length) {\n        var child2 = this.content[child2N],\n          child2Score = this.scoreFunction(child2);\n        if (child2Score < (swap == null ? elemScore : child1Score)) swap = child2N;\n      }\n\n      // No need to swap further, we are done.\n      if (swap == null) break;\n\n      // Otherwise, swap and continue.\n      this.content[n] = this.content[swap];\n      this.content[swap] = element;\n      n = swap;\n    }\n  }\n};\n;// CONCATENATED MODULE: ./src/utils/box3-helper.ts\n\n/**\n *\n * code adapted from three.js BoxHelper.js\n * https://github.com/mrdoob/three.js/blob/dev/src/helpers/BoxHelper.js\n *\n * @author mrdoob / http://mrdoob.com/\n * @author Mugen87 / http://github.com/Mugen87\n * @author mschuetz / http://potree.org\n */\nclass Box3Helper extends external_three_.LineSegments {\n    constructor(box, color = new external_three_.Color(0xffff00)) {\n        // prettier-ignore\n        const indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);\n        // prettier-ignore\n        const positions = new Float32Array([\n            box.min.x, box.min.y, box.min.z,\n            box.max.x, box.min.y, box.min.z,\n            box.max.x, box.min.y, box.max.z,\n            box.min.x, box.min.y, box.max.z,\n            box.min.x, box.max.y, box.min.z,\n            box.max.x, box.max.y, box.min.z,\n            box.max.x, box.max.y, box.max.z,\n            box.min.x, box.max.y, box.max.z\n        ]);\n        const geometry = new external_three_.BufferGeometry();\n        geometry.setIndex(new external_three_.BufferAttribute(indices, 1));\n        geometry.setAttribute('position', new external_three_.BufferAttribute(positions, 3));\n        const material = new external_three_.LineBasicMaterial({ color: color });\n        super(geometry, material);\n    }\n}\n\n;// CONCATENATED MODULE: ./src/utils/lru.ts\nclass LRUItem {\n    constructor(node) {\n        this.node = node;\n        this.next = null;\n        this.previous = null;\n    }\n}\n/**\n * A doubly-linked-list of the least recently used elements.\n */\nclass LRU {\n    constructor(pointBudget = 1000000) {\n        this.pointBudget = pointBudget;\n        // the least recently used item\n        this.first = null;\n        // the most recently used item\n        this.last = null;\n        this.numPoints = 0;\n        this.items = new Map();\n    }\n    get size() {\n        return this.items.size;\n    }\n    has(node) {\n        return this.items.has(node.id);\n    }\n    /**\n     * Makes the specified the most recently used item. if the list does not contain node, it will\n     * be added.\n     */\n    touch(node) {\n        if (!node.loaded) {\n            return;\n        }\n        const item = this.items.get(node.id);\n        if (item) {\n            this.touchExisting(item);\n        }\n        else {\n            this.addNew(node);\n        }\n    }\n    addNew(node) {\n        const item = new LRUItem(node);\n        item.previous = this.last;\n        this.last = item;\n        if (item.previous) {\n            item.previous.next = item;\n        }\n        if (!this.first) {\n            this.first = item;\n        }\n        this.items.set(node.id, item);\n        this.numPoints += node.numPoints;\n    }\n    touchExisting(item) {\n        if (!item.previous) {\n            // handle touch on first element\n            if (item.next) {\n                this.first = item.next;\n                this.first.previous = null;\n                item.previous = this.last;\n                item.next = null;\n                this.last = item;\n                if (item.previous) {\n                    item.previous.next = item;\n                }\n            }\n        }\n        else if (!item.next) {\n            // handle touch on last element\n        }\n        else {\n            // handle touch on any other element\n            item.previous.next = item.next;\n            item.next.previous = item.previous;\n            item.previous = this.last;\n            item.next = null;\n            this.last = item;\n            if (item.previous) {\n                item.previous.next = item;\n            }\n        }\n    }\n    remove(node) {\n        const item = this.items.get(node.id);\n        if (!item) {\n            return;\n        }\n        if (this.items.size === 1) {\n            this.first = null;\n            this.last = null;\n        }\n        else {\n            if (!item.previous) {\n                this.first = item.next;\n                this.first.previous = null;\n            }\n            if (!item.next) {\n                this.last = item.previous;\n                this.last.next = null;\n            }\n            if (item.previous && item.next) {\n                item.previous.next = item.next;\n                item.next.previous = item.previous;\n            }\n        }\n        this.items.delete(node.id);\n        this.numPoints -= node.numPoints;\n    }\n    getLRUItem() {\n        return this.first ? this.first.node : undefined;\n    }\n    freeMemory() {\n        if (this.items.size <= 1) {\n            return;\n        }\n        while (this.numPoints > this.pointBudget * 2) {\n            const node = this.getLRUItem();\n            if (node) {\n                this.disposeSubtree(node);\n            }\n        }\n    }\n    disposeSubtree(node) {\n        // Collect all the nodes which are to be disposed and removed.\n        const nodesToDispose = [node];\n        node.traverse(n => {\n            if (n.loaded) {\n                nodesToDispose.push(n);\n            }\n        });\n        // Dispose of all the nodes in one go.\n        for (const n of nodesToDispose) {\n            n.dispose();\n            this.remove(n);\n        }\n    }\n}\n\n;// CONCATENATED MODULE: ./src/potree.ts\n\n\n\n\n\n\n\n\n\n\n\n\nclass QueueItem {\n    constructor(pointCloudIndex, weight, node, parent) {\n        this.pointCloudIndex = pointCloudIndex;\n        this.weight = weight;\n        this.node = node;\n        this.parent = parent;\n    }\n}\nconst GEOMETRY_LOADERS = {\n    v1: loadPOC,\n    v2: loadOctree\n};\nclass Potree {\n    constructor(version = \"v1\") {\n        this._pointBudget = DEFAULT_POINT_BUDGET;\n        this._rendererSize = new external_three_.Vector2();\n        this.maxNumNodesLoading = MAX_NUM_NODES_LOADING;\n        this.features = FEATURES;\n        this.lru = new LRU(this._pointBudget);\n        this.updateVisibilityStructures = (() => {\n            const frustumMatrix = new external_three_.Matrix4();\n            const inverseWorldMatrix = new external_three_.Matrix4();\n            const cameraMatrix = new external_three_.Matrix4();\n            return (pointClouds, camera) => {\n                const frustums = [];\n                const cameraPositions = [];\n                const priorityQueue = new BinaryHeap(x => 1 / x.weight);\n                for (let i = 0; i < pointClouds.length; i++) {\n                    const pointCloud = pointClouds[i];\n                    if (!pointCloud.initialized()) {\n                        continue;\n                    }\n                    pointCloud.numVisiblePoints = 0;\n                    pointCloud.visibleNodes = [];\n                    pointCloud.visibleGeometry = [];\n                    camera.updateMatrixWorld(false);\n                    // Furstum in object space.\n                    const inverseViewMatrix = camera.matrixWorldInverse;\n                    const worldMatrix = pointCloud.matrixWorld;\n                    frustumMatrix\n                        .identity()\n                        .multiply(camera.projectionMatrix)\n                        .multiply(inverseViewMatrix)\n                        .multiply(worldMatrix);\n                    frustums.push(new external_three_.Frustum().setFromProjectionMatrix(frustumMatrix));\n                    // Camera position in object space\n                    inverseWorldMatrix.copy(worldMatrix).invert();\n                    cameraMatrix\n                        .identity()\n                        .multiply(inverseWorldMatrix)\n                        .multiply(camera.matrixWorld);\n                    cameraPositions.push(new external_three_.Vector3().setFromMatrixPosition(cameraMatrix));\n                    if (pointCloud.visible && pointCloud.root !== null) {\n                        const weight = Number.MAX_VALUE;\n                        priorityQueue.push(new QueueItem(i, weight, pointCloud.root));\n                    }\n                    // Hide any previously visible nodes. We will later show only the needed ones.\n                    if (isTreeNode(pointCloud.root)) {\n                        pointCloud.hideDescendants(pointCloud.root.sceneNode);\n                    }\n                    for (const boundingBoxNode of pointCloud.boundingBoxNodes) {\n                        boundingBoxNode.visible = false;\n                    }\n                }\n                return { frustums, cameraPositions, priorityQueue };\n            };\n        })();\n        this.loadGeometry = GEOMETRY_LOADERS[version];\n    }\n    loadPointCloud(url, getUrl, xhrRequest = (input, init) => fetch(input, init)) {\n        return this.loadGeometry(url, getUrl, xhrRequest).then(geometry => new PointCloudOctree(this, geometry));\n    }\n    updatePointClouds(pointClouds, camera, renderer) {\n        const result = this.updateVisibility(pointClouds, camera, renderer);\n        for (let i = 0; i < pointClouds.length; i++) {\n            const pointCloud = pointClouds[i];\n            if (pointCloud.disposed) {\n                continue;\n            }\n            pointCloud.material.updateMaterial(pointCloud, pointCloud.visibleNodes, camera, renderer);\n            pointCloud.updateVisibleBounds();\n            pointCloud.updateBoundingBoxes();\n        }\n        this.lru.freeMemory();\n        return result;\n    }\n    static pick(pointClouds, renderer, camera, ray, params = {}) {\n        Potree.picker = Potree.picker || new PointCloudOctreePicker();\n        return Potree.picker.pick(renderer, camera, ray, pointClouds, params);\n    }\n    get pointBudget() {\n        return this._pointBudget;\n    }\n    set pointBudget(value) {\n        if (value !== this._pointBudget) {\n            this._pointBudget = value;\n            this.lru.pointBudget = value;\n            this.lru.freeMemory();\n        }\n    }\n    static set maxLoaderWorkers(value) {\n        BinaryLoader.WORKER_POOL.maxWorkers = value;\n    }\n    static get maxLoaderWorkers() {\n        return BinaryLoader.WORKER_POOL.maxWorkers;\n    }\n    updateVisibility(pointClouds, camera, renderer) {\n        let numVisiblePoints = 0;\n        const visibleNodes = [];\n        const unloadedGeometry = [];\n        // calculate object space frustum and cam pos and setup priority queue\n        const { frustums, cameraPositions, priorityQueue } = this.updateVisibilityStructures(pointClouds, camera);\n        let loadedToGPUThisFrame = 0;\n        let exceededMaxLoadsToGPU = false;\n        let nodeLoadFailed = false;\n        let queueItem;\n        while ((queueItem = priorityQueue.pop()) !== undefined) {\n            let node = queueItem.node;\n            // If we will end up with too many points, we stop right away.\n            if (numVisiblePoints + node.numPoints > this.pointBudget) {\n                break;\n            }\n            const pointCloudIndex = queueItem.pointCloudIndex;\n            const pointCloud = pointClouds[pointCloudIndex];\n            const maxLevel = pointCloud.maxLevel !== undefined ? pointCloud.maxLevel : Infinity;\n            if (node.level > maxLevel ||\n                !frustums[pointCloudIndex].intersectsBox(node.boundingBox) ||\n                this.shouldClip(pointCloud, node.boundingBox)) {\n                continue;\n            }\n            numVisiblePoints += node.numPoints;\n            pointCloud.numVisiblePoints += node.numPoints;\n            const parentNode = queueItem.parent;\n            if (isGeometryNode(node) && (!parentNode || isTreeNode(parentNode))) {\n                if (node.loaded && loadedToGPUThisFrame < MAX_LOADS_TO_GPU) {\n                    node = pointCloud.toTreeNode(node, parentNode);\n                    loadedToGPUThisFrame++;\n                }\n                else if (!node.failed) {\n                    if (node.loaded && loadedToGPUThisFrame >= MAX_LOADS_TO_GPU) {\n                        exceededMaxLoadsToGPU = true;\n                    }\n                    unloadedGeometry.push(node);\n                    pointCloud.visibleGeometry.push(node);\n                }\n                else {\n                    nodeLoadFailed = true;\n                    continue;\n                }\n            }\n            if (isTreeNode(node)) {\n                this.updateTreeNodeVisibility(pointCloud, node, visibleNodes);\n                pointCloud.visibleGeometry.push(node.geometryNode);\n            }\n            const halfHeight = 0.5 * renderer.getSize(this._rendererSize).height * renderer.getPixelRatio();\n            this.updateChildVisibility(queueItem, priorityQueue, pointCloud, node, cameraPositions[pointCloudIndex], camera, halfHeight);\n        } // end priority queue loop\n        const numNodesToLoad = Math.min(this.maxNumNodesLoading, unloadedGeometry.length);\n        const nodeLoadPromises = [];\n        for (let i = 0; i < numNodesToLoad; i++) {\n            nodeLoadPromises.push(unloadedGeometry[i].load());\n        }\n        return {\n            visibleNodes: visibleNodes,\n            numVisiblePoints: numVisiblePoints,\n            exceededMaxLoadsToGPU: exceededMaxLoadsToGPU,\n            nodeLoadFailed: nodeLoadFailed,\n            nodeLoadPromises: nodeLoadPromises,\n        };\n    }\n    updateTreeNodeVisibility(pointCloud, node, visibleNodes) {\n        this.lru.touch(node.geometryNode);\n        const sceneNode = node.sceneNode;\n        sceneNode.visible = true;\n        sceneNode.material = pointCloud.material;\n        sceneNode.updateMatrix();\n        sceneNode.matrixWorld.multiplyMatrices(pointCloud.matrixWorld, sceneNode.matrix);\n        visibleNodes.push(node);\n        pointCloud.visibleNodes.push(node);\n        this.updateBoundingBoxVisibility(pointCloud, node);\n    }\n    updateChildVisibility(queueItem, priorityQueue, pointCloud, node, cameraPosition, camera, halfHeight) {\n        const children = node.children;\n        for (let i = 0; i < children.length; i++) {\n            const child = children[i];\n            if (child === null) {\n                continue;\n            }\n            const sphere = child.boundingSphere;\n            const distance = sphere.center.distanceTo(cameraPosition);\n            const radius = sphere.radius;\n            let projectionFactor = 0.0;\n            if (camera.type === PERSPECTIVE_CAMERA) {\n                const perspective = camera;\n                const fov = (perspective.fov * Math.PI) / 180.0;\n                const slope = Math.tan(fov / 2.0);\n                projectionFactor = halfHeight / (slope * distance);\n            }\n            else {\n                const orthographic = camera;\n                projectionFactor = (2 * halfHeight) / (orthographic.top - orthographic.bottom);\n            }\n            const screenPixelRadius = radius * projectionFactor;\n            // Don't add the node if it'll be too small on the screen.\n            if (screenPixelRadius < pointCloud.minNodePixelSize) {\n                continue;\n            }\n            // Nodes which are larger will have priority in loading/displaying.\n            const weight = distance < radius ? Number.MAX_VALUE : screenPixelRadius + 1 / distance;\n            priorityQueue.push(new QueueItem(queueItem.pointCloudIndex, weight, child, node));\n        }\n    }\n    updateBoundingBoxVisibility(pointCloud, node) {\n        if (pointCloud.showBoundingBox && !node.boundingBoxNode) {\n            const boxHelper = new Box3Helper(node.boundingBox);\n            boxHelper.matrixAutoUpdate = false;\n            pointCloud.boundingBoxNodes.push(boxHelper);\n            node.boundingBoxNode = boxHelper;\n            node.boundingBoxNode.matrix.copy(pointCloud.matrixWorld);\n        }\n        else if (pointCloud.showBoundingBox && node.boundingBoxNode) {\n            node.boundingBoxNode.visible = true;\n            node.boundingBoxNode.matrix.copy(pointCloud.matrixWorld);\n        }\n        else if (!pointCloud.showBoundingBox && node.boundingBoxNode) {\n            node.boundingBoxNode.visible = false;\n        }\n    }\n    shouldClip(pointCloud, boundingBox) {\n        const material = pointCloud.material;\n        if (material.numClipBoxes === 0 || material.clipMode !== ClipMode.CLIP_OUTSIDE) {\n            return false;\n        }\n        const box2 = boundingBox.clone();\n        pointCloud.updateMatrixWorld(true);\n        box2.applyMatrix4(pointCloud.matrixWorld);\n        const clipBoxes = material.clipBoxes;\n        for (let i = 0; i < clipBoxes.length; i++) {\n            const clipMatrixWorld = clipBoxes[i].matrix;\n            const clipBoxWorld = new external_three_.Box3(new external_three_.Vector3(-0.5, -0.5, -0.5), new external_three_.Vector3(0.5, 0.5, 0.5)).applyMatrix4(clipMatrixWorld);\n            if (box2.intersectsBox(clipBoxWorld)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n;// CONCATENATED MODULE: ./src/loading2/index.ts\n\n\n;// CONCATENATED MODULE: ./src/index.ts\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTk5LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2hwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3pOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDN0RBO0FBQ0E7QUFDQTs7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDalBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMxS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzVJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNoSEE7QUFDQTtBQUNBOzs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDeEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN6VEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMxSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2xRQTs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wb3RyZWUvLi9zcmMvbWF0ZXJpYWxzL2JsdXItbWF0ZXJpYWwudHM/NTczOSIsIndlYnBhY2s6Ly9wb3RyZWUvLi9zcmMvbWF0ZXJpYWxzL2NsaXBwaW5nLnRzPzFmOTYiLCJ3ZWJwYWNrOi8vcG90cmVlLy4vc3JjL21hdGVyaWFscy9lbnVtcy50cz85NjQyIiwid2VicGFjazovL3BvdHJlZS8uL3NyYy9jb25zdGFudHMudHM/YzNiNCIsIndlYnBhY2s6Ly9wb3RyZWUvLi9zcmMvdXRpbHMvdXRpbHMudHM/NTYyMiIsIndlYnBhY2s6Ly9wb3RyZWUvLi9zcmMvbWF0ZXJpYWxzL2NsYXNzaWZpY2F0aW9uLnRzP2ZhM2MiLCJ3ZWJwYWNrOi8vcG90cmVlLy4vc3JjL21hdGVyaWFscy9ncmFkaWVudHMvZ3JheXNjYWxlLnRzPzkyZDgiLCJ3ZWJwYWNrOi8vcG90cmVlLy4vc3JjL21hdGVyaWFscy9ncmFkaWVudHMvaW5mZXJuby50cz85MDMzIiwid2VicGFjazovL3BvdHJlZS8uL3NyYy9tYXRlcmlhbHMvZ3JhZGllbnRzL3BsYXNtYS50cz9jZWJmIiwid2VicGFjazovL3BvdHJlZS8uL3NyYy9tYXRlcmlhbHMvZ3JhZGllbnRzL3JhaW5ib3cudHM/YjEyYSIsIndlYnBhY2s6Ly9wb3RyZWUvLi9zcmMvbWF0ZXJpYWxzL2dyYWRpZW50cy9zcGVjdHJhbC50cz9iMGEyIiwid2VicGFjazovL3BvdHJlZS8uL3NyYy9tYXRlcmlhbHMvZ3JhZGllbnRzL3ZpZHJpcy50cz83Y2ZkIiwid2VicGFjazovL3BvdHJlZS8uL3NyYy9tYXRlcmlhbHMvZ3JhZGllbnRzL3llbGxvdy1ncmVlbi50cz9kMjA3Iiwid2VicGFjazovL3BvdHJlZS8uL3NyYy9tYXRlcmlhbHMvZ3JhZGllbnRzL2luZGV4LnRzPzJjOGUiLCJ3ZWJwYWNrOi8vcG90cmVlLy4vc3JjL21hdGVyaWFscy90ZXh0dXJlLWdlbmVyYXRpb24udHM/MWVlNyIsIndlYnBhY2s6Ly9wb3RyZWUvLi9zcmMvbWF0ZXJpYWxzL3BvaW50LWNsb3VkLW1hdGVyaWFsLnRzPzk1NDAiLCJ3ZWJwYWNrOi8vcG90cmVlLy4vc3JjL21hdGVyaWFscy9pbmRleC50cz85MDI5Iiwid2VicGFjazovL3BvdHJlZS8uL3NyYy9wb2ludC1hdHRyaWJ1dGVzLnRzP2UwMzIiLCJ3ZWJwYWNrOi8vcG90cmVlLy4vc3JjL3V0aWxzL2JvdW5kcy50cz9kNTBlIiwid2VicGFjazovL3BvdHJlZS8uL3NyYy9wb2ludC1jbG91ZC1vY3RyZWUtZ2VvbWV0cnktbm9kZS50cz8xOGVhIiwid2VicGFjazovL3BvdHJlZS8uL3NyYy9wb2ludC1jbG91ZC1vY3RyZWUtZ2VvbWV0cnkudHM/OWY4MCIsIndlYnBhY2s6Ly9wb3RyZWUvLi9zcmMvcG9pbnQtY2xvdWQtb2N0cmVlLW5vZGUudHM/ZGExNyIsIndlYnBhY2s6Ly9wb3RyZWUvLi9zcmMvdXRpbHMvbWF0aC50cz82MWY4Iiwid2VicGFjazovL3BvdHJlZS8uL3NyYy9wb2ludC1jbG91ZC1vY3RyZWUtcGlja2VyLnRzPzFlM2MiLCJ3ZWJwYWNrOi8vcG90cmVlLy4vc3JjL2xvYWRpbmcyL29jdHJlZS1nZW9tZXRyeS50cz8yYTU1Iiwid2VicGFjazovL3BvdHJlZS8uL3NyYy9wb2ludC1jbG91ZC10cmVlLnRzPzE1NGMiLCJ3ZWJwYWNrOi8vcG90cmVlLy4vc3JjL3BvaW50LWNsb3VkLW9jdHJlZS50cz8zOWNhIiwid2VicGFjazovL3BvdHJlZS8uL3NyYy9mZWF0dXJlcy50cz8yOGMwIiwid2VicGFjazovL3BvdHJlZS8uL3NyYy91dGlscy9hc3luYy1ibG9ja2luZy1xdWV1ZS50cz8zYjMzIiwid2VicGFjazovL3BvdHJlZS8uL3NyYy91dGlscy93b3JrZXItcG9vbC50cz8zNmJmIiwid2VicGFjazovL3BvdHJlZS8uL3NyYy92ZXJzaW9uLnRzPzEwMjkiLCJ3ZWJwYWNrOi8vcG90cmVlLy4vc3JjL2xvYWRpbmcvYmluYXJ5LWxvYWRlci50cz9jZDM0Iiwid2VicGFjazovL3BvdHJlZS8uL3NyYy9sb2FkaW5nL2xvYWQtcG9jLnRzPzNkNjIiLCJ3ZWJwYWNrOi8vcG90cmVlLy4vc3JjL2xvYWRpbmcvaW5kZXgudHM/MWE0YiIsIndlYnBhY2s6Ly9wb3RyZWUvLi9zcmMvbG9hZGluZzIvb2N0cmVlLWdlb21ldHJ5LW5vZGUudHM/MzljMCIsIndlYnBhY2s6Ly9wb3RyZWUvLi9zcmMvbG9hZGluZzIvcG9pbnQtYXR0cmlidXRlcy50cz9kY2UwIiwid2VicGFjazovL3BvdHJlZS8uL3NyYy9sb2FkaW5nMi93b3JrZXItcG9vbC50cz8wZmFmIiwid2VicGFjazovL3BvdHJlZS8uL3NyYy9sb2FkaW5nMi9vY3RyZWUtbG9hZGVyLnRzP2Y2OTAiLCJ3ZWJwYWNrOi8vcG90cmVlLy4vc3JjL2xvYWRpbmcyL2xvYWQtb2N0cmVlLnRzPzQzMTAiLCJ3ZWJwYWNrOi8vcG90cmVlLy4vc3JjL3R5cGUtcHJlZGljYXRlcy50cz8zMTQzIiwid2VicGFjazovL3BvdHJlZS8uL3NyYy91dGlscy9iaW5hcnktaGVhcC5qcz8yNDUwIiwid2VicGFjazovL3BvdHJlZS8uL3NyYy91dGlscy9ib3gzLWhlbHBlci50cz83MWEwIiwid2VicGFjazovL3BvdHJlZS8uL3NyYy91dGlscy9scnUudHM/OGUwZSIsIndlYnBhY2s6Ly9wb3RyZWUvLi9zcmMvcG90cmVlLnRzPzlkOTciLCJ3ZWJwYWNrOi8vcG90cmVlLy4vc3JjL2xvYWRpbmcyL2luZGV4LnRzPzBlZWEiLCJ3ZWJwYWNrOi8vcG90cmVlLy4vc3JjL2luZGV4LnRzP2U5NGUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU2hhZGVyTWF0ZXJpYWwgfSBmcm9tICd0aHJlZSc7XG5leHBvcnQgY2xhc3MgQmx1ck1hdGVyaWFsIGV4dGVuZHMgU2hhZGVyTWF0ZXJpYWwge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnZlcnRleFNoYWRlciA9IHJlcXVpcmUoJy4vc2hhZGVycy9ibHVyLnZlcnQnKTtcbiAgICAgICAgdGhpcy5mcmFnbWVudFNoYWRlciA9IHJlcXVpcmUoJy4vc2hhZGVycy9ibHVyLmZyYWcnKTtcbiAgICAgICAgdGhpcy51bmlmb3JtcyA9IHtcbiAgICAgICAgICAgIHNjcmVlbldpZHRoOiB7IHR5cGU6ICdmJywgdmFsdWU6IDAgfSxcbiAgICAgICAgICAgIHNjcmVlbkhlaWdodDogeyB0eXBlOiAnZicsIHZhbHVlOiAwIH0sXG4gICAgICAgICAgICBtYXA6IHsgdHlwZTogJ3QnLCB2YWx1ZTogbnVsbCB9LFxuICAgICAgICB9O1xuICAgIH1cbn1cbiIsImV4cG9ydCB2YXIgQ2xpcE1vZGU7XG4oZnVuY3Rpb24gKENsaXBNb2RlKSB7XG4gICAgQ2xpcE1vZGVbQ2xpcE1vZGVbXCJESVNBQkxFRFwiXSA9IDBdID0gXCJESVNBQkxFRFwiO1xuICAgIENsaXBNb2RlW0NsaXBNb2RlW1wiQ0xJUF9PVVRTSURFXCJdID0gMV0gPSBcIkNMSVBfT1VUU0lERVwiO1xuICAgIENsaXBNb2RlW0NsaXBNb2RlW1wiSElHSExJR0hUX0lOU0lERVwiXSA9IDJdID0gXCJISUdITElHSFRfSU5TSURFXCI7XG4gICAgQ2xpcE1vZGVbQ2xpcE1vZGVbXCJDTElQX0hPUklaT05UQUxMWVwiXSA9IDNdID0gXCJDTElQX0hPUklaT05UQUxMWVwiO1xuICAgIENsaXBNb2RlW0NsaXBNb2RlW1wiQ0xJUF9WRVJUSUNBTExZXCJdID0gNF0gPSBcIkNMSVBfVkVSVElDQUxMWVwiO1xufSkoQ2xpcE1vZGUgfHwgKENsaXBNb2RlID0ge30pKTtcbiIsImV4cG9ydCB2YXIgUG9pbnRTaXplVHlwZTtcbihmdW5jdGlvbiAoUG9pbnRTaXplVHlwZSkge1xuICAgIFBvaW50U2l6ZVR5cGVbUG9pbnRTaXplVHlwZVtcIkZJWEVEXCJdID0gMF0gPSBcIkZJWEVEXCI7XG4gICAgUG9pbnRTaXplVHlwZVtQb2ludFNpemVUeXBlW1wiQVRURU5VQVRFRFwiXSA9IDFdID0gXCJBVFRFTlVBVEVEXCI7XG4gICAgUG9pbnRTaXplVHlwZVtQb2ludFNpemVUeXBlW1wiQURBUFRJVkVcIl0gPSAyXSA9IFwiQURBUFRJVkVcIjtcbn0pKFBvaW50U2l6ZVR5cGUgfHwgKFBvaW50U2l6ZVR5cGUgPSB7fSkpO1xuZXhwb3J0IHZhciBQb2ludFNoYXBlO1xuKGZ1bmN0aW9uIChQb2ludFNoYXBlKSB7XG4gICAgUG9pbnRTaGFwZVtQb2ludFNoYXBlW1wiU1FVQVJFXCJdID0gMF0gPSBcIlNRVUFSRVwiO1xuICAgIFBvaW50U2hhcGVbUG9pbnRTaGFwZVtcIkNJUkNMRVwiXSA9IDFdID0gXCJDSVJDTEVcIjtcbiAgICBQb2ludFNoYXBlW1BvaW50U2hhcGVbXCJQQVJBQk9MT0lEXCJdID0gMl0gPSBcIlBBUkFCT0xPSURcIjtcbn0pKFBvaW50U2hhcGUgfHwgKFBvaW50U2hhcGUgPSB7fSkpO1xuZXhwb3J0IHZhciBUcmVlVHlwZTtcbihmdW5jdGlvbiAoVHJlZVR5cGUpIHtcbiAgICBUcmVlVHlwZVtUcmVlVHlwZVtcIk9DVFJFRVwiXSA9IDBdID0gXCJPQ1RSRUVcIjtcbiAgICBUcmVlVHlwZVtUcmVlVHlwZVtcIktEVFJFRVwiXSA9IDFdID0gXCJLRFRSRUVcIjtcbn0pKFRyZWVUeXBlIHx8IChUcmVlVHlwZSA9IHt9KSk7XG5leHBvcnQgdmFyIFBvaW50T3BhY2l0eVR5cGU7XG4oZnVuY3Rpb24gKFBvaW50T3BhY2l0eVR5cGUpIHtcbiAgICBQb2ludE9wYWNpdHlUeXBlW1BvaW50T3BhY2l0eVR5cGVbXCJGSVhFRFwiXSA9IDBdID0gXCJGSVhFRFwiO1xuICAgIFBvaW50T3BhY2l0eVR5cGVbUG9pbnRPcGFjaXR5VHlwZVtcIkFUVEVOVUFURURcIl0gPSAxXSA9IFwiQVRURU5VQVRFRFwiO1xufSkoUG9pbnRPcGFjaXR5VHlwZSB8fCAoUG9pbnRPcGFjaXR5VHlwZSA9IHt9KSk7XG5leHBvcnQgdmFyIFBvaW50Q29sb3JUeXBlO1xuKGZ1bmN0aW9uIChQb2ludENvbG9yVHlwZSkge1xuICAgIFBvaW50Q29sb3JUeXBlW1BvaW50Q29sb3JUeXBlW1wiUkdCXCJdID0gMF0gPSBcIlJHQlwiO1xuICAgIFBvaW50Q29sb3JUeXBlW1BvaW50Q29sb3JUeXBlW1wiQ09MT1JcIl0gPSAxXSA9IFwiQ09MT1JcIjtcbiAgICBQb2ludENvbG9yVHlwZVtQb2ludENvbG9yVHlwZVtcIkRFUFRIXCJdID0gMl0gPSBcIkRFUFRIXCI7XG4gICAgUG9pbnRDb2xvclR5cGVbUG9pbnRDb2xvclR5cGVbXCJIRUlHSFRcIl0gPSAzXSA9IFwiSEVJR0hUXCI7XG4gICAgUG9pbnRDb2xvclR5cGVbUG9pbnRDb2xvclR5cGVbXCJFTEVWQVRJT05cIl0gPSAzXSA9IFwiRUxFVkFUSU9OXCI7XG4gICAgUG9pbnRDb2xvclR5cGVbUG9pbnRDb2xvclR5cGVbXCJJTlRFTlNJVFlcIl0gPSA0XSA9IFwiSU5URU5TSVRZXCI7XG4gICAgUG9pbnRDb2xvclR5cGVbUG9pbnRDb2xvclR5cGVbXCJJTlRFTlNJVFlfR1JBRElFTlRcIl0gPSA1XSA9IFwiSU5URU5TSVRZX0dSQURJRU5UXCI7XG4gICAgUG9pbnRDb2xvclR5cGVbUG9pbnRDb2xvclR5cGVbXCJMT0RcIl0gPSA2XSA9IFwiTE9EXCI7XG4gICAgUG9pbnRDb2xvclR5cGVbUG9pbnRDb2xvclR5cGVbXCJMRVZFTF9PRl9ERVRBSUxcIl0gPSA2XSA9IFwiTEVWRUxfT0ZfREVUQUlMXCI7XG4gICAgUG9pbnRDb2xvclR5cGVbUG9pbnRDb2xvclR5cGVbXCJQT0lOVF9JTkRFWFwiXSA9IDddID0gXCJQT0lOVF9JTkRFWFwiO1xuICAgIFBvaW50Q29sb3JUeXBlW1BvaW50Q29sb3JUeXBlW1wiQ0xBU1NJRklDQVRJT05cIl0gPSA4XSA9IFwiQ0xBU1NJRklDQVRJT05cIjtcbiAgICBQb2ludENvbG9yVHlwZVtQb2ludENvbG9yVHlwZVtcIlJFVFVSTl9OVU1CRVJcIl0gPSA5XSA9IFwiUkVUVVJOX05VTUJFUlwiO1xuICAgIFBvaW50Q29sb3JUeXBlW1BvaW50Q29sb3JUeXBlW1wiU09VUkNFXCJdID0gMTBdID0gXCJTT1VSQ0VcIjtcbiAgICBQb2ludENvbG9yVHlwZVtQb2ludENvbG9yVHlwZVtcIk5PUk1BTFwiXSA9IDExXSA9IFwiTk9STUFMXCI7XG4gICAgUG9pbnRDb2xvclR5cGVbUG9pbnRDb2xvclR5cGVbXCJQSE9OR1wiXSA9IDEyXSA9IFwiUEhPTkdcIjtcbiAgICBQb2ludENvbG9yVHlwZVtQb2ludENvbG9yVHlwZVtcIlJHQl9IRUlHSFRcIl0gPSAxM10gPSBcIlJHQl9IRUlHSFRcIjtcbiAgICBQb2ludENvbG9yVHlwZVtQb2ludENvbG9yVHlwZVtcIkNPTVBPU0lURVwiXSA9IDUwXSA9IFwiQ09NUE9TSVRFXCI7XG59KShQb2ludENvbG9yVHlwZSB8fCAoUG9pbnRDb2xvclR5cGUgPSB7fSkpO1xuZXhwb3J0IHZhciBOb3JtYWxGaWx0ZXJpbmdNb2RlO1xuKGZ1bmN0aW9uIChOb3JtYWxGaWx0ZXJpbmdNb2RlKSB7XG4gICAgTm9ybWFsRmlsdGVyaW5nTW9kZVtOb3JtYWxGaWx0ZXJpbmdNb2RlW1wiQUJTT0xVVEVfTk9STUFMX0ZJTFRFUklOR19NT0RFXCJdID0gMV0gPSBcIkFCU09MVVRFX05PUk1BTF9GSUxURVJJTkdfTU9ERVwiO1xuICAgIE5vcm1hbEZpbHRlcmluZ01vZGVbTm9ybWFsRmlsdGVyaW5nTW9kZVtcIkxFU1NfRVFVQUxfTk9STUFMX0ZJTFRFUklOR19NT0RFXCJdID0gMl0gPSBcIkxFU1NfRVFVQUxfTk9STUFMX0ZJTFRFUklOR19NT0RFXCI7XG4gICAgTm9ybWFsRmlsdGVyaW5nTW9kZVtOb3JtYWxGaWx0ZXJpbmdNb2RlW1wiR1JFQVRFUl9OT1JNQUxfRklMVEVSSU5HX01PREVcIl0gPSAzXSA9IFwiR1JFQVRFUl9OT1JNQUxfRklMVEVSSU5HX01PREVcIjtcbn0pKE5vcm1hbEZpbHRlcmluZ01vZGUgfHwgKE5vcm1hbEZpbHRlcmluZ01vZGUgPSB7fSkpO1xuZXhwb3J0IHZhciBQb2ludENsb3VkTWl4aW5nTW9kZTtcbihmdW5jdGlvbiAoUG9pbnRDbG91ZE1peGluZ01vZGUpIHtcbiAgICBQb2ludENsb3VkTWl4aW5nTW9kZVtQb2ludENsb3VkTWl4aW5nTW9kZVtcIkNIRUNLQk9BUkRcIl0gPSAxXSA9IFwiQ0hFQ0tCT0FSRFwiO1xuICAgIFBvaW50Q2xvdWRNaXhpbmdNb2RlW1BvaW50Q2xvdWRNaXhpbmdNb2RlW1wiU1RSSVBFU1wiXSA9IDJdID0gXCJTVFJJUEVTXCI7XG59KShQb2ludENsb3VkTWl4aW5nTW9kZSB8fCAoUG9pbnRDbG91ZE1peGluZ01vZGUgPSB7fSkpO1xuIiwiaW1wb3J0IHsgQ29sb3IsIFZlY3RvcjQgfSBmcm9tICd0aHJlZSc7XG5leHBvcnQgY29uc3QgREVGQVVMVF9SR0JfQlJJR0hUTkVTUyA9IDA7XG5leHBvcnQgY29uc3QgREVGQVVMVF9SR0JfQ09OVFJBU1QgPSAwO1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfUkdCX0dBTU1BID0gMTtcbmV4cG9ydCBjb25zdCBERUZBVUxUX01BWF9QT0lOVF9TSVpFID0gNTA7XG5leHBvcnQgY29uc3QgREVGQVVMVF9NSU5fTk9ERV9QSVhFTF9TSVpFID0gNTA7XG5leHBvcnQgY29uc3QgREVGQVVMVF9NSU5fUE9JTlRfU0laRSA9IDI7XG5leHBvcnQgY29uc3QgREVGQVVMVF9QSUNLX1dJTkRPV19TSVpFID0gMTU7XG5leHBvcnQgY29uc3QgREVGQVVMVF9QT0lOVF9CVURHRVQgPSAxMDAwMDAwO1xuZXhwb3J0IGNvbnN0IE1BWF9MT0FEU19UT19HUFUgPSAyO1xuZXhwb3J0IGNvbnN0IE1BWF9OVU1fTk9ERVNfTE9BRElORyA9IDQ7XG5leHBvcnQgY29uc3QgUEVSU1BFQ1RJVkVfQ0FNRVJBID0gJ1BlcnNwZWN0aXZlQ2FtZXJhJztcbmV4cG9ydCBjb25zdCBDT0xPUl9CTEFDSyA9IG5ldyBDb2xvcigwLCAwLCAwKTtcbmV4cG9ydCBjb25zdCBERUZBVUxUX0hJR0hMSUdIVF9DT0xPUiA9IG5ldyBWZWN0b3I0KDEsIDAsIDAsIDEpO1xuIiwiZXhwb3J0IGZ1bmN0aW9uIGdldEluZGV4RnJvbU5hbWUobmFtZSkge1xuICAgIHJldHVybiBwYXJzZUludChuYW1lLmNoYXJBdChuYW1lLmxlbmd0aCAtIDEpLCAxMCk7XG59XG4vKipcbiAqIFdoZW4gcGFzc2VkIHRvIGBbXS5zb3J0YCwgc29ydHMgdGhlIGFycmF5IGJ5IGxldmVsIGFuZCBpbmRleDogciwgcjAsIHIzLCByNCwgcjAxLCByMDcsIHIzMCwgLi4uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBieUxldmVsQW5kSW5kZXgoYSwgYikge1xuICAgIGNvbnN0IG5hID0gYS5uYW1lO1xuICAgIGNvbnN0IG5iID0gYi5uYW1lO1xuICAgIGlmIChuYS5sZW5ndGggIT09IG5iLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbmEubGVuZ3RoIC0gbmIubGVuZ3RoO1xuICAgIH1cbiAgICBlbHNlIGlmIChuYSA8IG5iKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgZWxzZSBpZiAobmEgPiBuYikge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBoYW5kbGVGYWlsZWRSZXF1ZXN0KHJlc3BvbnNlKSB7XG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdSZXNwb25zZSBlcnJvcicpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzcG9uc2U7XG59XG5leHBvcnQgZnVuY3Rpb24gaGFuZGxlRW1wdHlCdWZmZXIoYnVmZmVyKSB7XG4gICAgaWYgKCFidWZmZXIgfHwgYnVmZmVyLmJ5dGVMZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ0VtcHR5IGJ1ZmZlcicpO1xuICAgIH1cbiAgICByZXR1cm4gYnVmZmVyO1xufVxuIiwiaW1wb3J0IHsgVmVjdG9yNCB9IGZyb20gJ3RocmVlJztcbmV4cG9ydCBjb25zdCBERUZBVUxUX0NMQVNTSUZJQ0FUSU9OID0ge1xuICAgIDA6IG5ldyBWZWN0b3I0KDAuNSwgMC41LCAwLjUsIDEuMCksXG4gICAgMTogbmV3IFZlY3RvcjQoMC41LCAwLjUsIDAuNSwgMS4wKSxcbiAgICAyOiBuZXcgVmVjdG9yNCgwLjYzLCAwLjMyLCAwLjE4LCAxLjApLFxuICAgIDM6IG5ldyBWZWN0b3I0KDAuMCwgMS4wLCAwLjAsIDEuMCksXG4gICAgNDogbmV3IFZlY3RvcjQoMC4wLCAwLjgsIDAuMCwgMS4wKSxcbiAgICA1OiBuZXcgVmVjdG9yNCgwLjAsIDAuNiwgMC4wLCAxLjApLFxuICAgIDY6IG5ldyBWZWN0b3I0KDEuMCwgMC42NiwgMC4wLCAxLjApLFxuICAgIDc6IG5ldyBWZWN0b3I0KDEuMCwgMCwgMS4wLCAxLjApLFxuICAgIDg6IG5ldyBWZWN0b3I0KDEuMCwgMCwgMC4wLCAxLjApLFxuICAgIDk6IG5ldyBWZWN0b3I0KDAuMCwgMC4wLCAxLjAsIDEuMCksXG4gICAgMTI6IG5ldyBWZWN0b3I0KDEuMCwgMS4wLCAwLjAsIDEuMCksXG4gICAgREVGQVVMVDogbmV3IFZlY3RvcjQoMC4zLCAwLjYsIDAuNiwgMC41KSxcbn07XG4iLCJpbXBvcnQgeyBDb2xvciB9IGZyb20gJ3RocmVlJztcbmV4cG9ydCBjb25zdCBHUkFZU0NBTEUgPSBbXG4gICAgWzAsIG5ldyBDb2xvcigwLCAwLCAwKV0sXG4gICAgWzEsIG5ldyBDb2xvcigxLCAxLCAxKV0sXG5dO1xuIiwiaW1wb3J0IHsgQ29sb3IgfSBmcm9tICd0aHJlZSc7XG5leHBvcnQgY29uc3QgSU5GRVJOTyA9IFtcbiAgICBbMC4wLCBuZXcgQ29sb3IoMC4wNzcsIDAuMDQyLCAwLjIwNildLFxuICAgIFswLjEsIG5ldyBDb2xvcigwLjIyNSwgMC4wMzYsIDAuMzg4KV0sXG4gICAgWzAuMiwgbmV3IENvbG9yKDAuMzczLCAwLjA3NCwgMC40MzIpXSxcbiAgICBbMC4zLCBuZXcgQ29sb3IoMC41MjIsIDAuMTI4LCAwLjQyKV0sXG4gICAgWzAuNCwgbmV3IENvbG9yKDAuNjY1LCAwLjE4MiwgMC4zNyldLFxuICAgIFswLjUsIG5ldyBDb2xvcigwLjc5NywgMC4yNTUsIDAuMjg3KV0sXG4gICAgWzAuNiwgbmV3IENvbG9yKDAuOTAyLCAwLjM2NCwgMC4xODQpXSxcbiAgICBbMC43LCBuZXcgQ29sb3IoMC45NjksIDAuNTE2LCAwLjA2MyldLFxuICAgIFswLjgsIG5ldyBDb2xvcigwLjk4OCwgMC42ODMsIDAuMDcyKV0sXG4gICAgWzAuOSwgbmV3IENvbG9yKDAuOTYxLCAwLjg1OSwgMC4yOTgpXSxcbiAgICBbMS4wLCBuZXcgQ29sb3IoMC45ODgsIDAuOTk4LCAwLjY0NSldLFxuXTtcbiIsImltcG9ydCB7IENvbG9yIH0gZnJvbSAndGhyZWUnO1xuZXhwb3J0IGNvbnN0IFBMQVNNQSA9IFtcbiAgICBbMC4wLCBuZXcgQ29sb3IoMC4yNDEsIDAuMDE1LCAwLjYxKV0sXG4gICAgWzAuMSwgbmV3IENvbG9yKDAuMzg3LCAwLjAwMSwgMC42NTQpXSxcbiAgICBbMC4yLCBuZXcgQ29sb3IoMC41MjQsIDAuMDI1LCAwLjY1MyldLFxuICAgIFswLjMsIG5ldyBDb2xvcigwLjY1MSwgMC4xMjUsIDAuNTk2KV0sXG4gICAgWzAuNCwgbmV3IENvbG9yKDAuNzUyLCAwLjIyNywgMC41MTMpXSxcbiAgICBbMC41LCBuZXcgQ29sb3IoMC44MzcsIDAuMzI5LCAwLjQzMSldLFxuICAgIFswLjYsIG5ldyBDb2xvcigwLjkwNywgMC40MzUsIDAuMzUzKV0sXG4gICAgWzAuNywgbmV3IENvbG9yKDAuOTYzLCAwLjU1NCwgMC4yNzIpXSxcbiAgICBbMC44LCBuZXcgQ29sb3IoMC45OTIsIDAuNjgxLCAwLjE5NSldLFxuICAgIFswLjksIG5ldyBDb2xvcigwLjk4NywgMC44MjIsIDAuMTQ0KV0sXG4gICAgWzEuMCwgbmV3IENvbG9yKDAuOTQsIDAuOTc1LCAwLjEzMSldLFxuXTtcbiIsImltcG9ydCB7IENvbG9yIH0gZnJvbSAndGhyZWUnO1xuZXhwb3J0IGNvbnN0IFJBSU5CT1cgPSBbXG4gICAgWzAsIG5ldyBDb2xvcigwLjI3OCwgMCwgMC43MTQpXSxcbiAgICBbMSAvIDYsIG5ldyBDb2xvcigwLCAwLCAxKV0sXG4gICAgWzIgLyA2LCBuZXcgQ29sb3IoMCwgMSwgMSldLFxuICAgIFszIC8gNiwgbmV3IENvbG9yKDAsIDEsIDApXSxcbiAgICBbNCAvIDYsIG5ldyBDb2xvcigxLCAxLCAwKV0sXG4gICAgWzUgLyA2LCBuZXcgQ29sb3IoMSwgMC42NCwgMCldLFxuICAgIFsxLCBuZXcgQ29sb3IoMSwgMCwgMCldLFxuXTtcbiIsImltcG9ydCB7IENvbG9yIH0gZnJvbSAndGhyZWUnO1xuLy8gRnJvbSBjaHJvbWEgc3BlY3RyYWwgaHR0cDovL2drYS5naXRodWIuaW8vY2hyb21hLmpzL1xuZXhwb3J0IGNvbnN0IFNQRUNUUkFMID0gW1xuICAgIFswLCBuZXcgQ29sb3IoMC4zNjg2LCAwLjMwOTgsIDAuNjM1MyldLFxuICAgIFswLjEsIG5ldyBDb2xvcigwLjE5NjEsIDAuNTMzMywgMC43NDEyKV0sXG4gICAgWzAuMiwgbmV3IENvbG9yKDAuNCwgMC43NjA4LCAwLjY0NzEpXSxcbiAgICBbMC4zLCBuZXcgQ29sb3IoMC42NzA2LCAwLjg2NjcsIDAuNjQzMSldLFxuICAgIFswLjQsIG5ldyBDb2xvcigwLjkwMiwgMC45NjA4LCAwLjU5NjEpXSxcbiAgICBbMC41LCBuZXcgQ29sb3IoMS4wLCAxLjAsIDAuNzQ5KV0sXG4gICAgWzAuNiwgbmV3IENvbG9yKDAuOTk2MSwgMC44Nzg0LCAwLjU0NTEpXSxcbiAgICBbMC43LCBuZXcgQ29sb3IoMC45OTIyLCAwLjY4MjQsIDAuMzgwNCldLFxuICAgIFswLjgsIG5ldyBDb2xvcigwLjk1NjksIDAuNDI3NSwgMC4yNjI3KV0sXG4gICAgWzAuOSwgbmV3IENvbG9yKDAuODM1MywgMC4yNDMxLCAwLjMwOTgpXSxcbiAgICBbMSwgbmV3IENvbG9yKDAuNjE5NiwgMC4wMDM5LCAwLjI1ODgpXSxcbl07XG4iLCJpbXBvcnQgeyBDb2xvciB9IGZyb20gJ3RocmVlJztcbmV4cG9ydCBjb25zdCBWSVJJRElTID0gW1xuICAgIFswLjAsIG5ldyBDb2xvcigwLjI2NywgMC4wMDUsIDAuMzI5KV0sXG4gICAgWzAuMSwgbmV3IENvbG9yKDAuMjgzLCAwLjE0MSwgMC40NTgpXSxcbiAgICBbMC4yLCBuZXcgQ29sb3IoMC4yNTQsIDAuMjY1LCAwLjUzKV0sXG4gICAgWzAuMywgbmV3IENvbG9yKDAuMjA3LCAwLjM3MiwgMC41NTMpXSxcbiAgICBbMC40LCBuZXcgQ29sb3IoMC4xNjQsIDAuNDcxLCAwLjU1OCldLFxuICAgIFswLjUsIG5ldyBDb2xvcigwLjEyOCwgMC41NjcsIDAuNTUxKV0sXG4gICAgWzAuNiwgbmV3IENvbG9yKDAuMTM1LCAwLjY1OSwgMC41MTgpXSxcbiAgICBbMC43LCBuZXcgQ29sb3IoMC4yNjcsIDAuNzQ5LCAwLjQ0MSldLFxuICAgIFswLjgsIG5ldyBDb2xvcigwLjQ3OCwgMC44MjEsIDAuMzE4KV0sXG4gICAgWzAuOSwgbmV3IENvbG9yKDAuNzQxLCAwLjg3MywgMC4xNSldLFxuICAgIFsxLjAsIG5ldyBDb2xvcigwLjk5MywgMC45MDYsIDAuMTQ0KV0sXG5dO1xuIiwiaW1wb3J0IHsgQ29sb3IgfSBmcm9tICd0aHJlZSc7XG5leHBvcnQgY29uc3QgWUVMTE9XX0dSRUVOID0gW1xuICAgIFswLCBuZXcgQ29sb3IoMC4xNjQ3LCAwLjI4MjQsIDAuMzQ1MSldLFxuICAgIFswLjEsIG5ldyBDb2xvcigwLjEzMzgsIDAuMzU1NSwgMC40MjI3KV0sXG4gICAgWzAuMiwgbmV3IENvbG9yKDAuMDYxLCAwLjQzMTksIDAuNDg2NCldLFxuICAgIFswLjMsIG5ldyBDb2xvcigwLjAsIDAuNTA5OSwgMC41MzE5KV0sXG4gICAgWzAuNCwgbmV3IENvbG9yKDAuMCwgMC41ODgxLCAwLjU1NjkpXSxcbiAgICBbMC41LCBuZXcgQ29sb3IoMC4xMzcsIDAuNjY1LCAwLjU2MTQpXSxcbiAgICBbMC42LCBuZXcgQ29sb3IoMC4yOTA2LCAwLjczOTUsIDAuNTQ3NyldLFxuICAgIFswLjcsIG5ldyBDb2xvcigwLjQ0NTMsIDAuODA5OSwgMC41MjAxKV0sXG4gICAgWzAuOCwgbmV3IENvbG9yKDAuNjEwMiwgMC44NzQ4LCAwLjQ4NSldLFxuICAgIFswLjksIG5ldyBDb2xvcigwLjc4ODMsIDAuOTMyMywgMC40NTE0KV0sXG4gICAgWzEsIG5ldyBDb2xvcigwLjk4MDQsIDAuOTgwNCwgMC40MzE0KV0sXG5dO1xuIiwiZXhwb3J0ICogZnJvbSAnLi9ncmF5c2NhbGUnO1xuZXhwb3J0ICogZnJvbSAnLi9pbmZlcm5vJztcbmV4cG9ydCAqIGZyb20gJy4vcGxhc21hJztcbmV4cG9ydCAqIGZyb20gJy4vcmFpbmJvdyc7XG5leHBvcnQgKiBmcm9tICcuL3NwZWN0cmFsJztcbmV4cG9ydCAqIGZyb20gJy4vdmlkcmlzJztcbmV4cG9ydCAqIGZyb20gJy4veWVsbG93LWdyZWVuJztcbiIsImltcG9ydCB7IENhbnZhc1RleHR1cmUsIERhdGFUZXh0dXJlLCBMaW5lYXJGaWx0ZXIsIE5lYXJlc3RGaWx0ZXIsIFJHQkFGb3JtYXQsIH0gZnJvbSAndGhyZWUnO1xuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlRGF0YVRleHR1cmUod2lkdGgsIGhlaWdodCwgY29sb3IpIHtcbiAgICBjb25zdCBzaXplID0gd2lkdGggKiBoZWlnaHQ7XG4gICAgY29uc3QgZGF0YSA9IG5ldyBVaW50OEFycmF5KDQgKiBzaXplKTtcbiAgICBjb25zdCByID0gTWF0aC5mbG9vcihjb2xvci5yICogMjU1KTtcbiAgICBjb25zdCBnID0gTWF0aC5mbG9vcihjb2xvci5nICogMjU1KTtcbiAgICBjb25zdCBiID0gTWF0aC5mbG9vcihjb2xvci5iICogMjU1KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICBkYXRhW2kgKiAzXSA9IHI7XG4gICAgICAgIGRhdGFbaSAqIDMgKyAxXSA9IGc7XG4gICAgICAgIGRhdGFbaSAqIDMgKyAyXSA9IGI7XG4gICAgfVxuICAgIGNvbnN0IHRleHR1cmUgPSBuZXcgRGF0YVRleHR1cmUoZGF0YSwgd2lkdGgsIGhlaWdodCwgUkdCQUZvcm1hdCk7XG4gICAgdGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgdGV4dHVyZS5tYWdGaWx0ZXIgPSBOZWFyZXN0RmlsdGVyO1xuICAgIHJldHVybiB0ZXh0dXJlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlR3JhZGllbnRUZXh0dXJlKGdyYWRpZW50KSB7XG4gICAgY29uc3Qgc2l6ZSA9IDY0O1xuICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIGNhbnZhcy53aWR0aCA9IHNpemU7XG4gICAgY2FudmFzLmhlaWdodCA9IHNpemU7XG4gICAgY29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGNvbnRleHQucmVjdCgwLCAwLCBzaXplLCBzaXplKTtcbiAgICBjb25zdCBjdHhHcmFkaWVudCA9IGNvbnRleHQuY3JlYXRlTGluZWFyR3JhZGllbnQoMCwgMCwgc2l6ZSwgc2l6ZSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBncmFkaWVudC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBzdGVwID0gZ3JhZGllbnRbaV07XG4gICAgICAgIGN0eEdyYWRpZW50LmFkZENvbG9yU3RvcChzdGVwWzBdLCBgIyR7c3RlcFsxXS5nZXRIZXhTdHJpbmcoKX1gKTtcbiAgICB9XG4gICAgY29udGV4dC5maWxsU3R5bGUgPSBjdHhHcmFkaWVudDtcbiAgICBjb250ZXh0LmZpbGwoKTtcbiAgICBjb25zdCB0ZXh0dXJlID0gbmV3IENhbnZhc1RleHR1cmUoY2FudmFzKTtcbiAgICB0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICB0ZXh0dXJlLm1pbkZpbHRlciA9IExpbmVhckZpbHRlcjtcbiAgICAvLyB0ZXh0dXJlSW1hZ2UgPSB0ZXh0dXJlLmltYWdlO1xuICAgIHJldHVybiB0ZXh0dXJlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlQ2xhc3NpZmljYXRpb25UZXh0dXJlKGNsYXNzaWZpY2F0aW9uKSB7XG4gICAgY29uc3Qgd2lkdGggPSAyNTY7XG4gICAgY29uc3QgaGVpZ2h0ID0gMjU2O1xuICAgIGNvbnN0IHNpemUgPSB3aWR0aCAqIGhlaWdodDtcbiAgICBjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoNCAqIHNpemUpO1xuICAgIGZvciAobGV0IHggPSAwOyB4IDwgd2lkdGg7IHgrKykge1xuICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XG4gICAgICAgICAgICBjb25zdCBpID0geCArIHdpZHRoICogeTtcbiAgICAgICAgICAgIGxldCBjb2xvcjtcbiAgICAgICAgICAgIGlmIChjbGFzc2lmaWNhdGlvblt4XSkge1xuICAgICAgICAgICAgICAgIGNvbG9yID0gY2xhc3NpZmljYXRpb25beF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjbGFzc2lmaWNhdGlvblt4ICUgMzJdKSB7XG4gICAgICAgICAgICAgICAgY29sb3IgPSBjbGFzc2lmaWNhdGlvblt4ICUgMzJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29sb3IgPSBjbGFzc2lmaWNhdGlvbi5ERUZBVUxUO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGF0YVs0ICogaSArIDBdID0gMjU1ICogY29sb3IueDtcbiAgICAgICAgICAgIGRhdGFbNCAqIGkgKyAxXSA9IDI1NSAqIGNvbG9yLnk7XG4gICAgICAgICAgICBkYXRhWzQgKiBpICsgMl0gPSAyNTUgKiBjb2xvci56O1xuICAgICAgICAgICAgZGF0YVs0ICogaSArIDNdID0gMjU1ICogY29sb3IudztcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB0ZXh0dXJlID0gbmV3IERhdGFUZXh0dXJlKGRhdGEsIHdpZHRoLCBoZWlnaHQsIFJHQkFGb3JtYXQpO1xuICAgIHRleHR1cmUubWFnRmlsdGVyID0gTmVhcmVzdEZpbHRlcjtcbiAgICB0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICByZXR1cm4gdGV4dHVyZTtcbn1cbiIsInZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbmltcG9ydCB7IEFkZGl0aXZlQmxlbmRpbmcsIENvbG9yLCBMZXNzRXF1YWxEZXB0aCwgTmVhcmVzdEZpbHRlciwgTm9CbGVuZGluZywgUmF3U2hhZGVyTWF0ZXJpYWwsIFRleHR1cmUsIFZlY3RvcjIsIFZlY3RvcjMsIH0gZnJvbSAndGhyZWUnO1xuaW1wb3J0IHsgREVGQVVMVF9ISUdITElHSFRfQ09MT1IsIERFRkFVTFRfTUFYX1BPSU5UX1NJWkUsIERFRkFVTFRfTUlOX1BPSU5UX1NJWkUsIERFRkFVTFRfUkdCX0JSSUdIVE5FU1MsIERFRkFVTFRfUkdCX0NPTlRSQVNULCBERUZBVUxUX1JHQl9HQU1NQSwgUEVSU1BFQ1RJVkVfQ0FNRVJBLCB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBieUxldmVsQW5kSW5kZXggfSBmcm9tICcuLi91dGlscy91dGlscyc7XG5pbXBvcnQgeyBERUZBVUxUX0NMQVNTSUZJQ0FUSU9OIH0gZnJvbSAnLi9jbGFzc2lmaWNhdGlvbic7XG5pbXBvcnQgeyBDbGlwTW9kZSB9IGZyb20gJy4vY2xpcHBpbmcnO1xuaW1wb3J0IHsgTm9ybWFsRmlsdGVyaW5nTW9kZSwgUG9pbnRDbG91ZE1peGluZ01vZGUsIFBvaW50Q29sb3JUeXBlLCBQb2ludE9wYWNpdHlUeXBlLCBQb2ludFNoYXBlLCBQb2ludFNpemVUeXBlLCBUcmVlVHlwZSwgfSBmcm9tICcuL2VudW1zJztcbmltcG9ydCB7IFNQRUNUUkFMIH0gZnJvbSAnLi9ncmFkaWVudHMnO1xuaW1wb3J0IHsgZ2VuZXJhdGVDbGFzc2lmaWNhdGlvblRleHR1cmUsIGdlbmVyYXRlRGF0YVRleHR1cmUsIGdlbmVyYXRlR3JhZGllbnRUZXh0dXJlLCB9IGZyb20gJy4vdGV4dHVyZS1nZW5lcmF0aW9uJztcbmNvbnN0IFRSRUVfVFlQRV9ERUZTID0ge1xuICAgIFtUcmVlVHlwZS5PQ1RSRUVdOiAndHJlZV90eXBlX29jdHJlZScsXG4gICAgW1RyZWVUeXBlLktEVFJFRV06ICd0cmVlX3R5cGVfa2R0cmVlJyxcbn07XG5jb25zdCBTSVpFX1RZUEVfREVGUyA9IHtcbiAgICBbUG9pbnRTaXplVHlwZS5GSVhFRF06ICdmaXhlZF9wb2ludF9zaXplJyxcbiAgICBbUG9pbnRTaXplVHlwZS5BVFRFTlVBVEVEXTogJ2F0dGVudWF0ZWRfcG9pbnRfc2l6ZScsXG4gICAgW1BvaW50U2l6ZVR5cGUuQURBUFRJVkVdOiAnYWRhcHRpdmVfcG9pbnRfc2l6ZScsXG59O1xuY29uc3QgT1BBQ0lUWV9ERUZTID0ge1xuICAgIFtQb2ludE9wYWNpdHlUeXBlLkFUVEVOVUFURURdOiAnYXR0ZW51YXRlZF9vcGFjaXR5JyxcbiAgICBbUG9pbnRPcGFjaXR5VHlwZS5GSVhFRF06ICdmaXhlZF9vcGFjaXR5Jyxcbn07XG5jb25zdCBTSEFQRV9ERUZTID0ge1xuICAgIFtQb2ludFNoYXBlLlNRVUFSRV06ICdzcXVhcmVfcG9pbnRfc2hhcGUnLFxuICAgIFtQb2ludFNoYXBlLkNJUkNMRV06ICdjaXJjbGVfcG9pbnRfc2hhcGUnLFxuICAgIFtQb2ludFNoYXBlLlBBUkFCT0xPSURdOiAncGFyYWJvbG9pZF9wb2ludF9zaGFwZScsXG59O1xuY29uc3QgQ09MT1JfREVGUyA9IHtcbiAgICBbUG9pbnRDb2xvclR5cGUuUkdCXTogJ2NvbG9yX3R5cGVfcmdiJyxcbiAgICBbUG9pbnRDb2xvclR5cGUuQ09MT1JdOiAnY29sb3JfdHlwZV9jb2xvcicsXG4gICAgW1BvaW50Q29sb3JUeXBlLkRFUFRIXTogJ2NvbG9yX3R5cGVfZGVwdGgnLFxuICAgIFtQb2ludENvbG9yVHlwZS5IRUlHSFRdOiAnY29sb3JfdHlwZV9oZWlnaHQnLFxuICAgIFtQb2ludENvbG9yVHlwZS5JTlRFTlNJVFldOiAnY29sb3JfdHlwZV9pbnRlbnNpdHknLFxuICAgIFtQb2ludENvbG9yVHlwZS5JTlRFTlNJVFlfR1JBRElFTlRdOiAnY29sb3JfdHlwZV9pbnRlbnNpdHlfZ3JhZGllbnQnLFxuICAgIFtQb2ludENvbG9yVHlwZS5MT0RdOiAnY29sb3JfdHlwZV9sb2QnLFxuICAgIFtQb2ludENvbG9yVHlwZS5QT0lOVF9JTkRFWF06ICdjb2xvcl90eXBlX3BvaW50X2luZGV4JyxcbiAgICBbUG9pbnRDb2xvclR5cGUuQ0xBU1NJRklDQVRJT05dOiAnY29sb3JfdHlwZV9jbGFzc2lmaWNhdGlvbicsXG4gICAgW1BvaW50Q29sb3JUeXBlLlJFVFVSTl9OVU1CRVJdOiAnY29sb3JfdHlwZV9yZXR1cm5fbnVtYmVyJyxcbiAgICBbUG9pbnRDb2xvclR5cGUuU09VUkNFXTogJ2NvbG9yX3R5cGVfc291cmNlJyxcbiAgICBbUG9pbnRDb2xvclR5cGUuTk9STUFMXTogJ2NvbG9yX3R5cGVfbm9ybWFsJyxcbiAgICBbUG9pbnRDb2xvclR5cGUuUEhPTkddOiAnY29sb3JfdHlwZV9waG9uZycsXG4gICAgW1BvaW50Q29sb3JUeXBlLlJHQl9IRUlHSFRdOiAnY29sb3JfdHlwZV9yZ2JfaGVpZ2h0JyxcbiAgICBbUG9pbnRDb2xvclR5cGUuQ09NUE9TSVRFXTogJ2NvbG9yX3R5cGVfY29tcG9zaXRlJyxcbn07XG5jb25zdCBDTElQX01PREVfREVGUyA9IHtcbiAgICBbQ2xpcE1vZGUuRElTQUJMRURdOiAnY2xpcF9kaXNhYmxlZCcsXG4gICAgW0NsaXBNb2RlLkNMSVBfT1VUU0lERV06ICdjbGlwX291dHNpZGUnLFxuICAgIFtDbGlwTW9kZS5ISUdITElHSFRfSU5TSURFXTogJ2NsaXBfaGlnaGxpZ2h0X2luc2lkZScsXG4gICAgW0NsaXBNb2RlLkNMSVBfSE9SSVpPTlRBTExZXTogJ2NsaXBfaG9yaXpvbnRhbGx5JyxcbiAgICBbQ2xpcE1vZGUuQ0xJUF9WRVJUSUNBTExZXTogJ2NsaXBfdmVydGljYWxseScsXG59O1xuZXhwb3J0IGNsYXNzIFBvaW50Q2xvdWRNYXRlcmlhbCBleHRlbmRzIFJhd1NoYWRlck1hdGVyaWFsIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzID0ge30pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVzZSB0aGUgZHJhd2luZyBidWZmZXIgc2l6ZSBpbnN0ZWFkIG9mIHRoZSBkb20gY2xpZW50IHdpZHRoIGFuZCBoZWlnaHQgd2hlbiBwYXNzaW5nIHRoZSBzY3JlZW4gaGVpZ2h0IGFuZCBzY3JlZW4gd2lkdGggdW5pZm9ybXMgdG8gdGhlXG4gICAgICAgICAqIHNoYWRlci4gVGhpcyBpcyB1c2VmdWwgaWYgeW91IGhhdmUgb2Zmc2NyZWVuIGNhbnZhc2VzICh3aGljaCBpbiBzb21lIGJyb3dzZXJzIHJldHVybiAwIGFzIGNsaWVudCB3aWR0aCBhbmQgY2xpZW50IGhlaWdodCkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnVzZURyYXdpbmdCdWZmZXJTaXplID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGlnaHRzID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZm9nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY29sb3JSZ2JhID0gZmFsc2U7XG4gICAgICAgIHRoaXMubnVtQ2xpcEJveGVzID0gMDtcbiAgICAgICAgdGhpcy5jbGlwQm94ZXMgPSBbXTtcbiAgICAgICAgdGhpcy52aXNpYmxlTm9kZVRleHR1cmVPZmZzZXRzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9ncmFkaWVudCA9IFNQRUNUUkFMO1xuICAgICAgICB0aGlzLmdyYWRpZW50VGV4dHVyZSA9IGdlbmVyYXRlR3JhZGllbnRUZXh0dXJlKHRoaXMuX2dyYWRpZW50KTtcbiAgICAgICAgdGhpcy5fY2xhc3NpZmljYXRpb24gPSBERUZBVUxUX0NMQVNTSUZJQ0FUSU9OO1xuICAgICAgICB0aGlzLmNsYXNzaWZpY2F0aW9uVGV4dHVyZSA9IGdlbmVyYXRlQ2xhc3NpZmljYXRpb25UZXh0dXJlKHRoaXMuX2NsYXNzaWZpY2F0aW9uKTtcbiAgICAgICAgdGhpcy51bmlmb3JtcyA9IHtcbiAgICAgICAgICAgIGJiU2l6ZTogbWFrZVVuaWZvcm0oJ2Z2JywgWzAsIDAsIDBdKSxcbiAgICAgICAgICAgIGJsZW5kRGVwdGhTdXBwbGVtZW50OiBtYWtlVW5pZm9ybSgnZicsIDAuMCksXG4gICAgICAgICAgICBibGVuZEhhcmRuZXNzOiBtYWtlVW5pZm9ybSgnZicsIDIuMCksXG4gICAgICAgICAgICBjbGFzc2lmaWNhdGlvbkxVVDogbWFrZVVuaWZvcm0oJ3QnLCB0aGlzLmNsYXNzaWZpY2F0aW9uVGV4dHVyZSB8fCBuZXcgVGV4dHVyZSgpKSxcbiAgICAgICAgICAgIGNsaXBCb3hDb3VudDogbWFrZVVuaWZvcm0oJ2YnLCAwKSxcbiAgICAgICAgICAgIGNsaXBCb3hlczogbWFrZVVuaWZvcm0oJ01hdHJpeDRmdicsIFtdKSxcbiAgICAgICAgICAgIGNsaXBFeHRlbnQ6IG1ha2VVbmlmb3JtKCdmdicsIFswLjAsIDAuMCwgMS4wLCAxLjBdKSxcbiAgICAgICAgICAgIGRlcHRoTWFwOiBtYWtlVW5pZm9ybSgndCcsIG51bGwpLFxuICAgICAgICAgICAgZGlmZnVzZTogbWFrZVVuaWZvcm0oJ2Z2JywgWzEsIDEsIDFdKSxcbiAgICAgICAgICAgIGZvdjogbWFrZVVuaWZvcm0oJ2YnLCAxLjApLFxuICAgICAgICAgICAgZ3JhZGllbnQ6IG1ha2VVbmlmb3JtKCd0JywgdGhpcy5ncmFkaWVudFRleHR1cmUgfHwgbmV3IFRleHR1cmUoKSksXG4gICAgICAgICAgICBoZWlnaHRNYXg6IG1ha2VVbmlmb3JtKCdmJywgMS4wKSxcbiAgICAgICAgICAgIGhlaWdodE1pbjogbWFrZVVuaWZvcm0oJ2YnLCAwLjApLFxuICAgICAgICAgICAgaW50ZW5zaXR5QnJpZ2h0bmVzczogbWFrZVVuaWZvcm0oJ2YnLCAwKSxcbiAgICAgICAgICAgIGludGVuc2l0eUNvbnRyYXN0OiBtYWtlVW5pZm9ybSgnZicsIDApLFxuICAgICAgICAgICAgaW50ZW5zaXR5R2FtbWE6IG1ha2VVbmlmb3JtKCdmJywgMSksXG4gICAgICAgICAgICBpbnRlbnNpdHlSYW5nZTogbWFrZVVuaWZvcm0oJ2Z2JywgWzAsIDY1MDAwXSksXG4gICAgICAgICAgICBpc0xlYWZOb2RlOiBtYWtlVW5pZm9ybSgnYicsIDApLFxuICAgICAgICAgICAgbGV2ZWw6IG1ha2VVbmlmb3JtKCdmJywgMC4wKSxcbiAgICAgICAgICAgIG1heFNpemU6IG1ha2VVbmlmb3JtKCdmJywgREVGQVVMVF9NQVhfUE9JTlRfU0laRSksXG4gICAgICAgICAgICBtaW5TaXplOiBtYWtlVW5pZm9ybSgnZicsIERFRkFVTFRfTUlOX1BPSU5UX1NJWkUpLFxuICAgICAgICAgICAgb2N0cmVlU2l6ZTogbWFrZVVuaWZvcm0oJ2YnLCAwKSxcbiAgICAgICAgICAgIG9wYWNpdHk6IG1ha2VVbmlmb3JtKCdmJywgMS4wKSxcbiAgICAgICAgICAgIHBjSW5kZXg6IG1ha2VVbmlmb3JtKCdmJywgMCksXG4gICAgICAgICAgICByZ2JCcmlnaHRuZXNzOiBtYWtlVW5pZm9ybSgnZicsIERFRkFVTFRfUkdCX0JSSUdIVE5FU1MpLFxuICAgICAgICAgICAgcmdiQ29udHJhc3Q6IG1ha2VVbmlmb3JtKCdmJywgREVGQVVMVF9SR0JfQ09OVFJBU1QpLFxuICAgICAgICAgICAgcmdiR2FtbWE6IG1ha2VVbmlmb3JtKCdmJywgREVGQVVMVF9SR0JfR0FNTUEpLFxuICAgICAgICAgICAgc2NyZWVuSGVpZ2h0OiBtYWtlVW5pZm9ybSgnZicsIDEuMCksXG4gICAgICAgICAgICBzY3JlZW5XaWR0aDogbWFrZVVuaWZvcm0oJ2YnLCAxLjApLFxuICAgICAgICAgICAgc2l6ZTogbWFrZVVuaWZvcm0oJ2YnLCAxKSxcbiAgICAgICAgICAgIHNwYWNpbmc6IG1ha2VVbmlmb3JtKCdmJywgMS4wKSxcbiAgICAgICAgICAgIHRvTW9kZWw6IG1ha2VVbmlmb3JtKCdNYXRyaXg0ZicsIFtdKSxcbiAgICAgICAgICAgIHRyYW5zaXRpb246IG1ha2VVbmlmb3JtKCdmJywgMC41KSxcbiAgICAgICAgICAgIHVDb2xvcjogbWFrZVVuaWZvcm0oJ2MnLCBuZXcgQ29sb3IoMHhmZmZmZmYpKSxcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIHZpc2libGVOb2RlczogbWFrZVVuaWZvcm0oJ3QnLCB0aGlzLnZpc2libGVOb2Rlc1RleHR1cmUgfHwgbmV3IFRleHR1cmUoKSksXG4gICAgICAgICAgICB2blN0YXJ0OiBtYWtlVW5pZm9ybSgnZicsIDAuMCksXG4gICAgICAgICAgICB3Q2xhc3NpZmljYXRpb246IG1ha2VVbmlmb3JtKCdmJywgMCksXG4gICAgICAgICAgICB3RWxldmF0aW9uOiBtYWtlVW5pZm9ybSgnZicsIDApLFxuICAgICAgICAgICAgd0ludGVuc2l0eTogbWFrZVVuaWZvcm0oJ2YnLCAwKSxcbiAgICAgICAgICAgIHdSZXR1cm5OdW1iZXI6IG1ha2VVbmlmb3JtKCdmJywgMCksXG4gICAgICAgICAgICB3UkdCOiBtYWtlVW5pZm9ybSgnZicsIDEpLFxuICAgICAgICAgICAgd1NvdXJjZUlEOiBtYWtlVW5pZm9ybSgnZicsIDApLFxuICAgICAgICAgICAgb3BhY2l0eUF0dGVudWF0aW9uOiBtYWtlVW5pZm9ybSgnZicsIDEpLFxuICAgICAgICAgICAgZmlsdGVyQnlOb3JtYWxUaHJlc2hvbGQ6IG1ha2VVbmlmb3JtKCdmJywgMCksXG4gICAgICAgICAgICBoaWdobGlnaHRlZFBvaW50Q29vcmRpbmF0ZTogbWFrZVVuaWZvcm0oJ2Z2JywgbmV3IFZlY3RvcjMoKSksXG4gICAgICAgICAgICBoaWdobGlnaHRlZFBvaW50Q29sb3I6IG1ha2VVbmlmb3JtKCdmdicsIERFRkFVTFRfSElHSExJR0hUX0NPTE9SLmNsb25lKCkpLFxuICAgICAgICAgICAgZW5hYmxlUG9pbnRIaWdobGlnaHRpbmc6IG1ha2VVbmlmb3JtKCdiJywgdHJ1ZSksXG4gICAgICAgICAgICBoaWdobGlnaHRlZFBvaW50U2NhbGU6IG1ha2VVbmlmb3JtKCdmJywgMi4wKSxcbiAgICAgICAgICAgIGJhY2tncm91bmRNYXA6IG1ha2VVbmlmb3JtKCd0JywgbnVsbCksXG4gICAgICAgICAgICBub3JtYWxGaWx0ZXJpbmdNb2RlOiBtYWtlVW5pZm9ybSgnaScsIE5vcm1hbEZpbHRlcmluZ01vZGUuQUJTT0xVVEVfTk9STUFMX0ZJTFRFUklOR19NT0RFKSxcbiAgICAgICAgICAgIHBvaW50Q2xvdWRJRDogbWFrZVVuaWZvcm0oJ2YnLCAyKSxcbiAgICAgICAgICAgIHBvaW50Q2xvdWRNaXhpbmdNb2RlOiBtYWtlVW5pZm9ybSgnaScsIFBvaW50Q2xvdWRNaXhpbmdNb2RlLkNIRUNLQk9BUkQpLFxuICAgICAgICAgICAgc3RyaXBlRGlzdGFuY2VYOiBtYWtlVW5pZm9ybSgnZicsIDUpLFxuICAgICAgICAgICAgc3RyaXBlRGlzdGFuY2VZOiBtYWtlVW5pZm9ybSgnZicsIDUpLFxuICAgICAgICAgICAgc3RyaXBlRGl2aXNvclg6IG1ha2VVbmlmb3JtKCdmJywgMiksXG4gICAgICAgICAgICBzdHJpcGVEaXZpc29yWTogbWFrZVVuaWZvcm0oJ2YnLCAyKSxcbiAgICAgICAgICAgIHBvaW50Q2xvdWRNaXhBbmdsZTogbWFrZVVuaWZvcm0oJ2YnLCAzMSksXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudXNlQ2xpcEJveCA9IGZhbHNlO1xuICAgICAgICB0aGlzLndlaWdodGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMucG9pbnRDb2xvclR5cGUgPSBQb2ludENvbG9yVHlwZS5SR0I7XG4gICAgICAgIHRoaXMucG9pbnRTaXplVHlwZSA9IFBvaW50U2l6ZVR5cGUuQURBUFRJVkU7XG4gICAgICAgIHRoaXMuY2xpcE1vZGUgPSBDbGlwTW9kZS5ESVNBQkxFRDtcbiAgICAgICAgdGhpcy51c2VFREwgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zaGFwZSA9IFBvaW50U2hhcGUuU1FVQVJFO1xuICAgICAgICB0aGlzLnRyZWVUeXBlID0gVHJlZVR5cGUuT0NUUkVFO1xuICAgICAgICB0aGlzLnBvaW50T3BhY2l0eVR5cGUgPSBQb2ludE9wYWNpdHlUeXBlLkZJWEVEO1xuICAgICAgICB0aGlzLnVzZUZpbHRlckJ5Tm9ybWFsID0gZmFsc2U7XG4gICAgICAgIHRoaXMudXNlVGV4dHVyZUJsZW5kaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMudXNlUG9pbnRDbG91ZE1peGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmhpZ2hsaWdodFBvaW50ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlcyA9IHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiB7IHR5cGU6ICdmdicsIHZhbHVlOiBbXSB9LFxuICAgICAgICAgICAgY29sb3I6IHsgdHlwZTogJ2Z2JywgdmFsdWU6IFtdIH0sXG4gICAgICAgICAgICBub3JtYWw6IHsgdHlwZTogJ2Z2JywgdmFsdWU6IFtdIH0sXG4gICAgICAgICAgICBpbnRlbnNpdHk6IHsgdHlwZTogJ2YnLCB2YWx1ZTogW10gfSxcbiAgICAgICAgICAgIGNsYXNzaWZpY2F0aW9uOiB7IHR5cGU6ICdmJywgdmFsdWU6IFtdIH0sXG4gICAgICAgICAgICByZXR1cm5OdW1iZXI6IHsgdHlwZTogJ2YnLCB2YWx1ZTogW10gfSxcbiAgICAgICAgICAgIG51bWJlck9mUmV0dXJuczogeyB0eXBlOiAnZicsIHZhbHVlOiBbXSB9LFxuICAgICAgICAgICAgcG9pbnRTb3VyY2VJRDogeyB0eXBlOiAnZicsIHZhbHVlOiBbXSB9LFxuICAgICAgICAgICAgaW5kaWNlczogeyB0eXBlOiAnZnYnLCB2YWx1ZTogW10gfSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdGV4ID0gKHRoaXMudmlzaWJsZU5vZGVzVGV4dHVyZSA9IGdlbmVyYXRlRGF0YVRleHR1cmUoMjA0OCwgMSwgbmV3IENvbG9yKDB4ZmZmZmZmKSkpO1xuICAgICAgICB0ZXgubWluRmlsdGVyID0gTmVhcmVzdEZpbHRlcjtcbiAgICAgICAgdGV4Lm1hZ0ZpbHRlciA9IE5lYXJlc3RGaWx0ZXI7XG4gICAgICAgIHRoaXMuc2V0VW5pZm9ybSgndmlzaWJsZU5vZGVzJywgdGV4KTtcbiAgICAgICAgdGhpcy50cmVlVHlwZSA9IGdldFZhbGlkKHBhcmFtZXRlcnMudHJlZVR5cGUsIFRyZWVUeXBlLk9DVFJFRSk7XG4gICAgICAgIHRoaXMuc2l6ZSA9IGdldFZhbGlkKHBhcmFtZXRlcnMuc2l6ZSwgMS4wKTtcbiAgICAgICAgdGhpcy5taW5TaXplID0gZ2V0VmFsaWQocGFyYW1ldGVycy5taW5TaXplLCAyLjApO1xuICAgICAgICB0aGlzLm1heFNpemUgPSBnZXRWYWxpZChwYXJhbWV0ZXJzLm1heFNpemUsIDUwLjApO1xuICAgICAgICB0aGlzLmNvbG9yUmdiYSA9IEJvb2xlYW4ocGFyYW1ldGVycy5jb2xvclJnYmEpO1xuICAgICAgICB0aGlzLmNsYXNzaWZpY2F0aW9uID0gREVGQVVMVF9DTEFTU0lGSUNBVElPTjtcbiAgICAgICAgdGhpcy5kZWZhdWx0QXR0cmlidXRlVmFsdWVzLm5vcm1hbCA9IFswLCAwLCAwXTtcbiAgICAgICAgdGhpcy5kZWZhdWx0QXR0cmlidXRlVmFsdWVzLmNsYXNzaWZpY2F0aW9uID0gWzAsIDAsIDBdO1xuICAgICAgICB0aGlzLmRlZmF1bHRBdHRyaWJ1dGVWYWx1ZXMuaW5kaWNlcyA9IFswLCAwLCAwLCAwXTtcbiAgICAgICAgdGhpcy52ZXJ0ZXhDb2xvcnMgPSB0cnVlO1xuICAgICAgICB0aGlzLnVwZGF0ZVNoYWRlclNvdXJjZSgpO1xuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICBzdXBlci5kaXNwb3NlKCk7XG4gICAgICAgIGlmICh0aGlzLmdyYWRpZW50VGV4dHVyZSkge1xuICAgICAgICAgICAgdGhpcy5ncmFkaWVudFRleHR1cmUuZGlzcG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5ncmFkaWVudFRleHR1cmUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudmlzaWJsZU5vZGVzVGV4dHVyZSkge1xuICAgICAgICAgICAgdGhpcy52aXNpYmxlTm9kZXNUZXh0dXJlLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHRoaXMudmlzaWJsZU5vZGVzVGV4dHVyZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsZWFyVmlzaWJsZU5vZGVUZXh0dXJlT2Zmc2V0cygpO1xuICAgICAgICBpZiAodGhpcy5jbGFzc2lmaWNhdGlvblRleHR1cmUpIHtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NpZmljYXRpb25UZXh0dXJlLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NpZmljYXRpb25UZXh0dXJlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRlcHRoTWFwKSB7XG4gICAgICAgICAgICB0aGlzLmRlcHRoTWFwLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHRoaXMuZGVwdGhNYXAgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYmFja2dyb3VuZE1hcCkge1xuICAgICAgICAgICAgdGhpcy5iYWNrZ3JvdW5kTWFwLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHRoaXMuYmFja2dyb3VuZE1hcCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbGVhclZpc2libGVOb2RlVGV4dHVyZU9mZnNldHMoKSB7XG4gICAgICAgIHRoaXMudmlzaWJsZU5vZGVUZXh0dXJlT2Zmc2V0cy5jbGVhcigpO1xuICAgIH1cbiAgICB1cGRhdGVTaGFkZXJTb3VyY2UoKSB7XG4gICAgICAgIHRoaXMudmVydGV4U2hhZGVyID0gdGhpcy5hcHBseURlZmluZXMocmVxdWlyZSgnLi9zaGFkZXJzL3BvaW50Y2xvdWQudmVydCcpLmRlZmF1bHQpO1xuICAgICAgICB0aGlzLmZyYWdtZW50U2hhZGVyID0gdGhpcy5hcHBseURlZmluZXMocmVxdWlyZSgnLi9zaGFkZXJzL3BvaW50Y2xvdWQuZnJhZycpLmRlZmF1bHQpO1xuICAgICAgICBpZiAodGhpcy5vcGFjaXR5ID09PSAxLjApIHtcbiAgICAgICAgICAgIHRoaXMuYmxlbmRpbmcgPSBOb0JsZW5kaW5nO1xuICAgICAgICAgICAgdGhpcy50cmFuc3BhcmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5kZXB0aFRlc3QgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5kZXB0aFdyaXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZGVwdGhGdW5jID0gTGVzc0VxdWFsRGVwdGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5vcGFjaXR5IDwgMS4wICYmICF0aGlzLnVzZUVETCkge1xuICAgICAgICAgICAgdGhpcy5ibGVuZGluZyA9IEFkZGl0aXZlQmxlbmRpbmc7XG4gICAgICAgICAgICB0aGlzLnRyYW5zcGFyZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZGVwdGhUZXN0ID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmRlcHRoV3JpdGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLndlaWdodGVkKSB7XG4gICAgICAgICAgICB0aGlzLmJsZW5kaW5nID0gQWRkaXRpdmVCbGVuZGluZztcbiAgICAgICAgICAgIHRoaXMudHJhbnNwYXJlbnQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5kZXB0aFRlc3QgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5kZXB0aFdyaXRlID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmRlcHRoRnVuYyA9IExlc3NFcXVhbERlcHRoO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIH1cbiAgICBhcHBseURlZmluZXMoc2hhZGVyU3JjKSB7XG4gICAgICAgIGNvbnN0IHBhcnRzID0gW107XG4gICAgICAgIGZ1bmN0aW9uIGRlZmluZSh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcGFydHMucHVzaChgI2RlZmluZSAke3ZhbHVlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRlZmluZShUUkVFX1RZUEVfREVGU1t0aGlzLnRyZWVUeXBlXSk7XG4gICAgICAgIGRlZmluZShTSVpFX1RZUEVfREVGU1t0aGlzLnBvaW50U2l6ZVR5cGVdKTtcbiAgICAgICAgZGVmaW5lKFNIQVBFX0RFRlNbdGhpcy5zaGFwZV0pO1xuICAgICAgICBkZWZpbmUoQ09MT1JfREVGU1t0aGlzLnBvaW50Q29sb3JUeXBlXSk7XG4gICAgICAgIGRlZmluZShDTElQX01PREVfREVGU1t0aGlzLmNsaXBNb2RlXSk7XG4gICAgICAgIGRlZmluZShPUEFDSVRZX0RFRlNbdGhpcy5wb2ludE9wYWNpdHlUeXBlXSk7XG4gICAgICAgIC8vIFdlIG9ubHkgcGVyZm9ybSBnYW1tYSBhbmQgYnJpZ2h0bmVzcy9jb250cmFzdCBjYWxjdWxhdGlvbnMgcGVyIHBvaW50IGlmIHZhbHVlcyBhcmUgc3BlY2lmaWVkLlxuICAgICAgICBpZiAodGhpcy5yZ2JHYW1tYSAhPT0gREVGQVVMVF9SR0JfR0FNTUEgfHxcbiAgICAgICAgICAgIHRoaXMucmdiQnJpZ2h0bmVzcyAhPT0gREVGQVVMVF9SR0JfQlJJR0hUTkVTUyB8fFxuICAgICAgICAgICAgdGhpcy5yZ2JDb250cmFzdCAhPT0gREVGQVVMVF9SR0JfQ09OVFJBU1QpIHtcbiAgICAgICAgICAgIGRlZmluZSgndXNlX3JnYl9nYW1tYV9jb250cmFzdF9icmlnaHRuZXNzJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudXNlRmlsdGVyQnlOb3JtYWwpIHtcbiAgICAgICAgICAgIGRlZmluZSgndXNlX2ZpbHRlcl9ieV9ub3JtYWwnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy51c2VFREwpIHtcbiAgICAgICAgICAgIGRlZmluZSgndXNlX2VkbCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLndlaWdodGVkKSB7XG4gICAgICAgICAgICBkZWZpbmUoJ3dlaWdodGVkX3NwbGF0cycpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm51bUNsaXBCb3hlcyA+IDApIHtcbiAgICAgICAgICAgIGRlZmluZSgndXNlX2NsaXBfYm94Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaGlnaGxpZ2h0UG9pbnQpIHtcbiAgICAgICAgICAgIGRlZmluZSgnaGlnaGxpZ2h0X3BvaW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudXNlVGV4dHVyZUJsZW5kaW5nKSB7XG4gICAgICAgICAgICBkZWZpbmUoJ3VzZV90ZXh0dXJlX2JsZW5kaW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudXNlUG9pbnRDbG91ZE1peGluZykge1xuICAgICAgICAgICAgZGVmaW5lKCd1c2VfcG9pbnRfY2xvdWRfbWl4aW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY29sb3JSZ2JhKSB7XG4gICAgICAgICAgICBkZWZpbmUoJ2NvbG9yX3JnYmEnKTtcbiAgICAgICAgfVxuICAgICAgICBkZWZpbmUoJ01BWF9QT0lOVF9MSUdIVFMgMCcpO1xuICAgICAgICBkZWZpbmUoJ01BWF9ESVJfTElHSFRTIDAnKTtcbiAgICAgICAgcGFydHMucHVzaChzaGFkZXJTcmMpO1xuICAgICAgICByZXR1cm4gcGFydHMuam9pbignXFxuJyk7XG4gICAgfVxuICAgIHNldFBvaW50Q2xvdWRNaXhpbmdNb2RlKG1vZGUpIHtcbiAgICAgICAgdGhpcy5wb2ludENsb3VkTWl4aW5nTW9kZSA9IG1vZGU7XG4gICAgfVxuICAgIGdldFBvaW50Q2xvdWRNaXhpbmdNb2RlKCkge1xuICAgICAgICBpZiAodGhpcy5wb2ludENsb3VkTWl4aW5nTW9kZSA9PT0gUG9pbnRDbG91ZE1peGluZ01vZGUuU1RSSVBFUykge1xuICAgICAgICAgICAgcmV0dXJuIFBvaW50Q2xvdWRNaXhpbmdNb2RlLlNUUklQRVM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFBvaW50Q2xvdWRNaXhpbmdNb2RlLkNIRUNLQk9BUkQ7XG4gICAgfVxuICAgIHNldENsaXBCb3hlcyhjbGlwQm94ZXMpIHtcbiAgICAgICAgaWYgKCFjbGlwQm94ZXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsaXBCb3hlcyA9IGNsaXBCb3hlcztcbiAgICAgICAgY29uc3QgZG9VcGRhdGUgPSB0aGlzLm51bUNsaXBCb3hlcyAhPT0gY2xpcEJveGVzLmxlbmd0aCAmJiAoY2xpcEJveGVzLmxlbmd0aCA9PT0gMCB8fCB0aGlzLm51bUNsaXBCb3hlcyA9PT0gMCk7XG4gICAgICAgIHRoaXMubnVtQ2xpcEJveGVzID0gY2xpcEJveGVzLmxlbmd0aDtcbiAgICAgICAgdGhpcy5zZXRVbmlmb3JtKCdjbGlwQm94Q291bnQnLCB0aGlzLm51bUNsaXBCb3hlcyk7XG4gICAgICAgIGlmIChkb1VwZGF0ZSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTaGFkZXJTb3VyY2UoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjbGlwQm94ZXNMZW5ndGggPSB0aGlzLm51bUNsaXBCb3hlcyAqIDE2O1xuICAgICAgICBjb25zdCBjbGlwQm94ZXNBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoY2xpcEJveGVzTGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm51bUNsaXBCb3hlczsgaSsrKSB7XG4gICAgICAgICAgICBjbGlwQm94ZXNBcnJheS5zZXQoY2xpcEJveGVzW2ldLmludmVyc2UuZWxlbWVudHMsIDE2ICogaSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjbGlwQm94ZXNMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGlzTmFOKGNsaXBCb3hlc0FycmF5W2ldKSkge1xuICAgICAgICAgICAgICAgIGNsaXBCb3hlc0FycmF5W2ldID0gSW5maW5pdHk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRVbmlmb3JtKCdjbGlwQm94ZXMnLCBjbGlwQm94ZXNBcnJheSk7XG4gICAgfVxuICAgIGdldCBncmFkaWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dyYWRpZW50O1xuICAgIH1cbiAgICBzZXQgZ3JhZGllbnQodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2dyYWRpZW50ICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fZ3JhZGllbnQgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuZ3JhZGllbnRUZXh0dXJlID0gZ2VuZXJhdGVHcmFkaWVudFRleHR1cmUodGhpcy5fZ3JhZGllbnQpO1xuICAgICAgICAgICAgdGhpcy5zZXRVbmlmb3JtKCdncmFkaWVudCcsIHRoaXMuZ3JhZGllbnRUZXh0dXJlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgY2xhc3NpZmljYXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbGFzc2lmaWNhdGlvbjtcbiAgICB9XG4gICAgc2V0IGNsYXNzaWZpY2F0aW9uKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNvcHkgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXModmFsdWUpKSB7XG4gICAgICAgICAgICBjb3B5W2tleV0gPSB2YWx1ZVtrZXldLmNsb25lKCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGlzRXF1YWwgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuX2NsYXNzaWZpY2F0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlzRXF1YWwgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlzRXF1YWwgPSBPYmplY3Qua2V5cyhjb3B5KS5sZW5ndGggPT09IE9iamVjdC5rZXlzKHRoaXMuX2NsYXNzaWZpY2F0aW9uKS5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhjb3B5KSkge1xuICAgICAgICAgICAgICAgIGlzRXF1YWwgPSBpc0VxdWFsICYmIHRoaXMuX2NsYXNzaWZpY2F0aW9uW2tleV0gIT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBpc0VxdWFsID0gaXNFcXVhbCAmJiBjb3B5W2tleV0uZXF1YWxzKHRoaXMuX2NsYXNzaWZpY2F0aW9uW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghaXNFcXVhbCkge1xuICAgICAgICAgICAgdGhpcy5fY2xhc3NpZmljYXRpb24gPSBjb3B5O1xuICAgICAgICAgICAgdGhpcy5yZWNvbXB1dGVDbGFzc2lmaWNhdGlvbigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlY29tcHV0ZUNsYXNzaWZpY2F0aW9uKCkge1xuICAgICAgICB0aGlzLmNsYXNzaWZpY2F0aW9uVGV4dHVyZSA9IGdlbmVyYXRlQ2xhc3NpZmljYXRpb25UZXh0dXJlKHRoaXMuX2NsYXNzaWZpY2F0aW9uKTtcbiAgICAgICAgdGhpcy5zZXRVbmlmb3JtKCdjbGFzc2lmaWNhdGlvbkxVVCcsIHRoaXMuY2xhc3NpZmljYXRpb25UZXh0dXJlKTtcbiAgICB9XG4gICAgZ2V0IGVsZXZhdGlvblJhbmdlKCkge1xuICAgICAgICByZXR1cm4gW3RoaXMuaGVpZ2h0TWluLCB0aGlzLmhlaWdodE1heF07XG4gICAgfVxuICAgIHNldCBlbGV2YXRpb25SYW5nZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLmhlaWdodE1pbiA9IHZhbHVlWzBdO1xuICAgICAgICB0aGlzLmhlaWdodE1heCA9IHZhbHVlWzFdO1xuICAgIH1cbiAgICBnZXRVbmlmb3JtKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudW5pZm9ybXMgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHRoaXMudW5pZm9ybXNbbmFtZV0udmFsdWU7XG4gICAgfVxuICAgIHNldFVuaWZvcm0obmFtZSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMudW5pZm9ybXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVPYmogPSB0aGlzLnVuaWZvcm1zW25hbWVdO1xuICAgICAgICBpZiAodU9iai50eXBlID09PSAnYycpIHtcbiAgICAgICAgICAgIHVPYmoudmFsdWUuY29weSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUgIT09IHVPYmoudmFsdWUpIHtcbiAgICAgICAgICAgIHVPYmoudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVNYXRlcmlhbChvY3RyZWUsIHZpc2libGVOb2RlcywgY2FtZXJhLCByZW5kZXJlcikge1xuICAgICAgICBjb25zdCBwaXhlbFJhdGlvID0gcmVuZGVyZXIuZ2V0UGl4ZWxSYXRpbygpO1xuICAgICAgICBpZiAoY2FtZXJhLnR5cGUgPT09IFBFUlNQRUNUSVZFX0NBTUVSQSkge1xuICAgICAgICAgICAgdGhpcy5mb3YgPSBjYW1lcmEuZm92ICogKE1hdGguUEkgLyAxODApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5mb3YgPSBNYXRoLlBJIC8gMjsgLy8gd2lsbCByZXN1bHQgaW4gc2xvcGUgPSAxIGluIHRoZSBzaGFkZXJcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZW5kZXJUYXJnZXQgPSByZW5kZXJlci5nZXRSZW5kZXJUYXJnZXQoKTtcbiAgICAgICAgaWYgKHJlbmRlclRhcmdldCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5zY3JlZW5XaWR0aCA9IHJlbmRlclRhcmdldC53aWR0aDtcbiAgICAgICAgICAgIHRoaXMuc2NyZWVuSGVpZ2h0ID0gcmVuZGVyVGFyZ2V0LmhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2NyZWVuV2lkdGggPSByZW5kZXJlci5kb21FbGVtZW50LmNsaWVudFdpZHRoICogcGl4ZWxSYXRpbztcbiAgICAgICAgICAgIHRoaXMuc2NyZWVuSGVpZ2h0ID0gcmVuZGVyZXIuZG9tRWxlbWVudC5jbGllbnRIZWlnaHQgKiBwaXhlbFJhdGlvO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnVzZURyYXdpbmdCdWZmZXJTaXplKSB7XG4gICAgICAgICAgICByZW5kZXJlci5nZXREcmF3aW5nQnVmZmVyU2l6ZShQb2ludENsb3VkTWF0ZXJpYWwuaGVscGVyVmVjMik7XG4gICAgICAgICAgICB0aGlzLnNjcmVlbldpZHRoID0gUG9pbnRDbG91ZE1hdGVyaWFsLmhlbHBlclZlYzIud2lkdGg7XG4gICAgICAgICAgICB0aGlzLnNjcmVlbkhlaWdodCA9IFBvaW50Q2xvdWRNYXRlcmlhbC5oZWxwZXJWZWMyLmhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtYXhTY2FsZSA9IE1hdGgubWF4KG9jdHJlZS5zY2FsZS54LCBvY3RyZWUuc2NhbGUueSwgb2N0cmVlLnNjYWxlLnopO1xuICAgICAgICB0aGlzLnNwYWNpbmcgPSBvY3RyZWUucGNvR2VvbWV0cnkuc3BhY2luZyAqIG1heFNjYWxlO1xuICAgICAgICB0aGlzLm9jdHJlZVNpemUgPSBvY3RyZWUucGNvR2VvbWV0cnkuYm91bmRpbmdCb3guZ2V0U2l6ZShQb2ludENsb3VkTWF0ZXJpYWwuaGVscGVyVmVjMykueDtcbiAgICAgICAgaWYgKHRoaXMucG9pbnRTaXplVHlwZSA9PT0gUG9pbnRTaXplVHlwZS5BREFQVElWRSB8fFxuICAgICAgICAgICAgdGhpcy5wb2ludENvbG9yVHlwZSA9PT0gUG9pbnRDb2xvclR5cGUuTE9EKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZpc2liaWxpdHlUZXh0dXJlRGF0YSh2aXNpYmxlTm9kZXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZVZpc2liaWxpdHlUZXh0dXJlRGF0YShub2Rlcykge1xuICAgICAgICBub2Rlcy5zb3J0KGJ5TGV2ZWxBbmRJbmRleCk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheShub2Rlcy5sZW5ndGggKiA0KTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0c1RvQ2hpbGQgPSBuZXcgQXJyYXkobm9kZXMubGVuZ3RoKS5maWxsKEluZmluaXR5KTtcbiAgICAgICAgdGhpcy52aXNpYmxlTm9kZVRleHR1cmVPZmZzZXRzLmNsZWFyKCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgICAgIHRoaXMudmlzaWJsZU5vZGVUZXh0dXJlT2Zmc2V0cy5zZXQobm9kZS5uYW1lLCBpKTtcbiAgICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudE5hbWUgPSBub2RlLm5hbWUuc2xpY2UoMCwgLTEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudE9mZnNldCA9IHRoaXMudmlzaWJsZU5vZGVUZXh0dXJlT2Zmc2V0cy5nZXQocGFyZW50TmFtZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50T2Zmc2V0VG9DaGlsZCA9IGkgLSBwYXJlbnRPZmZzZXQ7XG4gICAgICAgICAgICAgICAgb2Zmc2V0c1RvQ2hpbGRbcGFyZW50T2Zmc2V0XSA9IE1hdGgubWluKG9mZnNldHNUb0NoaWxkW3BhcmVudE9mZnNldF0sIHBhcmVudE9mZnNldFRvQ2hpbGQpO1xuICAgICAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlOm5vLWJpdHdpc2VcbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBwYXJlbnRPZmZzZXQgKiA0O1xuICAgICAgICAgICAgICAgIGRhdGFbb2Zmc2V0XSA9IGRhdGFbb2Zmc2V0XSB8ICgxIDw8IG5vZGUuaW5kZXgpO1xuICAgICAgICAgICAgICAgIGRhdGFbb2Zmc2V0ICsgMV0gPSBvZmZzZXRzVG9DaGlsZFtwYXJlbnRPZmZzZXRdID4+IDg7XG4gICAgICAgICAgICAgICAgZGF0YVtvZmZzZXQgKyAyXSA9IG9mZnNldHNUb0NoaWxkW3BhcmVudE9mZnNldF0gJSAyNTY7XG4gICAgICAgICAgICAgICAgLy8gdHNsaW50OmVuYWJsZTpuby1iaXR3aXNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkYXRhW2kgKiA0ICsgM10gPSBub2RlLm5hbWUubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRleHR1cmUgPSB0aGlzLnZpc2libGVOb2Rlc1RleHR1cmU7XG4gICAgICAgIGlmICh0ZXh0dXJlKSB7XG4gICAgICAgICAgICB0ZXh0dXJlLmltYWdlLmRhdGEuc2V0KGRhdGEpO1xuICAgICAgICAgICAgdGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIG1ha2VPbkJlZm9yZVJlbmRlcihvY3RyZWUsIG5vZGUsIHBjSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIChfcmVuZGVyZXIsIF9zY2VuZSwgX2NhbWVyYSwgX2dlb21ldHJ5LCBtYXRlcmlhbCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcG9pbnRDbG91ZE1hdGVyaWFsID0gbWF0ZXJpYWw7XG4gICAgICAgICAgICBjb25zdCBtYXRlcmlhbFVuaWZvcm1zID0gcG9pbnRDbG91ZE1hdGVyaWFsLnVuaWZvcm1zO1xuICAgICAgICAgICAgbWF0ZXJpYWxVbmlmb3Jtcy5sZXZlbC52YWx1ZSA9IG5vZGUubGV2ZWw7XG4gICAgICAgICAgICBtYXRlcmlhbFVuaWZvcm1zLmlzTGVhZk5vZGUudmFsdWUgPSBub2RlLmlzTGVhZk5vZGU7XG4gICAgICAgICAgICBjb25zdCB2blN0YXJ0ID0gcG9pbnRDbG91ZE1hdGVyaWFsLnZpc2libGVOb2RlVGV4dHVyZU9mZnNldHMuZ2V0KG5vZGUubmFtZSk7XG4gICAgICAgICAgICBpZiAodm5TdGFydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbWF0ZXJpYWxVbmlmb3Jtcy52blN0YXJ0LnZhbHVlID0gdm5TdGFydDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1hdGVyaWFsVW5pZm9ybXMucGNJbmRleC52YWx1ZSA9XG4gICAgICAgICAgICAgICAgcGNJbmRleCAhPT0gdW5kZWZpbmVkID8gcGNJbmRleCA6IG9jdHJlZS52aXNpYmxlTm9kZXMuaW5kZXhPZihub2RlKTtcbiAgICAgICAgICAgIC8vIE5vdGU6IHdoZW4gY2hhbmdpbmcgdW5pZm9ybXMgaW4gb25CZWZvcmVSZW5kZXIsIHRoZSBmbGFnIHVuaWZvcm1zTmVlZFVwZGF0ZSBoYXMgdG8gYmVcbiAgICAgICAgICAgIC8vIHNldCB0byB0cnVlIHRvIGluc3RydWN0IFRocmVlSlMgdG8gdXBsb2FkIHRoZW0uIFNlZSBhbHNvXG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL3RocmVlLmpzL2lzc3Vlcy85ODcwI2lzc3VlY29tbWVudC0zNjg3NTAxODIuXG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhlIGNhc3QgdG8gYW55IGFmdGVyIHVwZGF0aW5nIHRvIFRocmVlLkpTID49IHIxMTNcbiAgICAgICAgICAgIG1hdGVyaWFsIC8qU2hhZGVyTWF0ZXJpYWwqLy51bmlmb3Jtc05lZWRVcGRhdGUgPSB0cnVlO1xuICAgICAgICB9O1xuICAgIH1cbn1cblBvaW50Q2xvdWRNYXRlcmlhbC5oZWxwZXJWZWMzID0gbmV3IFZlY3RvcjMoKTtcblBvaW50Q2xvdWRNYXRlcmlhbC5oZWxwZXJWZWMyID0gbmV3IFZlY3RvcjIoKTtcbl9fZGVjb3JhdGUoW1xuICAgIHVuaWZvcm0oJ2JiU2l6ZScpXG5dLCBQb2ludENsb3VkTWF0ZXJpYWwucHJvdG90eXBlLCBcImJiU2l6ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgdW5pZm9ybSgnY2xpcEV4dGVudCcpXG5dLCBQb2ludENsb3VkTWF0ZXJpYWwucHJvdG90eXBlLCBcImNsaXBFeHRlbnRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIHVuaWZvcm0oJ2RlcHRoTWFwJylcbl0sIFBvaW50Q2xvdWRNYXRlcmlhbC5wcm90b3R5cGUsIFwiZGVwdGhNYXBcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIHVuaWZvcm0oJ2ZvdicpXG5dLCBQb2ludENsb3VkTWF0ZXJpYWwucHJvdG90eXBlLCBcImZvdlwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgdW5pZm9ybSgnaGVpZ2h0TWF4Jylcbl0sIFBvaW50Q2xvdWRNYXRlcmlhbC5wcm90b3R5cGUsIFwiaGVpZ2h0TWF4XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICB1bmlmb3JtKCdoZWlnaHRNaW4nKVxuXSwgUG9pbnRDbG91ZE1hdGVyaWFsLnByb3RvdHlwZSwgXCJoZWlnaHRNaW5cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIHVuaWZvcm0oJ2ludGVuc2l0eUJyaWdodG5lc3MnKVxuXSwgUG9pbnRDbG91ZE1hdGVyaWFsLnByb3RvdHlwZSwgXCJpbnRlbnNpdHlCcmlnaHRuZXNzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICB1bmlmb3JtKCdpbnRlbnNpdHlDb250cmFzdCcpXG5dLCBQb2ludENsb3VkTWF0ZXJpYWwucHJvdG90eXBlLCBcImludGVuc2l0eUNvbnRyYXN0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICB1bmlmb3JtKCdpbnRlbnNpdHlHYW1tYScpXG5dLCBQb2ludENsb3VkTWF0ZXJpYWwucHJvdG90eXBlLCBcImludGVuc2l0eUdhbW1hXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICB1bmlmb3JtKCdpbnRlbnNpdHlSYW5nZScpXG5dLCBQb2ludENsb3VkTWF0ZXJpYWwucHJvdG90eXBlLCBcImludGVuc2l0eVJhbmdlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICB1bmlmb3JtKCdtYXhTaXplJylcbl0sIFBvaW50Q2xvdWRNYXRlcmlhbC5wcm90b3R5cGUsIFwibWF4U2l6ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgdW5pZm9ybSgnbWluU2l6ZScpXG5dLCBQb2ludENsb3VkTWF0ZXJpYWwucHJvdG90eXBlLCBcIm1pblNpemVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIHVuaWZvcm0oJ29jdHJlZVNpemUnKVxuXSwgUG9pbnRDbG91ZE1hdGVyaWFsLnByb3RvdHlwZSwgXCJvY3RyZWVTaXplXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICB1bmlmb3JtKCdvcGFjaXR5JywgdHJ1ZSlcbl0sIFBvaW50Q2xvdWRNYXRlcmlhbC5wcm90b3R5cGUsIFwib3BhY2l0eVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgdW5pZm9ybSgncmdiQnJpZ2h0bmVzcycsIHRydWUpXG5dLCBQb2ludENsb3VkTWF0ZXJpYWwucHJvdG90eXBlLCBcInJnYkJyaWdodG5lc3NcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIHVuaWZvcm0oJ3JnYkNvbnRyYXN0JywgdHJ1ZSlcbl0sIFBvaW50Q2xvdWRNYXRlcmlhbC5wcm90b3R5cGUsIFwicmdiQ29udHJhc3RcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIHVuaWZvcm0oJ3JnYkdhbW1hJywgdHJ1ZSlcbl0sIFBvaW50Q2xvdWRNYXRlcmlhbC5wcm90b3R5cGUsIFwicmdiR2FtbWFcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIHVuaWZvcm0oJ3NjcmVlbkhlaWdodCcpXG5dLCBQb2ludENsb3VkTWF0ZXJpYWwucHJvdG90eXBlLCBcInNjcmVlbkhlaWdodFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgdW5pZm9ybSgnc2NyZWVuV2lkdGgnKVxuXSwgUG9pbnRDbG91ZE1hdGVyaWFsLnByb3RvdHlwZSwgXCJzY3JlZW5XaWR0aFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgdW5pZm9ybSgnc2l6ZScpXG5dLCBQb2ludENsb3VkTWF0ZXJpYWwucHJvdG90eXBlLCBcInNpemVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIHVuaWZvcm0oJ3NwYWNpbmcnKVxuXSwgUG9pbnRDbG91ZE1hdGVyaWFsLnByb3RvdHlwZSwgXCJzcGFjaW5nXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICB1bmlmb3JtKCd0cmFuc2l0aW9uJylcbl0sIFBvaW50Q2xvdWRNYXRlcmlhbC5wcm90b3R5cGUsIFwidHJhbnNpdGlvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgdW5pZm9ybSgndUNvbG9yJylcbl0sIFBvaW50Q2xvdWRNYXRlcmlhbC5wcm90b3R5cGUsIFwiY29sb3JcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIHVuaWZvcm0oJ3dDbGFzc2lmaWNhdGlvbicpXG5dLCBQb2ludENsb3VkTWF0ZXJpYWwucHJvdG90eXBlLCBcIndlaWdodENsYXNzaWZpY2F0aW9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICB1bmlmb3JtKCd3RWxldmF0aW9uJylcbl0sIFBvaW50Q2xvdWRNYXRlcmlhbC5wcm90b3R5cGUsIFwid2VpZ2h0RWxldmF0aW9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICB1bmlmb3JtKCd3SW50ZW5zaXR5Jylcbl0sIFBvaW50Q2xvdWRNYXRlcmlhbC5wcm90b3R5cGUsIFwid2VpZ2h0SW50ZW5zaXR5XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICB1bmlmb3JtKCd3UmV0dXJuTnVtYmVyJylcbl0sIFBvaW50Q2xvdWRNYXRlcmlhbC5wcm90b3R5cGUsIFwid2VpZ2h0UmV0dXJuTnVtYmVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICB1bmlmb3JtKCd3UkdCJylcbl0sIFBvaW50Q2xvdWRNYXRlcmlhbC5wcm90b3R5cGUsIFwid2VpZ2h0UkdCXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICB1bmlmb3JtKCd3U291cmNlSUQnKVxuXSwgUG9pbnRDbG91ZE1hdGVyaWFsLnByb3RvdHlwZSwgXCJ3ZWlnaHRTb3VyY2VJRFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgdW5pZm9ybSgnb3BhY2l0eUF0dGVudWF0aW9uJylcbl0sIFBvaW50Q2xvdWRNYXRlcmlhbC5wcm90b3R5cGUsIFwib3BhY2l0eUF0dGVudWF0aW9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICB1bmlmb3JtKCdmaWx0ZXJCeU5vcm1hbFRocmVzaG9sZCcpXG5dLCBQb2ludENsb3VkTWF0ZXJpYWwucHJvdG90eXBlLCBcImZpbHRlckJ5Tm9ybWFsVGhyZXNob2xkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICB1bmlmb3JtKCdoaWdobGlnaHRlZFBvaW50Q29vcmRpbmF0ZScpXG5dLCBQb2ludENsb3VkTWF0ZXJpYWwucHJvdG90eXBlLCBcImhpZ2hsaWdodGVkUG9pbnRDb29yZGluYXRlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICB1bmlmb3JtKCdoaWdobGlnaHRlZFBvaW50Q29sb3InKVxuXSwgUG9pbnRDbG91ZE1hdGVyaWFsLnByb3RvdHlwZSwgXCJoaWdobGlnaHRlZFBvaW50Q29sb3JcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIHVuaWZvcm0oJ2VuYWJsZVBvaW50SGlnaGxpZ2h0aW5nJylcbl0sIFBvaW50Q2xvdWRNYXRlcmlhbC5wcm90b3R5cGUsIFwiZW5hYmxlUG9pbnRIaWdobGlnaHRpbmdcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIHVuaWZvcm0oJ2hpZ2hsaWdodGVkUG9pbnRTY2FsZScpXG5dLCBQb2ludENsb3VkTWF0ZXJpYWwucHJvdG90eXBlLCBcImhpZ2hsaWdodGVkUG9pbnRTY2FsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgdW5pZm9ybSgnbm9ybWFsRmlsdGVyaW5nTW9kZScpXG5dLCBQb2ludENsb3VkTWF0ZXJpYWwucHJvdG90eXBlLCBcIm5vcm1hbEZpbHRlcmluZ01vZGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIHVuaWZvcm0oJ2JhY2tncm91bmRNYXAnKVxuXSwgUG9pbnRDbG91ZE1hdGVyaWFsLnByb3RvdHlwZSwgXCJiYWNrZ3JvdW5kTWFwXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICB1bmlmb3JtKCdwb2ludENsb3VkSUQnKVxuXSwgUG9pbnRDbG91ZE1hdGVyaWFsLnByb3RvdHlwZSwgXCJwb2ludENsb3VkSURcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIHVuaWZvcm0oJ3BvaW50Q2xvdWRNaXhpbmdNb2RlJylcbl0sIFBvaW50Q2xvdWRNYXRlcmlhbC5wcm90b3R5cGUsIFwicG9pbnRDbG91ZE1peGluZ01vZGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIHVuaWZvcm0oJ3N0cmlwZURpc3RhbmNlWCcpXG5dLCBQb2ludENsb3VkTWF0ZXJpYWwucHJvdG90eXBlLCBcInN0cmlwZURpc3RhbmNlWFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgdW5pZm9ybSgnc3RyaXBlRGlzdGFuY2VZJylcbl0sIFBvaW50Q2xvdWRNYXRlcmlhbC5wcm90b3R5cGUsIFwic3RyaXBlRGlzdGFuY2VZXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICB1bmlmb3JtKCdzdHJpcGVEaXZpc29yWCcpXG5dLCBQb2ludENsb3VkTWF0ZXJpYWwucHJvdG90eXBlLCBcInN0cmlwZURpdmlzb3JYXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICB1bmlmb3JtKCdzdHJpcGVEaXZpc29yWScpXG5dLCBQb2ludENsb3VkTWF0ZXJpYWwucHJvdG90eXBlLCBcInN0cmlwZURpdmlzb3JZXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICB1bmlmb3JtKCdwb2ludENsb3VkTWl4QW5nbGUnKVxuXSwgUG9pbnRDbG91ZE1hdGVyaWFsLnByb3RvdHlwZSwgXCJwb2ludENsb3VkTWl4QW5nbGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIHJlcXVpcmVzU2hhZGVyVXBkYXRlKClcbl0sIFBvaW50Q2xvdWRNYXRlcmlhbC5wcm90b3R5cGUsIFwidXNlQ2xpcEJveFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgcmVxdWlyZXNTaGFkZXJVcGRhdGUoKVxuXSwgUG9pbnRDbG91ZE1hdGVyaWFsLnByb3RvdHlwZSwgXCJ3ZWlnaHRlZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgcmVxdWlyZXNTaGFkZXJVcGRhdGUoKVxuXSwgUG9pbnRDbG91ZE1hdGVyaWFsLnByb3RvdHlwZSwgXCJwb2ludENvbG9yVHlwZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgcmVxdWlyZXNTaGFkZXJVcGRhdGUoKVxuXSwgUG9pbnRDbG91ZE1hdGVyaWFsLnByb3RvdHlwZSwgXCJwb2ludFNpemVUeXBlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICByZXF1aXJlc1NoYWRlclVwZGF0ZSgpXG5dLCBQb2ludENsb3VkTWF0ZXJpYWwucHJvdG90eXBlLCBcImNsaXBNb2RlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICByZXF1aXJlc1NoYWRlclVwZGF0ZSgpXG5dLCBQb2ludENsb3VkTWF0ZXJpYWwucHJvdG90eXBlLCBcInVzZUVETFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgcmVxdWlyZXNTaGFkZXJVcGRhdGUoKVxuXSwgUG9pbnRDbG91ZE1hdGVyaWFsLnByb3RvdHlwZSwgXCJzaGFwZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgcmVxdWlyZXNTaGFkZXJVcGRhdGUoKVxuXSwgUG9pbnRDbG91ZE1hdGVyaWFsLnByb3RvdHlwZSwgXCJ0cmVlVHlwZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgcmVxdWlyZXNTaGFkZXJVcGRhdGUoKVxuXSwgUG9pbnRDbG91ZE1hdGVyaWFsLnByb3RvdHlwZSwgXCJwb2ludE9wYWNpdHlUeXBlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICByZXF1aXJlc1NoYWRlclVwZGF0ZSgpXG5dLCBQb2ludENsb3VkTWF0ZXJpYWwucHJvdG90eXBlLCBcInVzZUZpbHRlckJ5Tm9ybWFsXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICByZXF1aXJlc1NoYWRlclVwZGF0ZSgpXG5dLCBQb2ludENsb3VkTWF0ZXJpYWwucHJvdG90eXBlLCBcInVzZVRleHR1cmVCbGVuZGluZ1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgcmVxdWlyZXNTaGFkZXJVcGRhdGUoKVxuXSwgUG9pbnRDbG91ZE1hdGVyaWFsLnByb3RvdHlwZSwgXCJ1c2VQb2ludENsb3VkTWl4aW5nXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICByZXF1aXJlc1NoYWRlclVwZGF0ZSgpXG5dLCBQb2ludENsb3VkTWF0ZXJpYWwucHJvdG90eXBlLCBcImhpZ2hsaWdodFBvaW50XCIsIHZvaWQgMCk7XG5mdW5jdGlvbiBtYWtlVW5pZm9ybSh0eXBlLCB2YWx1ZSkge1xuICAgIHJldHVybiB7IHR5cGUsIHZhbHVlIH07XG59XG5mdW5jdGlvbiBnZXRWYWxpZChhLCBiKSB7XG4gICAgcmV0dXJuIGEgPT09IHVuZGVmaW5lZCA/IGIgOiBhO1xufVxuLy8gdHNsaW50OmRpc2FibGU6bm8taW52YWxpZC10aGlzXG5mdW5jdGlvbiB1bmlmb3JtKHVuaWZvcm1OYW1lLCByZXF1aXJlU3JjVXBkYXRlID0gZmFsc2UpIHtcbiAgICByZXR1cm4gKHRhcmdldCwgcHJvcGVydHlLZXkpID0+IHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHlLZXksIHtcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRVbmlmb3JtKHVuaWZvcm1OYW1lKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMuZ2V0VW5pZm9ybSh1bmlmb3JtTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRVbmlmb3JtKHVuaWZvcm1OYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXF1aXJlU3JjVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVNoYWRlclNvdXJjZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHJlcXVpcmVzU2hhZGVyVXBkYXRlKCkge1xuICAgIHJldHVybiAodGFyZ2V0LCBwcm9wZXJ0eUtleSkgPT4ge1xuICAgICAgICBjb25zdCBmaWVsZE5hbWUgPSBgXyR7cHJvcGVydHlLZXkudG9TdHJpbmcoKX1gO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eUtleSwge1xuICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW2ZpZWxkTmFtZV07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0KHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzW2ZpZWxkTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tmaWVsZE5hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU2hhZGVyU291cmNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbiIsImV4cG9ydCAqIGZyb20gJy4vYmx1ci1tYXRlcmlhbCc7XG5leHBvcnQgKiBmcm9tICcuL2NsaXBwaW5nJztcbmV4cG9ydCAqIGZyb20gJy4vZW51bXMnO1xuZXhwb3J0ICogZnJvbSAnLi9wb2ludC1jbG91ZC1tYXRlcmlhbCc7XG5leHBvcnQgKiBmcm9tICcuL3RleHR1cmUtZ2VuZXJhdGlvbic7XG5leHBvcnQgKiBmcm9tICcuL3R5cGVzJztcbmV4cG9ydCAqIGZyb20gJy4vZ3JhZGllbnRzJztcbiIsIi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIENvbnZlcnRlZCB0byBUeXBlc2NyaXB0IGFuZCBhZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL3BvdHJlZS9wb3RyZWVcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmV4cG9ydCB2YXIgUG9pbnRBdHRyaWJ1dGVOYW1lO1xuKGZ1bmN0aW9uIChQb2ludEF0dHJpYnV0ZU5hbWUpIHtcbiAgICBQb2ludEF0dHJpYnV0ZU5hbWVbUG9pbnRBdHRyaWJ1dGVOYW1lW1wiUE9TSVRJT05fQ0FSVEVTSUFOXCJdID0gMF0gPSBcIlBPU0lUSU9OX0NBUlRFU0lBTlwiO1xuICAgIFBvaW50QXR0cmlidXRlTmFtZVtQb2ludEF0dHJpYnV0ZU5hbWVbXCJDT0xPUl9QQUNLRURcIl0gPSAxXSA9IFwiQ09MT1JfUEFDS0VEXCI7XG4gICAgUG9pbnRBdHRyaWJ1dGVOYW1lW1BvaW50QXR0cmlidXRlTmFtZVtcIkNPTE9SX0ZMT0FUU18xXCJdID0gMl0gPSBcIkNPTE9SX0ZMT0FUU18xXCI7XG4gICAgUG9pbnRBdHRyaWJ1dGVOYW1lW1BvaW50QXR0cmlidXRlTmFtZVtcIkNPTE9SX0ZMT0FUU18yNTVcIl0gPSAzXSA9IFwiQ09MT1JfRkxPQVRTXzI1NVwiO1xuICAgIFBvaW50QXR0cmlidXRlTmFtZVtQb2ludEF0dHJpYnV0ZU5hbWVbXCJOT1JNQUxfRkxPQVRTXCJdID0gNF0gPSBcIk5PUk1BTF9GTE9BVFNcIjtcbiAgICBQb2ludEF0dHJpYnV0ZU5hbWVbUG9pbnRBdHRyaWJ1dGVOYW1lW1wiRklMTEVSXCJdID0gNV0gPSBcIkZJTExFUlwiO1xuICAgIFBvaW50QXR0cmlidXRlTmFtZVtQb2ludEF0dHJpYnV0ZU5hbWVbXCJJTlRFTlNJVFlcIl0gPSA2XSA9IFwiSU5URU5TSVRZXCI7XG4gICAgUG9pbnRBdHRyaWJ1dGVOYW1lW1BvaW50QXR0cmlidXRlTmFtZVtcIkNMQVNTSUZJQ0FUSU9OXCJdID0gN10gPSBcIkNMQVNTSUZJQ0FUSU9OXCI7XG4gICAgUG9pbnRBdHRyaWJ1dGVOYW1lW1BvaW50QXR0cmlidXRlTmFtZVtcIk5PUk1BTF9TUEhFUkVNQVBQRURcIl0gPSA4XSA9IFwiTk9STUFMX1NQSEVSRU1BUFBFRFwiO1xuICAgIFBvaW50QXR0cmlidXRlTmFtZVtQb2ludEF0dHJpYnV0ZU5hbWVbXCJOT1JNQUxfT0NUMTZcIl0gPSA5XSA9IFwiTk9STUFMX09DVDE2XCI7XG4gICAgUG9pbnRBdHRyaWJ1dGVOYW1lW1BvaW50QXR0cmlidXRlTmFtZVtcIk5PUk1BTFwiXSA9IDEwXSA9IFwiTk9STUFMXCI7XG59KShQb2ludEF0dHJpYnV0ZU5hbWUgfHwgKFBvaW50QXR0cmlidXRlTmFtZSA9IHt9KSk7XG5leHBvcnQgY29uc3QgUE9JTlRfQVRUUklCVVRFX1RZUEVTID0ge1xuICAgIERBVEFfVFlQRV9ET1VCTEU6IHsgb3JkaW5hbDogMCwgc2l6ZTogOCB9LFxuICAgIERBVEFfVFlQRV9GTE9BVDogeyBvcmRpbmFsOiAxLCBzaXplOiA0IH0sXG4gICAgREFUQV9UWVBFX0lOVDg6IHsgb3JkaW5hbDogMiwgc2l6ZTogMSB9LFxuICAgIERBVEFfVFlQRV9VSU5UODogeyBvcmRpbmFsOiAzLCBzaXplOiAxIH0sXG4gICAgREFUQV9UWVBFX0lOVDE2OiB7IG9yZGluYWw6IDQsIHNpemU6IDIgfSxcbiAgICBEQVRBX1RZUEVfVUlOVDE2OiB7IG9yZGluYWw6IDUsIHNpemU6IDIgfSxcbiAgICBEQVRBX1RZUEVfSU5UMzI6IHsgb3JkaW5hbDogNiwgc2l6ZTogNCB9LFxuICAgIERBVEFfVFlQRV9VSU5UMzI6IHsgb3JkaW5hbDogNywgc2l6ZTogNCB9LFxuICAgIERBVEFfVFlQRV9JTlQ2NDogeyBvcmRpbmFsOiA4LCBzaXplOiA4IH0sXG4gICAgREFUQV9UWVBFX1VJTlQ2NDogeyBvcmRpbmFsOiA5LCBzaXplOiA4IH0sXG59O1xuZnVuY3Rpb24gbWFrZVBvaW50QXR0cmlidXRlKG5hbWUsIHR5cGUsIG51bUVsZW1lbnRzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgbnVtRWxlbWVudHMsXG4gICAgICAgIGJ5dGVTaXplOiBudW1FbGVtZW50cyAqIHR5cGUuc2l6ZSxcbiAgICB9O1xufVxuY29uc3QgUkdCQV9QQUNLRUQgPSBtYWtlUG9pbnRBdHRyaWJ1dGUoUG9pbnRBdHRyaWJ1dGVOYW1lLkNPTE9SX1BBQ0tFRCwgUE9JTlRfQVRUUklCVVRFX1RZUEVTLkRBVEFfVFlQRV9JTlQ4LCA0KTtcbmV4cG9ydCBjb25zdCBQT0lOVF9BVFRSSUJVVEVTID0ge1xuICAgIFBPU0lUSU9OX0NBUlRFU0lBTjogbWFrZVBvaW50QXR0cmlidXRlKFBvaW50QXR0cmlidXRlTmFtZS5QT1NJVElPTl9DQVJURVNJQU4sIFBPSU5UX0FUVFJJQlVURV9UWVBFUy5EQVRBX1RZUEVfRkxPQVQsIDMpLFxuICAgIFJHQkFfUEFDS0VELFxuICAgIENPTE9SX1BBQ0tFRDogUkdCQV9QQUNLRUQsXG4gICAgUkdCX1BBQ0tFRDogbWFrZVBvaW50QXR0cmlidXRlKFBvaW50QXR0cmlidXRlTmFtZS5DT0xPUl9QQUNLRUQsIFBPSU5UX0FUVFJJQlVURV9UWVBFUy5EQVRBX1RZUEVfSU5UOCwgMyksXG4gICAgTk9STUFMX0ZMT0FUUzogbWFrZVBvaW50QXR0cmlidXRlKFBvaW50QXR0cmlidXRlTmFtZS5OT1JNQUxfRkxPQVRTLCBQT0lOVF9BVFRSSUJVVEVfVFlQRVMuREFUQV9UWVBFX0ZMT0FULCAzKSxcbiAgICBGSUxMRVJfMUI6IG1ha2VQb2ludEF0dHJpYnV0ZShQb2ludEF0dHJpYnV0ZU5hbWUuRklMTEVSLCBQT0lOVF9BVFRSSUJVVEVfVFlQRVMuREFUQV9UWVBFX1VJTlQ4LCAxKSxcbiAgICBJTlRFTlNJVFk6IG1ha2VQb2ludEF0dHJpYnV0ZShQb2ludEF0dHJpYnV0ZU5hbWUuSU5URU5TSVRZLCBQT0lOVF9BVFRSSUJVVEVfVFlQRVMuREFUQV9UWVBFX1VJTlQxNiwgMSksXG4gICAgQ0xBU1NJRklDQVRJT046IG1ha2VQb2ludEF0dHJpYnV0ZShQb2ludEF0dHJpYnV0ZU5hbWUuQ0xBU1NJRklDQVRJT04sIFBPSU5UX0FUVFJJQlVURV9UWVBFUy5EQVRBX1RZUEVfVUlOVDgsIDEpLFxuICAgIE5PUk1BTF9TUEhFUkVNQVBQRUQ6IG1ha2VQb2ludEF0dHJpYnV0ZShQb2ludEF0dHJpYnV0ZU5hbWUuTk9STUFMX1NQSEVSRU1BUFBFRCwgUE9JTlRfQVRUUklCVVRFX1RZUEVTLkRBVEFfVFlQRV9VSU5UOCwgMiksXG4gICAgTk9STUFMX09DVDE2OiBtYWtlUG9pbnRBdHRyaWJ1dGUoUG9pbnRBdHRyaWJ1dGVOYW1lLk5PUk1BTF9PQ1QxNiwgUE9JTlRfQVRUUklCVVRFX1RZUEVTLkRBVEFfVFlQRV9VSU5UOCwgMiksXG4gICAgTk9STUFMOiBtYWtlUG9pbnRBdHRyaWJ1dGUoUG9pbnRBdHRyaWJ1dGVOYW1lLk5PUk1BTCwgUE9JTlRfQVRUUklCVVRFX1RZUEVTLkRBVEFfVFlQRV9GTE9BVCwgMyksXG59O1xuZXhwb3J0IGNsYXNzIFBvaW50QXR0cmlidXRlcyB7XG4gICAgY29uc3RydWN0b3IocG9pbnRBdHRyaWJ1dGVOYW1lcyA9IFtdKSB7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlcyA9IFtdO1xuICAgICAgICB0aGlzLmJ5dGVTaXplID0gMDtcbiAgICAgICAgdGhpcy5zaXplID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludEF0dHJpYnV0ZU5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwb2ludEF0dHJpYnV0ZU5hbWUgPSBwb2ludEF0dHJpYnV0ZU5hbWVzW2ldO1xuICAgICAgICAgICAgY29uc3QgcG9pbnRBdHRyaWJ1dGUgPSBQT0lOVF9BVFRSSUJVVEVTW3BvaW50QXR0cmlidXRlTmFtZV07XG4gICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZXMucHVzaChwb2ludEF0dHJpYnV0ZSk7XG4gICAgICAgICAgICB0aGlzLmJ5dGVTaXplICs9IHBvaW50QXR0cmlidXRlLmJ5dGVTaXplO1xuICAgICAgICAgICAgdGhpcy5zaXplKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkKHBvaW50QXR0cmlidXRlKSB7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlcy5wdXNoKHBvaW50QXR0cmlidXRlKTtcbiAgICAgICAgdGhpcy5ieXRlU2l6ZSArPSBwb2ludEF0dHJpYnV0ZS5ieXRlU2l6ZTtcbiAgICAgICAgdGhpcy5zaXplKys7XG4gICAgfVxuICAgIGhhc0NvbG9ycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlcy5maW5kKGlzQ29sb3JBdHRyaWJ1dGUpICE9PSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGhhc05vcm1hbHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZXMuZmluZChpc05vcm1hbEF0dHJpYnV0ZSkgIT09IHVuZGVmaW5lZDtcbiAgICB9XG59XG5mdW5jdGlvbiBpc0NvbG9yQXR0cmlidXRlKHsgbmFtZSB9KSB7XG4gICAgcmV0dXJuIG5hbWUgPT09IFBvaW50QXR0cmlidXRlTmFtZS5DT0xPUl9QQUNLRUQ7XG59XG5mdW5jdGlvbiBpc05vcm1hbEF0dHJpYnV0ZSh7IG5hbWUgfSkge1xuICAgIHJldHVybiAobmFtZSA9PT0gUG9pbnRBdHRyaWJ1dGVOYW1lLk5PUk1BTF9TUEhFUkVNQVBQRUQgfHxcbiAgICAgICAgbmFtZSA9PT0gUG9pbnRBdHRyaWJ1dGVOYW1lLk5PUk1BTF9GTE9BVFMgfHxcbiAgICAgICAgbmFtZSA9PT0gUG9pbnRBdHRyaWJ1dGVOYW1lLk5PUk1BTCB8fFxuICAgICAgICBuYW1lID09PSBQb2ludEF0dHJpYnV0ZU5hbWUuTk9STUFMX09DVDE2KTtcbn1cbiIsImltcG9ydCB7IEJveDMsIFZlY3RvcjMgfSBmcm9tICd0aHJlZSc7XG4vKipcbiAqIGFkYXB0ZWQgZnJvbSBtaGx1c2thIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvaXNzdWVzLzE1NjFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVUcmFuc2Zvcm1lZEJvdW5kaW5nQm94KGJveCwgdHJhbnNmb3JtKSB7XG4gICAgcmV0dXJuIG5ldyBCb3gzKCkuc2V0RnJvbVBvaW50cyhbXG4gICAgICAgIG5ldyBWZWN0b3IzKGJveC5taW4ueCwgYm94Lm1pbi55LCBib3gubWluLnopLmFwcGx5TWF0cml4NCh0cmFuc2Zvcm0pLFxuICAgICAgICBuZXcgVmVjdG9yMyhib3gubWluLngsIGJveC5taW4ueSwgYm94Lm1pbi56KS5hcHBseU1hdHJpeDQodHJhbnNmb3JtKSxcbiAgICAgICAgbmV3IFZlY3RvcjMoYm94Lm1heC54LCBib3gubWluLnksIGJveC5taW4ueikuYXBwbHlNYXRyaXg0KHRyYW5zZm9ybSksXG4gICAgICAgIG5ldyBWZWN0b3IzKGJveC5taW4ueCwgYm94Lm1heC55LCBib3gubWluLnopLmFwcGx5TWF0cml4NCh0cmFuc2Zvcm0pLFxuICAgICAgICBuZXcgVmVjdG9yMyhib3gubWluLngsIGJveC5taW4ueSwgYm94Lm1heC56KS5hcHBseU1hdHJpeDQodHJhbnNmb3JtKSxcbiAgICAgICAgbmV3IFZlY3RvcjMoYm94Lm1pbi54LCBib3gubWF4LnksIGJveC5tYXgueikuYXBwbHlNYXRyaXg0KHRyYW5zZm9ybSksXG4gICAgICAgIG5ldyBWZWN0b3IzKGJveC5tYXgueCwgYm94Lm1heC55LCBib3gubWluLnopLmFwcGx5TWF0cml4NCh0cmFuc2Zvcm0pLFxuICAgICAgICBuZXcgVmVjdG9yMyhib3gubWF4LngsIGJveC5taW4ueSwgYm94Lm1heC56KS5hcHBseU1hdHJpeDQodHJhbnNmb3JtKSxcbiAgICAgICAgbmV3IFZlY3RvcjMoYm94Lm1heC54LCBib3gubWF4LnksIGJveC5tYXgueikuYXBwbHlNYXRyaXg0KHRyYW5zZm9ybSksXG4gICAgXSk7XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ2hpbGRBQUJCKGFhYmIsIGluZGV4KSB7XG4gICAgY29uc3QgbWluID0gYWFiYi5taW4uY2xvbmUoKTtcbiAgICBjb25zdCBtYXggPSBhYWJiLm1heC5jbG9uZSgpO1xuICAgIGNvbnN0IHNpemUgPSBuZXcgVmVjdG9yMygpLnN1YlZlY3RvcnMobWF4LCBtaW4pO1xuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1iaXR3aXNlXG4gICAgaWYgKChpbmRleCAmIDBiMDAwMSkgPiAwKSB7XG4gICAgICAgIG1pbi56ICs9IHNpemUueiAvIDI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBtYXgueiAtPSBzaXplLnogLyAyO1xuICAgIH1cbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYml0d2lzZVxuICAgIGlmICgoaW5kZXggJiAwYjAwMTApID4gMCkge1xuICAgICAgICBtaW4ueSArPSBzaXplLnkgLyAyO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbWF4LnkgLT0gc2l6ZS55IC8gMjtcbiAgICB9XG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWJpdHdpc2VcbiAgICBpZiAoKGluZGV4ICYgMGIwMTAwKSA+IDApIHtcbiAgICAgICAgbWluLnggKz0gc2l6ZS54IC8gMjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG1heC54IC09IHNpemUueCAvIDI7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQm94MyhtaW4sIG1heCk7XG59XG4iLCIvKipcbiAqIEFkYXB0ZWQgZnJvbSBQb3RyZWUuanMgaHR0cDovL3BvdHJlZS5vcmdcbiAqIFBvdHJlZSBMaWNlbnNlOiBodHRwczovL2dpdGh1Yi5jb20vcG90cmVlL3BvdHJlZS9ibG9iLzEuNS9MSUNFTlNFXG4gKi9cbmltcG9ydCB7IEV2ZW50RGlzcGF0Y2hlciwgU3BoZXJlLCBWZWN0b3IzIH0gZnJvbSAndGhyZWUnO1xuaW1wb3J0IHsgY3JlYXRlQ2hpbGRBQUJCIH0gZnJvbSAnLi91dGlscy9ib3VuZHMnO1xuaW1wb3J0IHsgZ2V0SW5kZXhGcm9tTmFtZSwgaGFuZGxlRW1wdHlCdWZmZXIsIGhhbmRsZUZhaWxlZFJlcXVlc3QgfSBmcm9tICcuL3V0aWxzL3V0aWxzJztcbmNvbnN0IE5PREVfU1RSSURFID0gNTtcbmV4cG9ydCBjbGFzcyBQb2ludENsb3VkT2N0cmVlR2VvbWV0cnlOb2RlIGV4dGVuZHMgRXZlbnREaXNwYXRjaGVyIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBwY29HZW9tZXRyeSwgYm91bmRpbmdCb3gpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5pZCA9IFBvaW50Q2xvdWRPY3RyZWVHZW9tZXRyeU5vZGUuaWRDb3VudCsrO1xuICAgICAgICB0aGlzLmxldmVsID0gMDtcbiAgICAgICAgdGhpcy5zcGFjaW5nID0gMDtcbiAgICAgICAgdGhpcy5oYXNDaGlsZHJlbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gW1xuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgIF07XG4gICAgICAgIHRoaXMubWVhbiA9IG5ldyBWZWN0b3IzKCk7XG4gICAgICAgIHRoaXMubnVtUG9pbnRzID0gMDtcbiAgICAgICAgdGhpcy5sb2FkZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sb2FkaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZmFpbGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5vbmVUaW1lRGlzcG9zZUhhbmRsZXJzID0gW107XG4gICAgICAgIHRoaXMuaXNMZWFmTm9kZSA9IHRydWU7XG4gICAgICAgIHRoaXMuaXNUcmVlTm9kZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzR2VvbWV0cnlOb2RlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5pbmRleCA9IGdldEluZGV4RnJvbU5hbWUobmFtZSk7XG4gICAgICAgIHRoaXMucGNvR2VvbWV0cnkgPSBwY29HZW9tZXRyeTtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveCA9IGJvdW5kaW5nQm94O1xuICAgICAgICB0aGlzLnRpZ2h0Qm91bmRpbmdCb3ggPSBib3VuZGluZ0JveC5jbG9uZSgpO1xuICAgICAgICB0aGlzLmJvdW5kaW5nU3BoZXJlID0gYm91bmRpbmdCb3guZ2V0Qm91bmRpbmdTcGhlcmUobmV3IFNwaGVyZSgpKTtcbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmdlb21ldHJ5IHx8ICF0aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ2VvbWV0cnkuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLmdlb21ldHJ5ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmxvYWRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9uZVRpbWVEaXNwb3NlSGFuZGxlcnMuZm9yRWFjaChoYW5kbGVyID0+IGhhbmRsZXIoKSk7XG4gICAgICAgIHRoaXMub25lVGltZURpc3Bvc2VIYW5kbGVycyA9IFtdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB1cmwgb2YgdGhlIGJpbmFyeSBmaWxlIGZvciB0aGlzIG5vZGUuXG4gICAgICovXG4gICAgZ2V0VXJsKCkge1xuICAgICAgICBjb25zdCBnZW9tZXRyeSA9IHRoaXMucGNvR2VvbWV0cnk7XG4gICAgICAgIGNvbnN0IHZlcnNpb24gPSBnZW9tZXRyeS5sb2FkZXIudmVyc2lvbjtcbiAgICAgICAgY29uc3QgcGF0aFBhcnRzID0gW2dlb21ldHJ5Lm9jdHJlZURpcl07XG4gICAgICAgIGlmIChnZW9tZXRyeS5sb2FkZXIgJiYgdmVyc2lvbi5lcXVhbE9ySGlnaGVyKCcxLjUnKSkge1xuICAgICAgICAgICAgcGF0aFBhcnRzLnB1c2godGhpcy5nZXRIaWVyYXJjaHlCYXNlVXJsKCkpO1xuICAgICAgICAgICAgcGF0aFBhcnRzLnB1c2godGhpcy5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2ZXJzaW9uLmVxdWFsT3JIaWdoZXIoJzEuNCcpKSB7XG4gICAgICAgICAgICBwYXRoUGFydHMucHVzaCh0aGlzLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZlcnNpb24udXBUbygnMS4zJykpIHtcbiAgICAgICAgICAgIHBhdGhQYXJ0cy5wdXNoKHRoaXMubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhdGhQYXJ0cy5qb2luKCcvJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHVybCBvZiB0aGUgaGllcmFyY2h5IGZpbGUgZm9yIHRoaXMgbm9kZS5cbiAgICAgKi9cbiAgICBnZXRIaWVyYXJjaHlVcmwoKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLnBjb0dlb21ldHJ5Lm9jdHJlZURpcn0vJHt0aGlzLmdldEhpZXJhcmNoeUJhc2VVcmwoKX0vJHt0aGlzLm5hbWV9LmhyY2A7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgdGhlIHNwZWNpZmllZCBub2RlIGFzIGEgY2hpbGQgb2YgdGhlIGN1cnJlbnQgbm9kZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjaGlsZFxuICAgICAqICAgIFRoZSBub2RlIHdoaWNoIGlzIHRvIGJlIGFkZGVkIGFzIGEgY2hpbGQuXG4gICAgICovXG4gICAgYWRkQ2hpbGQoY2hpbGQpIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbltjaGlsZC5pbmRleF0gPSBjaGlsZDtcbiAgICAgICAgdGhpcy5pc0xlYWZOb2RlID0gZmFsc2U7XG4gICAgICAgIGNoaWxkLnBhcmVudCA9IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxzIHRoZSBzcGVjaWZpZWQgY2FsbGJhY2sgZm9yIHRoZSBjdXJyZW50IG5vZGUgKGlmIGluY2x1ZGVTZWxmIGlzIHNldCB0byB0cnVlKSBhbmQgYWxsIGl0c1xuICAgICAqIGNoaWxkcmVuLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNiXG4gICAgICogICAgVGhlIGZ1bmN0aW9uIHdoaWNoIGlzIHRvIGJlIGNhbGxlZCBmb3IgZWFjaCBub2RlLlxuICAgICAqL1xuICAgIHRyYXZlcnNlKGNiLCBpbmNsdWRlU2VsZiA9IHRydWUpIHtcbiAgICAgICAgY29uc3Qgc3RhY2sgPSBpbmNsdWRlU2VsZiA/IFt0aGlzXSA6IFtdO1xuICAgICAgICBsZXQgY3VycmVudDtcbiAgICAgICAgd2hpbGUgKChjdXJyZW50ID0gc3RhY2sucG9wKCkpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNiKGN1cnJlbnQpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBjdXJyZW50LmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBsb2FkKCkge1xuICAgICAgICBpZiAoIXRoaXMuY2FuTG9hZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5wY29HZW9tZXRyeS5udW1Ob2Rlc0xvYWRpbmcrKztcbiAgICAgICAgdGhpcy5wY29HZW9tZXRyeS5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgIGxldCBwcm9taXNlO1xuICAgICAgICBpZiAodGhpcy5wY29HZW9tZXRyeS5sb2FkZXIudmVyc2lvbi5lcXVhbE9ySGlnaGVyKCcxLjUnKSAmJlxuICAgICAgICAgICAgdGhpcy5sZXZlbCAlIHRoaXMucGNvR2VvbWV0cnkuaGllcmFyY2h5U3RlcFNpemUgPT09IDAgJiZcbiAgICAgICAgICAgIHRoaXMuaGFzQ2hpbGRyZW4pIHtcbiAgICAgICAgICAgIHByb21pc2UgPSB0aGlzLmxvYWRIaWVyYWNoeVRoZW5Qb2ludHMoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHByb21pc2UgPSB0aGlzLmxvYWRQb2ludHMoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvbWlzZS5jYXRjaChyZWFzb24gPT4ge1xuICAgICAgICAgICAgdGhpcy5sb2FkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmZhaWxlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnBjb0dlb21ldHJ5Lm51bU5vZGVzTG9hZGluZy0tO1xuICAgICAgICAgICAgdGhyb3cgcmVhc29uO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2FuTG9hZCgpIHtcbiAgICAgICAgcmV0dXJuICghdGhpcy5sb2FkaW5nICYmXG4gICAgICAgICAgICAhdGhpcy5sb2FkZWQgJiZcbiAgICAgICAgICAgICF0aGlzLnBjb0dlb21ldHJ5LmRpc3Bvc2VkICYmXG4gICAgICAgICAgICAhdGhpcy5wY29HZW9tZXRyeS5sb2FkZXIuZGlzcG9zZWQgJiZcbiAgICAgICAgICAgIHRoaXMucGNvR2VvbWV0cnkubnVtTm9kZXNMb2FkaW5nIDwgdGhpcy5wY29HZW9tZXRyeS5tYXhOdW1Ob2Rlc0xvYWRpbmcpO1xuICAgIH1cbiAgICBsb2FkUG9pbnRzKCkge1xuICAgICAgICB0aGlzLnBjb0dlb21ldHJ5Lm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGNvR2VvbWV0cnkubG9hZGVyLmxvYWQodGhpcyk7XG4gICAgfVxuICAgIGxvYWRIaWVyYWNoeVRoZW5Qb2ludHMoKSB7XG4gICAgICAgIGlmICh0aGlzLmxldmVsICUgdGhpcy5wY29HZW9tZXRyeS5oaWVyYXJjaHlTdGVwU2l6ZSAhPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5wY29HZW9tZXRyeS5sb2FkZXIuZ2V0VXJsKHRoaXMuZ2V0SGllcmFyY2h5VXJsKCkpKVxuICAgICAgICAgICAgLnRoZW4odXJsID0+IHRoaXMucGNvR2VvbWV0cnkueGhyUmVxdWVzdCh1cmwsIHsgbW9kZTogJ2NvcnMnIH0pKVxuICAgICAgICAgICAgLnRoZW4ocmVzID0+IGhhbmRsZUZhaWxlZFJlcXVlc3QocmVzKSlcbiAgICAgICAgICAgIC50aGVuKG9rUmVzID0+IG9rUmVzLmFycmF5QnVmZmVyKCkpXG4gICAgICAgICAgICAudGhlbihidWZmZXIgPT4gaGFuZGxlRW1wdHlCdWZmZXIoYnVmZmVyKSlcbiAgICAgICAgICAgIC50aGVuKG9rQnVmZmVyID0+IHRoaXMubG9hZEhpZXJhcmNoeSh0aGlzLCBva0J1ZmZlcikpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB1cmwgb2YgdGhlIGZvbGRlciB3aGVyZSB0aGUgaGllcmFyY2h5IGlzLCByZWxhdGl2ZSB0byB0aGUgb2N0cmVlRGlyLlxuICAgICAqL1xuICAgIGdldEhpZXJhcmNoeUJhc2VVcmwoKSB7XG4gICAgICAgIGNvbnN0IGhpZXJhcmNoeVN0ZXBTaXplID0gdGhpcy5wY29HZW9tZXRyeS5oaWVyYXJjaHlTdGVwU2l6ZTtcbiAgICAgICAgY29uc3QgaW5kaWNlcyA9IHRoaXMubmFtZS5zdWJzdHIoMSk7XG4gICAgICAgIGNvbnN0IG51bVBhcnRzID0gTWF0aC5mbG9vcihpbmRpY2VzLmxlbmd0aCAvIGhpZXJhcmNoeVN0ZXBTaXplKTtcbiAgICAgICAgbGV0IHBhdGggPSAnci8nO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVBhcnRzOyBpKyspIHtcbiAgICAgICAgICAgIHBhdGggKz0gYCR7aW5kaWNlcy5zdWJzdHIoaSAqIGhpZXJhcmNoeVN0ZXBTaXplLCBoaWVyYXJjaHlTdGVwU2l6ZSl9L2A7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhdGguc2xpY2UoMCwgLTEpO1xuICAgIH1cbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZTpuby1iaXR3aXNlXG4gICAgbG9hZEhpZXJhcmNoeShub2RlLCBidWZmZXIpIHtcbiAgICAgICAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIpO1xuICAgICAgICBjb25zdCBmaXJzdE5vZGVEYXRhID0gdGhpcy5nZXROb2RlRGF0YShub2RlLm5hbWUsIDAsIHZpZXcpO1xuICAgICAgICBub2RlLm51bVBvaW50cyA9IGZpcnN0Tm9kZURhdGEubnVtUG9pbnRzO1xuICAgICAgICAvLyBOb2RlcyB3aGljaCBuZWVkIGJlIHZpc2l0ZWQuXG4gICAgICAgIGNvbnN0IHN0YWNrID0gW2ZpcnN0Tm9kZURhdGFdO1xuICAgICAgICAvLyBOb2RlcyB3aGljaCBoYXZlIGFscmVhZHkgYmVlbiBkZWNvZGVkLiBXZSB3aWxsIHRha2Ugbm9kZXMgZnJvbSB0aGUgc3RhY2sgYW5kIHBsYWNlIHRoZW0gaGVyZS5cbiAgICAgICAgY29uc3QgZGVjb2RlZCA9IFtdO1xuICAgICAgICBsZXQgb2Zmc2V0ID0gTk9ERV9TVFJJREU7XG4gICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBzdGFja05vZGVEYXRhID0gc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgIC8vIEZyb20gdGhlIGxhc3QgYml0LCBhbGwgdGhlIHdheSB0byB0aGUgOHRoIG9uZSBmcm9tIHRoZSByaWdodC5cbiAgICAgICAgICAgIGxldCBtYXNrID0gMTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgOCAmJiBvZmZzZXQgKyAxIDwgYnVmZmVyLmJ5dGVMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICgoc3RhY2tOb2RlRGF0YS5jaGlsZHJlbiAmIG1hc2spICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vZGVEYXRhID0gdGhpcy5nZXROb2RlRGF0YShzdGFja05vZGVEYXRhLm5hbWUgKyBpLCBvZmZzZXQsIHZpZXcpO1xuICAgICAgICAgICAgICAgICAgICBkZWNvZGVkLnB1c2gobm9kZURhdGEpOyAvLyBOb2RlIGlzIGRlY29kZWQuXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2gobm9kZURhdGEpOyAvLyBOZWVkIHRvIGNoZWNrIGl0cyBjaGlsZHJlbi5cbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ICs9IE5PREVfU1RSSURFOyAvLyBNb3ZlIG92ZXIgdG8gdGhlIG5leHQgbm9kZSBpbiB0aGUgYnVmZmVyLlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtYXNrID0gbWFzayAqIDI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5wY29HZW9tZXRyeS5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgIC8vIE1hcCBjb250YWluaW5nIGFsbCB0aGUgbm9kZXMuXG4gICAgICAgIGNvbnN0IG5vZGVzID0gbmV3IE1hcCgpO1xuICAgICAgICBub2Rlcy5zZXQobm9kZS5uYW1lLCBub2RlKTtcbiAgICAgICAgZGVjb2RlZC5mb3JFYWNoKG5vZGVEYXRhID0+IHRoaXMuYWRkTm9kZShub2RlRGF0YSwgbm9kZS5wY29HZW9tZXRyeSwgbm9kZXMpKTtcbiAgICAgICAgbm9kZS5sb2FkUG9pbnRzKCk7XG4gICAgfVxuICAgIC8vIHRzbGludDplbmFibGU6bm8tYml0d2lzZVxuICAgIGdldE5vZGVEYXRhKG5hbWUsIG9mZnNldCwgdmlldykge1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHZpZXcuZ2V0VWludDgob2Zmc2V0KTtcbiAgICAgICAgY29uc3QgbnVtUG9pbnRzID0gdmlldy5nZXRVaW50MzIob2Zmc2V0ICsgMSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB7IGNoaWxkcmVuOiBjaGlsZHJlbiwgbnVtUG9pbnRzOiBudW1Qb2ludHMsIG5hbWUgfTtcbiAgICB9XG4gICAgYWRkTm9kZSh7IG5hbWUsIG51bVBvaW50cywgY2hpbGRyZW4gfSwgcGNvLCBub2Rlcykge1xuICAgICAgICBjb25zdCBpbmRleCA9IGdldEluZGV4RnJvbU5hbWUobmFtZSk7XG4gICAgICAgIGNvbnN0IHBhcmVudE5hbWUgPSBuYW1lLnN1YnN0cmluZygwLCBuYW1lLmxlbmd0aCAtIDEpO1xuICAgICAgICBjb25zdCBwYXJlbnROb2RlID0gbm9kZXMuZ2V0KHBhcmVudE5hbWUpO1xuICAgICAgICBjb25zdCBsZXZlbCA9IG5hbWUubGVuZ3RoIC0gMTtcbiAgICAgICAgY29uc3QgYm91bmRpbmdCb3ggPSBjcmVhdGVDaGlsZEFBQkIocGFyZW50Tm9kZS5ib3VuZGluZ0JveCwgaW5kZXgpO1xuICAgICAgICBjb25zdCBub2RlID0gbmV3IFBvaW50Q2xvdWRPY3RyZWVHZW9tZXRyeU5vZGUobmFtZSwgcGNvLCBib3VuZGluZ0JveCk7XG4gICAgICAgIG5vZGUubGV2ZWwgPSBsZXZlbDtcbiAgICAgICAgbm9kZS5udW1Qb2ludHMgPSBudW1Qb2ludHM7XG4gICAgICAgIG5vZGUuaGFzQ2hpbGRyZW4gPSBjaGlsZHJlbiA+IDA7XG4gICAgICAgIG5vZGUuc3BhY2luZyA9IHBjby5zcGFjaW5nIC8gTWF0aC5wb3coMiwgbGV2ZWwpO1xuICAgICAgICBwYXJlbnROb2RlLmFkZENoaWxkKG5vZGUpO1xuICAgICAgICBub2Rlcy5zZXQobmFtZSwgbm9kZSk7XG4gICAgfVxufVxuUG9pbnRDbG91ZE9jdHJlZUdlb21ldHJ5Tm9kZS5pZENvdW50ID0gMDtcbiIsImltcG9ydCB7IFBvaW50QXR0cmlidXRlcyB9IGZyb20gJy4vcG9pbnQtYXR0cmlidXRlcyc7XG5leHBvcnQgY2xhc3MgUG9pbnRDbG91ZE9jdHJlZUdlb21ldHJ5IHtcbiAgICBjb25zdHJ1Y3Rvcihsb2FkZXIsIGJvdW5kaW5nQm94LCB0aWdodEJvdW5kaW5nQm94LCBvZmZzZXQsIHhoclJlcXVlc3QpIHtcbiAgICAgICAgdGhpcy5sb2FkZXIgPSBsb2FkZXI7XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3ggPSBib3VuZGluZ0JveDtcbiAgICAgICAgdGhpcy50aWdodEJvdW5kaW5nQm94ID0gdGlnaHRCb3VuZGluZ0JveDtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIHRoaXMueGhyUmVxdWVzdCA9IHhoclJlcXVlc3Q7XG4gICAgICAgIHRoaXMuZGlzcG9zZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgIHRoaXMub2N0cmVlRGlyID0gJyc7XG4gICAgICAgIHRoaXMuaGllcmFyY2h5U3RlcFNpemUgPSAtMTtcbiAgICAgICAgdGhpcy5ub2RlcyA9IHt9O1xuICAgICAgICB0aGlzLm51bU5vZGVzTG9hZGluZyA9IDA7XG4gICAgICAgIHRoaXMubWF4TnVtTm9kZXNMb2FkaW5nID0gMztcbiAgICAgICAgdGhpcy5zcGFjaW5nID0gMDtcbiAgICAgICAgdGhpcy5wb2ludEF0dHJpYnV0ZXMgPSBuZXcgUG9pbnRBdHRyaWJ1dGVzKFtdKTtcbiAgICAgICAgdGhpcy5wcm9qZWN0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy51cmwgPSBudWxsO1xuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICB0aGlzLmxvYWRlci5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMucm9vdC50cmF2ZXJzZShub2RlID0+IG5vZGUuZGlzcG9zZSgpKTtcbiAgICAgICAgdGhpcy5kaXNwb3NlZCA9IHRydWU7XG4gICAgfVxuICAgIGFkZE5vZGVMb2FkZWRDYWxsYmFjayhjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmxvYWRlci5jYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgfVxuICAgIGNsZWFyTm9kZUxvYWRlZENhbGxiYWNrcygpIHtcbiAgICAgICAgdGhpcy5sb2FkZXIuY2FsbGJhY2tzID0gW107XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgQnVmZmVyR2VvbWV0cnksIEV2ZW50RGlzcGF0Y2hlciB9IGZyb20gJ3RocmVlJztcbmV4cG9ydCBjbGFzcyBQb2ludENsb3VkT2N0cmVlTm9kZSBleHRlbmRzIEV2ZW50RGlzcGF0Y2hlciB7XG4gICAgY29uc3RydWN0b3IoZ2VvbWV0cnlOb2RlLCBzY2VuZU5vZGUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5wY0luZGV4ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94Tm9kZSA9IG51bGw7XG4gICAgICAgIHRoaXMubG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pc1RyZWVOb2RlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pc0dlb21ldHJ5Tm9kZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmdlb21ldHJ5Tm9kZSA9IGdlb21ldHJ5Tm9kZTtcbiAgICAgICAgdGhpcy5zY2VuZU5vZGUgPSBzY2VuZU5vZGU7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBnZW9tZXRyeU5vZGUuY2hpbGRyZW4uc2xpY2UoKTtcbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgdGhpcy5nZW9tZXRyeU5vZGUuZGlzcG9zZSgpO1xuICAgIH1cbiAgICBkaXNwb3NlU2NlbmVOb2RlKCkge1xuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5zY2VuZU5vZGU7XG4gICAgICAgIGlmIChub2RlLmdlb21ldHJ5IGluc3RhbmNlb2YgQnVmZmVyR2VvbWV0cnkpIHtcbiAgICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBub2RlLmdlb21ldHJ5LmF0dHJpYnV0ZXM7XG4gICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6Zm9yaW5cbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSAncG9zaXRpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBhdHRyaWJ1dGVzW2tleV0uYXJyYXk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlbGV0ZSBhdHRyaWJ1dGVzW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlLmdlb21ldHJ5LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIG5vZGUuZ2VvbWV0cnkgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdHJhdmVyc2UoY2IsIGluY2x1ZGVTZWxmKSB7XG4gICAgICAgIHRoaXMuZ2VvbWV0cnlOb2RlLnRyYXZlcnNlKGNiLCBpbmNsdWRlU2VsZik7XG4gICAgfVxuICAgIGdldCBpZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2VvbWV0cnlOb2RlLmlkO1xuICAgIH1cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2VvbWV0cnlOb2RlLm5hbWU7XG4gICAgfVxuICAgIGdldCBsZXZlbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2VvbWV0cnlOb2RlLmxldmVsO1xuICAgIH1cbiAgICBnZXQgaXNMZWFmTm9kZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2VvbWV0cnlOb2RlLmlzTGVhZk5vZGU7XG4gICAgfVxuICAgIGdldCBudW1Qb2ludHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdlb21ldHJ5Tm9kZS5udW1Qb2ludHM7XG4gICAgfVxuICAgIGdldCBpbmRleCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2VvbWV0cnlOb2RlLmluZGV4O1xuICAgIH1cbiAgICBnZXQgYm91bmRpbmdTcGhlcmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdlb21ldHJ5Tm9kZS5ib3VuZGluZ1NwaGVyZTtcbiAgICB9XG4gICAgZ2V0IGJvdW5kaW5nQm94KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZW9tZXRyeU5vZGUuYm91bmRpbmdCb3g7XG4gICAgfVxuICAgIGdldCBzcGFjaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZW9tZXRyeU5vZGUuc3BhY2luZztcbiAgICB9XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gY2xhbXAodmFsdWUsIG1pbiwgbWF4KSB7XG4gICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KG1pbiwgdmFsdWUpLCBtYXgpO1xufVxuIiwiaW1wb3J0IHsgQ29sb3IsIExpbmVhckZpbHRlciwgTmVhcmVzdEZpbHRlciwgTm9CbGVuZGluZywgUG9pbnRzLCBSR0JBRm9ybWF0LCBTY2VuZSwgU3BoZXJlLCBWZWN0b3IzLCBWZWN0b3I0LCBXZWJHTFJlbmRlclRhcmdldCwgfSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgeyBDT0xPUl9CTEFDSywgREVGQVVMVF9QSUNLX1dJTkRPV19TSVpFIH0gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgQ2xpcE1vZGUsIFBvaW50Q2xvdWRNYXRlcmlhbCwgUG9pbnRDb2xvclR5cGUgfSBmcm9tICcuL21hdGVyaWFscyc7XG5pbXBvcnQgeyBjbGFtcCB9IGZyb20gJy4vdXRpbHMvbWF0aCc7XG5leHBvcnQgY2xhc3MgUG9pbnRDbG91ZE9jdHJlZVBpY2tlciB7XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMucGlja1N0YXRlKSB7XG4gICAgICAgICAgICB0aGlzLnBpY2tTdGF0ZS5tYXRlcmlhbC5kaXNwb3NlKCk7XG4gICAgICAgICAgICB0aGlzLnBpY2tTdGF0ZS5yZW5kZXJUYXJnZXQuZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHBpY2socmVuZGVyZXIsIGNhbWVyYSwgcmF5LCBvY3RyZWVzLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBpZiAob2N0cmVlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBpY2tTdGF0ZSA9IHRoaXMucGlja1N0YXRlXG4gICAgICAgICAgICA/IHRoaXMucGlja1N0YXRlXG4gICAgICAgICAgICA6ICh0aGlzLnBpY2tTdGF0ZSA9IFBvaW50Q2xvdWRPY3RyZWVQaWNrZXIuZ2V0UGlja1N0YXRlKCkpO1xuICAgICAgICBjb25zdCBwaWNrTWF0ZXJpYWwgPSBwaWNrU3RhdGUubWF0ZXJpYWw7XG4gICAgICAgIGNvbnN0IHBpeGVsUmF0aW8gPSByZW5kZXJlci5nZXRQaXhlbFJhdGlvKCk7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gTWF0aC5jZWlsKHJlbmRlcmVyLmRvbUVsZW1lbnQuY2xpZW50V2lkdGggKiBwaXhlbFJhdGlvKTtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5jZWlsKHJlbmRlcmVyLmRvbUVsZW1lbnQuY2xpZW50SGVpZ2h0ICogcGl4ZWxSYXRpbyk7XG4gICAgICAgIFBvaW50Q2xvdWRPY3RyZWVQaWNrZXIudXBkYXRlUGlja1JlbmRlclRhcmdldCh0aGlzLnBpY2tTdGF0ZSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIGNvbnN0IHBpeGVsUG9zaXRpb24gPSBQb2ludENsb3VkT2N0cmVlUGlja2VyLmhlbHBlclZlYzM7IC8vIFVzZSBoZWxwZXIgdmVjdG9yIHRvIHByZXZlbnQgZXh0cmEgYWxsb2NhdGlvbnMuXG4gICAgICAgIGlmIChwYXJhbXMucGl4ZWxQb3NpdGlvbikge1xuICAgICAgICAgICAgcGl4ZWxQb3NpdGlvbi5jb3B5KHBhcmFtcy5waXhlbFBvc2l0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBpeGVsUG9zaXRpb24uYWRkVmVjdG9ycyhjYW1lcmEucG9zaXRpb24sIHJheS5kaXJlY3Rpb24pLnByb2plY3QoY2FtZXJhKTtcbiAgICAgICAgICAgIHBpeGVsUG9zaXRpb24ueCA9IChwaXhlbFBvc2l0aW9uLnggKyAxKSAqIHdpZHRoICogMC41O1xuICAgICAgICAgICAgcGl4ZWxQb3NpdGlvbi55ID0gKHBpeGVsUG9zaXRpb24ueSArIDEpICogaGVpZ2h0ICogMC41O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBpY2tXbmRTaXplID0gTWF0aC5mbG9vcigocGFyYW1zLnBpY2tXaW5kb3dTaXplIHx8IERFRkFVTFRfUElDS19XSU5ET1dfU0laRSkgKiBwaXhlbFJhdGlvKTtcbiAgICAgICAgY29uc3QgaGFsZlBpY2tXbmRTaXplID0gKHBpY2tXbmRTaXplIC0gMSkgLyAyO1xuICAgICAgICBjb25zdCB4ID0gTWF0aC5mbG9vcihjbGFtcChwaXhlbFBvc2l0aW9uLnggLSBoYWxmUGlja1duZFNpemUsIDAsIHdpZHRoKSk7XG4gICAgICAgIGNvbnN0IHkgPSBNYXRoLmZsb29yKGNsYW1wKHBpeGVsUG9zaXRpb24ueSAtIGhhbGZQaWNrV25kU2l6ZSwgMCwgaGVpZ2h0KSk7XG4gICAgICAgIFBvaW50Q2xvdWRPY3RyZWVQaWNrZXIucHJlcGFyZVJlbmRlcihyZW5kZXJlciwgeCwgeSwgcGlja1duZFNpemUsIHBpY2tNYXRlcmlhbCwgcGlja1N0YXRlKTtcbiAgICAgICAgY29uc3QgcmVuZGVyZWROb2RlcyA9IFBvaW50Q2xvdWRPY3RyZWVQaWNrZXIucmVuZGVyKHJlbmRlcmVyLCBjYW1lcmEsIHBpY2tNYXRlcmlhbCwgb2N0cmVlcywgcmF5LCBwaWNrU3RhdGUsIHBhcmFtcyk7XG4gICAgICAgIC8vIENsZWFudXBcbiAgICAgICAgcGlja01hdGVyaWFsLmNsZWFyVmlzaWJsZU5vZGVUZXh0dXJlT2Zmc2V0cygpO1xuICAgICAgICAvLyBSZWFkIGJhY2sgaW1hZ2UgYW5kIGRlY29kZSBoaXQgcG9pbnRcbiAgICAgICAgY29uc3QgcGl4ZWxzID0gUG9pbnRDbG91ZE9jdHJlZVBpY2tlci5yZWFkUGl4ZWxzKHJlbmRlcmVyLCB4LCB5LCBwaWNrV25kU2l6ZSk7XG4gICAgICAgIGNvbnN0IGhpdCA9IFBvaW50Q2xvdWRPY3RyZWVQaWNrZXIuZmluZEhpdChwaXhlbHMsIHBpY2tXbmRTaXplKTtcbiAgICAgICAgcmV0dXJuIFBvaW50Q2xvdWRPY3RyZWVQaWNrZXIuZ2V0UGlja1BvaW50KGhpdCwgcmVuZGVyZWROb2Rlcyk7XG4gICAgfVxuICAgIHN0YXRpYyBwcmVwYXJlUmVuZGVyKHJlbmRlcmVyLCB4LCB5LCBwaWNrV25kU2l6ZSwgcGlja01hdGVyaWFsLCBwaWNrU3RhdGUpIHtcbiAgICAgICAgLy8gUmVuZGVyIHRoZSBpbnRlcnNlY3RlZCBub2RlcyBvbnRvIHRoZSBwaWNrIHJlbmRlciB0YXJnZXQsIGNsaXBwaW5nIHRvIGEgc21hbGwgcGljayB3aW5kb3cuXG4gICAgICAgIHJlbmRlcmVyLnNldFNjaXNzb3IoeCwgeSwgcGlja1duZFNpemUsIHBpY2tXbmRTaXplKTtcbiAgICAgICAgcmVuZGVyZXIuc2V0U2Npc3NvclRlc3QodHJ1ZSk7XG4gICAgICAgIHJlbmRlcmVyLnN0YXRlLmJ1ZmZlcnMuZGVwdGguc2V0VGVzdChwaWNrTWF0ZXJpYWwuZGVwdGhUZXN0KTtcbiAgICAgICAgcmVuZGVyZXIuc3RhdGUuYnVmZmVycy5kZXB0aC5zZXRNYXNrKHBpY2tNYXRlcmlhbC5kZXB0aFdyaXRlKTtcbiAgICAgICAgcmVuZGVyZXIuc3RhdGUuc2V0QmxlbmRpbmcoTm9CbGVuZGluZyk7XG4gICAgICAgIHJlbmRlcmVyLnNldFJlbmRlclRhcmdldChwaWNrU3RhdGUucmVuZGVyVGFyZ2V0KTtcbiAgICAgICAgLy8gU2F2ZSB0aGUgY3VycmVudCBjbGVhciBjb2xvciBhbmQgY2xlYXIgdGhlIHJlbmRlcmVyIHdpdGggYmxhY2sgY29sb3IgYW5kIGFscGhhIDAuXG4gICAgICAgIHJlbmRlcmVyLmdldENsZWFyQ29sb3IodGhpcy5jbGVhckNvbG9yKTtcbiAgICAgICAgY29uc3Qgb2xkQ2xlYXJBbHBoYSA9IHJlbmRlcmVyLmdldENsZWFyQWxwaGEoKTtcbiAgICAgICAgcmVuZGVyZXIuc2V0Q2xlYXJDb2xvcihDT0xPUl9CTEFDSywgMCk7XG4gICAgICAgIHJlbmRlcmVyLmNsZWFyKHRydWUsIHRydWUsIHRydWUpO1xuICAgICAgICByZW5kZXJlci5zZXRDbGVhckNvbG9yKHRoaXMuY2xlYXJDb2xvciwgb2xkQ2xlYXJBbHBoYSk7XG4gICAgfVxuICAgIHN0YXRpYyByZW5kZXIocmVuZGVyZXIsIGNhbWVyYSwgcGlja01hdGVyaWFsLCBvY3RyZWVzLCByYXksIHBpY2tTdGF0ZSwgcGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IHJlbmRlcmVkTm9kZXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBvY3RyZWUgb2Ygb2N0cmVlcykge1xuICAgICAgICAgICAgLy8gR2V0IGFsbCB0aGUgb2N0cmVlIG5vZGVzIHdoaWNoIGludGVyc2VjdCB0aGUgcGlja2luZyByYXkuIFdlIG9ubHkgbmVlZCB0byByZW5kZXIgdGhvc2UuXG4gICAgICAgICAgICBjb25zdCBub2RlcyA9IFBvaW50Q2xvdWRPY3RyZWVQaWNrZXIubm9kZXNPblJheShvY3RyZWUsIHJheSk7XG4gICAgICAgICAgICBpZiAoIW5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUG9pbnRDbG91ZE9jdHJlZVBpY2tlci51cGRhdGVQaWNrTWF0ZXJpYWwocGlja01hdGVyaWFsLCBvY3RyZWUubWF0ZXJpYWwsIHBhcmFtcyk7XG4gICAgICAgICAgICBwaWNrTWF0ZXJpYWwudXBkYXRlTWF0ZXJpYWwob2N0cmVlLCBub2RlcywgY2FtZXJhLCByZW5kZXJlcik7XG4gICAgICAgICAgICBpZiAocGFyYW1zLm9uQmVmb3JlUGlja1JlbmRlcikge1xuICAgICAgICAgICAgICAgIHBhcmFtcy5vbkJlZm9yZVBpY2tSZW5kZXIocGlja01hdGVyaWFsLCBwaWNrU3RhdGUucmVuZGVyVGFyZ2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENyZWF0ZSBjb3BpZXMgb2YgdGhlIG5vZGVzIHNvIHdlIGNhbiByZW5kZXIgdGhlbSBkaWZmZXJlbnRseSB0aGFuIGluIHRoZSBub3JtYWwgcG9pbnQgY2xvdWQuXG4gICAgICAgICAgICBwaWNrU3RhdGUuc2NlbmUuY2hpbGRyZW4gPSBQb2ludENsb3VkT2N0cmVlUGlja2VyLmNyZWF0ZVRlbXBOb2RlcyhvY3RyZWUsIG5vZGVzLCBwaWNrTWF0ZXJpYWwsIHJlbmRlcmVkTm9kZXMubGVuZ3RoKTtcbiAgICAgICAgICAgIHJlbmRlcmVyLnJlbmRlcihwaWNrU3RhdGUuc2NlbmUsIGNhbWVyYSk7XG4gICAgICAgICAgICBub2Rlcy5mb3JFYWNoKG5vZGUgPT4gcmVuZGVyZWROb2Rlcy5wdXNoKHsgbm9kZSwgb2N0cmVlIH0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVuZGVyZWROb2RlcztcbiAgICB9XG4gICAgc3RhdGljIG5vZGVzT25SYXkob2N0cmVlLCByYXkpIHtcbiAgICAgICAgY29uc3Qgbm9kZXNPblJheSA9IFtdO1xuICAgICAgICBjb25zdCByYXlDbG9uZSA9IHJheS5jbG9uZSgpO1xuICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygb2N0cmVlLnZpc2libGVOb2Rlcykge1xuICAgICAgICAgICAgY29uc3Qgc3BoZXJlID0gUG9pbnRDbG91ZE9jdHJlZVBpY2tlci5oZWxwZXJTcGhlcmVcbiAgICAgICAgICAgICAgICAuY29weShub2RlLmJvdW5kaW5nU3BoZXJlKVxuICAgICAgICAgICAgICAgIC5hcHBseU1hdHJpeDQob2N0cmVlLm1hdHJpeFdvcmxkKTtcbiAgICAgICAgICAgIGlmIChyYXlDbG9uZS5pbnRlcnNlY3RzU3BoZXJlKHNwaGVyZSkpIHtcbiAgICAgICAgICAgICAgICBub2Rlc09uUmF5LnB1c2gobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGVzT25SYXk7XG4gICAgfVxuICAgIHN0YXRpYyByZWFkUGl4ZWxzKHJlbmRlcmVyLCB4LCB5LCBwaWNrV25kU2l6ZSkge1xuICAgICAgICAvLyBSZWFkIHRoZSBwaXhlbCBmcm9tIHRoZSBwaWNrIHJlbmRlciB0YXJnZXQuXG4gICAgICAgIGNvbnN0IHBpeGVscyA9IG5ldyBVaW50OEFycmF5KDQgKiBwaWNrV25kU2l6ZSAqIHBpY2tXbmRTaXplKTtcbiAgICAgICAgcmVuZGVyZXIucmVhZFJlbmRlclRhcmdldFBpeGVscyhyZW5kZXJlci5nZXRSZW5kZXJUYXJnZXQoKSwgeCwgeSwgcGlja1duZFNpemUsIHBpY2tXbmRTaXplLCBwaXhlbHMpO1xuICAgICAgICByZW5kZXJlci5zZXRTY2lzc29yVGVzdChmYWxzZSk7XG4gICAgICAgIHJlbmRlcmVyLnNldFJlbmRlclRhcmdldChudWxsKTtcbiAgICAgICAgcmV0dXJuIHBpeGVscztcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZVRlbXBOb2RlcyhvY3RyZWUsIG5vZGVzLCBwaWNrTWF0ZXJpYWwsIG5vZGVJbmRleE9mZnNldCkge1xuICAgICAgICBjb25zdCB0ZW1wTm9kZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICAgICAgY29uc3Qgc2NlbmVOb2RlID0gbm9kZS5zY2VuZU5vZGU7XG4gICAgICAgICAgICBjb25zdCB0ZW1wTm9kZSA9IG5ldyBQb2ludHMoc2NlbmVOb2RlLmdlb21ldHJ5LCBwaWNrTWF0ZXJpYWwpO1xuICAgICAgICAgICAgdGVtcE5vZGUubWF0cml4ID0gc2NlbmVOb2RlLm1hdHJpeDtcbiAgICAgICAgICAgIHRlbXBOb2RlLm1hdHJpeFdvcmxkID0gc2NlbmVOb2RlLm1hdHJpeFdvcmxkO1xuICAgICAgICAgICAgdGVtcE5vZGUubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGVtcE5vZGUuZnJ1c3R1bUN1bGxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgY29uc3Qgbm9kZUluZGV4ID0gbm9kZUluZGV4T2Zmc2V0ICsgaSArIDE7XG4gICAgICAgICAgICBpZiAobm9kZUluZGV4ID4gMjU1KSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignTW9yZSB0aGFuIDI1NSBub2RlcyBmb3IgcGljayBhcmUgbm90IHN1cHBvcnRlZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRlbXBOb2RlLm9uQmVmb3JlUmVuZGVyID0gUG9pbnRDbG91ZE1hdGVyaWFsLm1ha2VPbkJlZm9yZVJlbmRlcihvY3RyZWUsIG5vZGUsIG5vZGVJbmRleCk7XG4gICAgICAgICAgICB0ZW1wTm9kZXMucHVzaCh0ZW1wTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRlbXBOb2RlcztcbiAgICB9XG4gICAgc3RhdGljIHVwZGF0ZVBpY2tNYXRlcmlhbChwaWNrTWF0ZXJpYWwsIG5vZGVNYXRlcmlhbCwgcGFyYW1zKSB7XG4gICAgICAgIHBpY2tNYXRlcmlhbC5wb2ludFNpemVUeXBlID0gbm9kZU1hdGVyaWFsLnBvaW50U2l6ZVR5cGU7XG4gICAgICAgIHBpY2tNYXRlcmlhbC5zaGFwZSA9IG5vZGVNYXRlcmlhbC5zaGFwZTtcbiAgICAgICAgcGlja01hdGVyaWFsLnNpemUgPSBub2RlTWF0ZXJpYWwuc2l6ZTtcbiAgICAgICAgcGlja01hdGVyaWFsLm1pblNpemUgPSBub2RlTWF0ZXJpYWwubWluU2l6ZTtcbiAgICAgICAgcGlja01hdGVyaWFsLm1heFNpemUgPSBub2RlTWF0ZXJpYWwubWF4U2l6ZTtcbiAgICAgICAgcGlja01hdGVyaWFsLmNsYXNzaWZpY2F0aW9uID0gbm9kZU1hdGVyaWFsLmNsYXNzaWZpY2F0aW9uO1xuICAgICAgICBwaWNrTWF0ZXJpYWwudXNlRmlsdGVyQnlOb3JtYWwgPSBub2RlTWF0ZXJpYWwudXNlRmlsdGVyQnlOb3JtYWw7XG4gICAgICAgIHBpY2tNYXRlcmlhbC5maWx0ZXJCeU5vcm1hbFRocmVzaG9sZCA9IG5vZGVNYXRlcmlhbC5maWx0ZXJCeU5vcm1hbFRocmVzaG9sZDtcbiAgICAgICAgaWYgKHBhcmFtcy5waWNrT3V0c2lkZUNsaXBSZWdpb24pIHtcbiAgICAgICAgICAgIHBpY2tNYXRlcmlhbC5jbGlwTW9kZSA9IENsaXBNb2RlLkRJU0FCTEVEO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGlja01hdGVyaWFsLmNsaXBNb2RlID0gbm9kZU1hdGVyaWFsLmNsaXBNb2RlO1xuICAgICAgICAgICAgcGlja01hdGVyaWFsLnNldENsaXBCb3hlcyhub2RlTWF0ZXJpYWwuY2xpcE1vZGUgPT09IENsaXBNb2RlLkNMSVBfT1VUU0lERSA/IG5vZGVNYXRlcmlhbC5jbGlwQm94ZXMgOiBbXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIHVwZGF0ZVBpY2tSZW5kZXJUYXJnZXQocGlja1N0YXRlLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIGlmIChwaWNrU3RhdGUucmVuZGVyVGFyZ2V0LndpZHRoID09PSB3aWR0aCAmJiBwaWNrU3RhdGUucmVuZGVyVGFyZ2V0LmhlaWdodCA9PT0gaGVpZ2h0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcGlja1N0YXRlLnJlbmRlclRhcmdldC5kaXNwb3NlKCk7XG4gICAgICAgIHBpY2tTdGF0ZS5yZW5kZXJUYXJnZXQgPSBQb2ludENsb3VkT2N0cmVlUGlja2VyLm1ha2VQaWNrUmVuZGVyVGFyZ2V0KCk7XG4gICAgICAgIHBpY2tTdGF0ZS5yZW5kZXJUYXJnZXQuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICB9XG4gICAgc3RhdGljIG1ha2VQaWNrUmVuZGVyVGFyZ2V0KCkge1xuICAgICAgICByZXR1cm4gbmV3IFdlYkdMUmVuZGVyVGFyZ2V0KDEsIDEsIHtcbiAgICAgICAgICAgIG1pbkZpbHRlcjogTGluZWFyRmlsdGVyLFxuICAgICAgICAgICAgbWFnRmlsdGVyOiBOZWFyZXN0RmlsdGVyLFxuICAgICAgICAgICAgZm9ybWF0OiBSR0JBRm9ybWF0LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIGZpbmRIaXQocGl4ZWxzLCBwaWNrV25kU2l6ZSkge1xuICAgICAgICBjb25zdCBpYnVmZmVyID0gbmV3IFVpbnQzMkFycmF5KHBpeGVscy5idWZmZXIpO1xuICAgICAgICAvLyBGaW5kIGNsb3Nlc3QgaGl0IGluc2lkZSBwaXhlbFdpbmRvdyBib3VuZGFyaWVzXG4gICAgICAgIGxldCBtaW4gPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICBsZXQgaGl0ID0gbnVsbDtcbiAgICAgICAgZm9yIChsZXQgdSA9IDA7IHUgPCBwaWNrV25kU2l6ZTsgdSsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB2ID0gMDsgdiA8IHBpY2tXbmRTaXplOyB2KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQgPSB1ICsgdiAqIHBpY2tXbmRTaXplO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRpc3RhbmNlID0gTWF0aC5wb3codSAtIChwaWNrV25kU2l6ZSAtIDEpIC8gMiwgMikgKyBNYXRoLnBvdyh2IC0gKHBpY2tXbmRTaXplIC0gMSkgLyAyLCAyKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwY0luZGV4ID0gcGl4ZWxzWzQgKiBvZmZzZXQgKyAzXTtcbiAgICAgICAgICAgICAgICBwaXhlbHNbNCAqIG9mZnNldCArIDNdID0gMDtcbiAgICAgICAgICAgICAgICBjb25zdCBwSW5kZXggPSBpYnVmZmVyW29mZnNldF07XG4gICAgICAgICAgICAgICAgaWYgKHBjSW5kZXggPiAwICYmIGRpc3RhbmNlIDwgbWluKSB7XG4gICAgICAgICAgICAgICAgICAgIGhpdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBJbmRleDogcEluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgcGNJbmRleDogcGNJbmRleCAtIDEsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IGRpc3RhbmNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGl0O1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0UGlja1BvaW50KGhpdCwgbm9kZXMpIHtcbiAgICAgICAgaWYgKCFoaXQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBvaW50ID0ge307XG4gICAgICAgIGNvbnN0IHBvaW50cyA9IG5vZGVzW2hpdC5wY0luZGV4XSAmJiBub2Rlc1toaXQucGNJbmRleF0ubm9kZS5zY2VuZU5vZGU7XG4gICAgICAgIGlmICghcG9pbnRzKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBwb2ludC5wb2ludENsb3VkID0gbm9kZXNbaGl0LnBjSW5kZXhdLm9jdHJlZTtcbiAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IHBvaW50cy5nZW9tZXRyeS5hdHRyaWJ1dGVzO1xuICAgICAgICBmb3IgKGNvbnN0IHByb3BlcnR5IGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgIGlmICghYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IGF0dHJpYnV0ZXNbcHJvcGVydHldO1xuICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOnByZWZlci1zd2l0Y2hcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0eSA9PT0gJ3Bvc2l0aW9uJykge1xuICAgICAgICAgICAgICAgIFBvaW50Q2xvdWRPY3RyZWVQaWNrZXIuYWRkUG9zaXRpb25Ub1BpY2tQb2ludChwb2ludCwgaGl0LCB2YWx1ZXMsIHBvaW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwcm9wZXJ0eSA9PT0gJ25vcm1hbCcpIHtcbiAgICAgICAgICAgICAgICBQb2ludENsb3VkT2N0cmVlUGlja2VyLmFkZE5vcm1hbFRvUGlja1BvaW50KHBvaW50LCBoaXQsIHZhbHVlcywgcG9pbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHByb3BlcnR5ID09PSAnaW5kaWNlcycpIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWVzLml0ZW1TaXplID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50W3Byb3BlcnR5XSA9IHZhbHVlcy5hcnJheVtoaXQucEluZGV4XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdmFsdWVzLml0ZW1TaXplOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLnB1c2godmFsdWVzLmFycmF5W3ZhbHVlcy5pdGVtU2l6ZSAqIGhpdC5wSW5kZXggKyBqXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcG9pbnRbcHJvcGVydHldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb2ludDtcbiAgICB9XG4gICAgc3RhdGljIGFkZFBvc2l0aW9uVG9QaWNrUG9pbnQocG9pbnQsIGhpdCwgdmFsdWVzLCBwb2ludHMpIHtcbiAgICAgICAgcG9pbnQucG9zaXRpb24gPSBuZXcgVmVjdG9yMygpXG4gICAgICAgICAgICAuZnJvbUJ1ZmZlckF0dHJpYnV0ZSh2YWx1ZXMsIGhpdC5wSW5kZXgpXG4gICAgICAgICAgICAuYXBwbHlNYXRyaXg0KHBvaW50cy5tYXRyaXhXb3JsZCk7XG4gICAgfVxuICAgIHN0YXRpYyBhZGROb3JtYWxUb1BpY2tQb2ludChwb2ludCwgaGl0LCB2YWx1ZXMsIHBvaW50cykge1xuICAgICAgICBjb25zdCBub3JtYWwgPSBuZXcgVmVjdG9yMygpLmZyb21CdWZmZXJBdHRyaWJ1dGUodmFsdWVzLCBoaXQucEluZGV4KTtcbiAgICAgICAgY29uc3Qgbm9ybWFsNCA9IG5ldyBWZWN0b3I0KG5vcm1hbC54LCBub3JtYWwueSwgbm9ybWFsLnosIDApLmFwcGx5TWF0cml4NChwb2ludHMubWF0cml4V29ybGQpO1xuICAgICAgICBub3JtYWwuc2V0KG5vcm1hbDQueCwgbm9ybWFsNC55LCBub3JtYWw0LnopO1xuICAgICAgICBwb2ludC5ub3JtYWwgPSBub3JtYWw7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRQaWNrU3RhdGUoKSB7XG4gICAgICAgIGNvbnN0IHNjZW5lID0gbmV3IFNjZW5lKCk7XG4gICAgICAgIHNjZW5lLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgbWF0ZXJpYWwgPSBuZXcgUG9pbnRDbG91ZE1hdGVyaWFsKCk7XG4gICAgICAgIG1hdGVyaWFsLnBvaW50Q29sb3JUeXBlID0gUG9pbnRDb2xvclR5cGUuUE9JTlRfSU5ERVg7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZW5kZXJUYXJnZXQ6IFBvaW50Q2xvdWRPY3RyZWVQaWNrZXIubWFrZVBpY2tSZW5kZXJUYXJnZXQoKSxcbiAgICAgICAgICAgIG1hdGVyaWFsOiBtYXRlcmlhbCxcbiAgICAgICAgICAgIHNjZW5lOiBzY2VuZSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5Qb2ludENsb3VkT2N0cmVlUGlja2VyLmhlbHBlclZlYzMgPSBuZXcgVmVjdG9yMygpO1xuUG9pbnRDbG91ZE9jdHJlZVBpY2tlci5oZWxwZXJTcGhlcmUgPSBuZXcgU3BoZXJlKCk7XG5Qb2ludENsb3VkT2N0cmVlUGlja2VyLmNsZWFyQ29sb3IgPSBuZXcgQ29sb3IoKTtcbiIsImltcG9ydCB7IFNwaGVyZSB9IGZyb20gJ3RocmVlJztcbmV4cG9ydCBjbGFzcyBPY3RyZWVHZW9tZXRyeSB7XG4gICAgY29uc3RydWN0b3IobG9hZGVyLCBib3VuZGluZ0JveCkge1xuICAgICAgICB0aGlzLmxvYWRlciA9IGxvYWRlcjtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveCA9IGJvdW5kaW5nQm94O1xuICAgICAgICB0aGlzLm1heE51bU5vZGVzTG9hZGluZyA9IDM7XG4gICAgICAgIHRoaXMubnVtTm9kZXNMb2FkaW5nID0gMDtcbiAgICAgICAgdGhpcy5kaXNwb3NlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnBvaW50QXR0cmlidXRlcyA9IG51bGw7XG4gICAgICAgIHRoaXMuc3BhY2luZyA9IDA7XG4gICAgICAgIHRoaXMudXJsID0gbnVsbDtcbiAgICAgICAgdGhpcy50aWdodEJvdW5kaW5nQm94ID0gdGhpcy5ib3VuZGluZ0JveC5jbG9uZSgpO1xuICAgICAgICB0aGlzLmJvdW5kaW5nU3BoZXJlID0gdGhpcy5ib3VuZGluZ0JveC5nZXRCb3VuZGluZ1NwaGVyZShuZXcgU3BoZXJlKCkpO1xuICAgICAgICB0aGlzLnRpZ2h0Qm91bmRpbmdTcGhlcmUgPSB0aGlzLmJvdW5kaW5nU3BoZXJlLmNsb25lKCk7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIHRoaXMucm9vdC50cmF2ZXJzZSgobm9kZSkgPT4gbm9kZS5kaXNwb3NlKCkpO1xuICAgICAgICB0aGlzLmRpc3Bvc2VkID0gdHJ1ZTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBPYmplY3QzRCB9IGZyb20gJ3RocmVlJztcbmV4cG9ydCBjbGFzcyBQb2ludENsb3VkVHJlZSBleHRlbmRzIE9iamVjdDNEIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5yb290ID0gbnVsbDtcbiAgICB9XG4gICAgaW5pdGlhbGl6ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvb3QgIT09IG51bGw7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgQm94MywgT2JqZWN0M0QsIFBvaW50cywgU3BoZXJlLCBWZWN0b3IzIH0gZnJvbSAndGhyZWUnO1xuaW1wb3J0IHsgREVGQVVMVF9NSU5fTk9ERV9QSVhFTF9TSVpFIH0gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgT2N0cmVlR2VvbWV0cnkgfSBmcm9tICcuL2xvYWRpbmcyL29jdHJlZS1nZW9tZXRyeSc7XG5pbXBvcnQgeyBQb2ludENsb3VkTWF0ZXJpYWwgfSBmcm9tICcuL21hdGVyaWFscyc7XG5pbXBvcnQgeyBQb2ludENsb3VkT2N0cmVlTm9kZSB9IGZyb20gJy4vcG9pbnQtY2xvdWQtb2N0cmVlLW5vZGUnO1xuaW1wb3J0IHsgUG9pbnRDbG91ZE9jdHJlZVBpY2tlciB9IGZyb20gJy4vcG9pbnQtY2xvdWQtb2N0cmVlLXBpY2tlcic7XG5pbXBvcnQgeyBQb2ludENsb3VkVHJlZSB9IGZyb20gJy4vcG9pbnQtY2xvdWQtdHJlZSc7XG5pbXBvcnQgeyBjb21wdXRlVHJhbnNmb3JtZWRCb3VuZGluZ0JveCB9IGZyb20gJy4vdXRpbHMvYm91bmRzJztcbmV4cG9ydCBjbGFzcyBQb2ludENsb3VkT2N0cmVlIGV4dGVuZHMgUG9pbnRDbG91ZFRyZWUge1xuICAgIGNvbnN0cnVjdG9yKHBvdHJlZSwgcGNvR2VvbWV0cnksIG1hdGVyaWFsKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZGlzcG9zZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sZXZlbCA9IDA7XG4gICAgICAgIHRoaXMubWF4TGV2ZWwgPSBJbmZpbml0eTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBtaW5pbXVtIHJhZGl1cyBvZiBhIG5vZGUncyBib3VuZGluZyBzcGhlcmUgb24gdGhlIHNjcmVlbiBpbiBvcmRlciB0byBiZSBkaXNwbGF5ZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1pbk5vZGVQaXhlbFNpemUgPSBERUZBVUxUX01JTl9OT0RFX1BJWEVMX1NJWkU7XG4gICAgICAgIHRoaXMucm9vdCA9IG51bGw7XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3hOb2RlcyA9IFtdO1xuICAgICAgICB0aGlzLnZpc2libGVOb2RlcyA9IFtdO1xuICAgICAgICB0aGlzLnZpc2libGVHZW9tZXRyeSA9IFtdO1xuICAgICAgICB0aGlzLm51bVZpc2libGVQb2ludHMgPSAwO1xuICAgICAgICB0aGlzLnNob3dCb3VuZGluZ0JveCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnZpc2libGVCb3VuZHMgPSBuZXcgQm94MygpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnJztcbiAgICAgICAgdGhpcy5wb3RyZWUgPSBwb3RyZWU7XG4gICAgICAgIHRoaXMucm9vdCA9IHBjb0dlb21ldHJ5LnJvb3Q7XG4gICAgICAgIHRoaXMucGNvR2VvbWV0cnkgPSBwY29HZW9tZXRyeTtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveCA9IHBjb0dlb21ldHJ5LmJvdW5kaW5nQm94O1xuICAgICAgICB0aGlzLmJvdW5kaW5nU3BoZXJlID0gdGhpcy5ib3VuZGluZ0JveC5nZXRCb3VuZGluZ1NwaGVyZShuZXcgU3BoZXJlKCkpO1xuICAgICAgICB0aGlzLnBvc2l0aW9uLmNvcHkocGNvR2VvbWV0cnkub2Zmc2V0KTtcbiAgICAgICAgdGhpcy51cGRhdGVNYXRyaXgoKTtcbiAgICAgICAgdGhpcy5tYXRlcmlhbCA9IG1hdGVyaWFsIHx8IHBjb0dlb21ldHJ5IGluc3RhbmNlb2YgT2N0cmVlR2VvbWV0cnkgPyBuZXcgUG9pbnRDbG91ZE1hdGVyaWFsKHsgY29sb3JSZ2JhOiB0cnVlIH0pIDogbmV3IFBvaW50Q2xvdWRNYXRlcmlhbCgpO1xuICAgICAgICB0aGlzLmluaXRNYXRlcmlhbCh0aGlzLm1hdGVyaWFsKTtcbiAgICB9XG4gICAgaW5pdE1hdGVyaWFsKG1hdGVyaWFsKSB7XG4gICAgICAgIHRoaXMudXBkYXRlTWF0cml4V29ybGQodHJ1ZSk7XG4gICAgICAgIGNvbnN0IHsgbWluLCBtYXggfSA9IGNvbXB1dGVUcmFuc2Zvcm1lZEJvdW5kaW5nQm94KHRoaXMucGNvR2VvbWV0cnkudGlnaHRCb3VuZGluZ0JveCB8fCB0aGlzLmdldEJvdW5kaW5nQm94V29ybGQoKSwgdGhpcy5tYXRyaXhXb3JsZCk7XG4gICAgICAgIGNvbnN0IGJXaWR0aCA9IG1heC56IC0gbWluLno7XG4gICAgICAgIG1hdGVyaWFsLmhlaWdodE1pbiA9IG1pbi56IC0gMC4yICogYldpZHRoO1xuICAgICAgICBtYXRlcmlhbC5oZWlnaHRNYXggPSBtYXgueiArIDAuMiAqIGJXaWR0aDtcbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMucm9vdCkge1xuICAgICAgICAgICAgdGhpcy5yb290LmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBjb0dlb21ldHJ5LnJvb3QudHJhdmVyc2UobiA9PiB0aGlzLnBvdHJlZS5scnUucmVtb3ZlKG4pKTtcbiAgICAgICAgdGhpcy5wY29HZW9tZXRyeS5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMubWF0ZXJpYWwuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLnZpc2libGVOb2RlcyA9IFtdO1xuICAgICAgICB0aGlzLnZpc2libGVHZW9tZXRyeSA9IFtdO1xuICAgICAgICBpZiAodGhpcy5waWNrZXIpIHtcbiAgICAgICAgICAgIHRoaXMucGlja2VyLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHRoaXMucGlja2VyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGlzcG9zZWQgPSB0cnVlO1xuICAgIH1cbiAgICBnZXQgcG9pbnRTaXplVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWF0ZXJpYWwucG9pbnRTaXplVHlwZTtcbiAgICB9XG4gICAgc2V0IHBvaW50U2l6ZVR5cGUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5tYXRlcmlhbC5wb2ludFNpemVUeXBlID0gdmFsdWU7XG4gICAgfVxuICAgIHRvVHJlZU5vZGUoZ2VvbWV0cnlOb2RlLCBwYXJlbnQpIHtcbiAgICAgICAgY29uc3QgcG9pbnRzID0gbmV3IFBvaW50cyhnZW9tZXRyeU5vZGUuZ2VvbWV0cnksIHRoaXMubWF0ZXJpYWwpO1xuICAgICAgICBjb25zdCBub2RlID0gbmV3IFBvaW50Q2xvdWRPY3RyZWVOb2RlKGdlb21ldHJ5Tm9kZSwgcG9pbnRzKTtcbiAgICAgICAgcG9pbnRzLm5hbWUgPSBnZW9tZXRyeU5vZGUubmFtZTtcbiAgICAgICAgcG9pbnRzLnBvc2l0aW9uLmNvcHkoZ2VvbWV0cnlOb2RlLmJvdW5kaW5nQm94Lm1pbik7XG4gICAgICAgIHBvaW50cy5mcnVzdHVtQ3VsbGVkID0gZmFsc2U7XG4gICAgICAgIHBvaW50cy5vbkJlZm9yZVJlbmRlciA9IFBvaW50Q2xvdWRNYXRlcmlhbC5tYWtlT25CZWZvcmVSZW5kZXIodGhpcywgbm9kZSk7XG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgIHBhcmVudC5zY2VuZU5vZGUuYWRkKHBvaW50cyk7XG4gICAgICAgICAgICBwYXJlbnQuY2hpbGRyZW5bZ2VvbWV0cnlOb2RlLmluZGV4XSA9IG5vZGU7XG4gICAgICAgICAgICBnZW9tZXRyeU5vZGUub25lVGltZURpc3Bvc2VIYW5kbGVycy5wdXNoKCgpID0+IHtcbiAgICAgICAgICAgICAgICBub2RlLmRpc3Bvc2VTY2VuZU5vZGUoKTtcbiAgICAgICAgICAgICAgICBwYXJlbnQuc2NlbmVOb2RlLnJlbW92ZShub2RlLnNjZW5lTm9kZSk7XG4gICAgICAgICAgICAgICAgLy8gUmVwbGFjZSB0aGUgdHJlZSBub2RlIChyZW5kZXJlZCBhbmQgaW4gdGhlIEdQVSkgd2l0aCB0aGUgZ2VvbWV0cnkgbm9kZS5cbiAgICAgICAgICAgICAgICBwYXJlbnQuY2hpbGRyZW5bZ2VvbWV0cnlOb2RlLmluZGV4XSA9IGdlb21ldHJ5Tm9kZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yb290ID0gbm9kZTtcbiAgICAgICAgICAgIHRoaXMuYWRkKHBvaW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIHVwZGF0ZVZpc2libGVCb3VuZHMoKSB7XG4gICAgICAgIGNvbnN0IGJvdW5kcyA9IHRoaXMudmlzaWJsZUJvdW5kcztcbiAgICAgICAgYm91bmRzLm1pbi5zZXQoSW5maW5pdHksIEluZmluaXR5LCBJbmZpbml0eSk7XG4gICAgICAgIGJvdW5kcy5tYXguc2V0KC1JbmZpbml0eSwgLUluZmluaXR5LCAtSW5maW5pdHkpO1xuICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgdGhpcy52aXNpYmxlTm9kZXMpIHtcbiAgICAgICAgICAgIGlmIChub2RlLmlzTGVhZk5vZGUpIHtcbiAgICAgICAgICAgICAgICBib3VuZHMuZXhwYW5kQnlQb2ludChub2RlLmJvdW5kaW5nQm94Lm1pbik7XG4gICAgICAgICAgICAgICAgYm91bmRzLmV4cGFuZEJ5UG9pbnQobm9kZS5ib3VuZGluZ0JveC5tYXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZUJvdW5kaW5nQm94ZXMoKSB7XG4gICAgICAgIGlmICghdGhpcy5zaG93Qm91bmRpbmdCb3ggfHwgIXRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGJiUm9vdCA9IHRoaXMucGFyZW50LmdldE9iamVjdEJ5TmFtZSgnYmJyb290Jyk7XG4gICAgICAgIGlmICghYmJSb290KSB7XG4gICAgICAgICAgICBiYlJvb3QgPSBuZXcgT2JqZWN0M0QoKTtcbiAgICAgICAgICAgIGJiUm9vdC5uYW1lID0gJ2Jicm9vdCc7XG4gICAgICAgICAgICB0aGlzLnBhcmVudC5hZGQoYmJSb290KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2aXNpYmxlQm94ZXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIHRoaXMudmlzaWJsZU5vZGVzKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5ib3VuZGluZ0JveE5vZGUgIT09IHVuZGVmaW5lZCAmJiBub2RlLmlzTGVhZk5vZGUpIHtcbiAgICAgICAgICAgICAgICB2aXNpYmxlQm94ZXMucHVzaChub2RlLmJvdW5kaW5nQm94Tm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYmJSb290LmNoaWxkcmVuID0gdmlzaWJsZUJveGVzO1xuICAgIH1cbiAgICB1cGRhdGVNYXRyaXhXb3JsZChmb3JjZSkge1xuICAgICAgICBpZiAodGhpcy5tYXRyaXhBdXRvVXBkYXRlID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZU1hdHJpeCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPT09IHRydWUgfHwgZm9yY2UgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1hdHJpeFdvcmxkLmNvcHkodGhpcy5tYXRyaXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXRyaXhXb3JsZC5tdWx0aXBseU1hdHJpY2VzKHRoaXMucGFyZW50Lm1hdHJpeFdvcmxkLCB0aGlzLm1hdHJpeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvcmNlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoaWRlRGVzY2VuZGFudHMob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IHRvSGlkZSA9IFtdO1xuICAgICAgICBhZGRWaXNpYmxlQ2hpbGRyZW4ob2JqZWN0KTtcbiAgICAgICAgd2hpbGUgKHRvSGlkZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBvYmpUb0hpZGUgPSB0b0hpZGUuc2hpZnQoKTtcbiAgICAgICAgICAgIG9ialRvSGlkZS52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgICAgICBhZGRWaXNpYmxlQ2hpbGRyZW4ob2JqVG9IaWRlKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhZGRWaXNpYmxlQ2hpbGRyZW4ob2JqKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIG9iai5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZC52aXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvSGlkZS5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbW92ZVRvT3JpZ2luKCkge1xuICAgICAgICB0aGlzLnBvc2l0aW9uLnNldCgwLCAwLCAwKTsgLy8gUmVzZXQsIHRoZW4gdGhlIG1hdHJpeCB3aWxsIGJlIHVwZGF0ZWQgaW4gZ2V0Qm91bmRpbmdCb3hXb3JsZCgpXG4gICAgICAgIHRoaXMucG9zaXRpb24uc2V0KDAsIDAsIDApLnN1Yih0aGlzLmdldEJvdW5kaW5nQm94V29ybGQoKS5nZXRDZW50ZXIobmV3IFZlY3RvcjMoKSkpO1xuICAgIH1cbiAgICBtb3ZlVG9Hcm91bmRQbGFuZSgpIHtcbiAgICAgICAgdGhpcy5wb3NpdGlvbi55ICs9IC10aGlzLmdldEJvdW5kaW5nQm94V29ybGQoKS5taW4ueTtcbiAgICB9XG4gICAgZ2V0Qm91bmRpbmdCb3hXb3JsZCgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVNYXRyaXhXb3JsZCh0cnVlKTtcbiAgICAgICAgcmV0dXJuIGNvbXB1dGVUcmFuc2Zvcm1lZEJvdW5kaW5nQm94KHRoaXMuYm91bmRpbmdCb3gsIHRoaXMubWF0cml4V29ybGQpO1xuICAgIH1cbiAgICBnZXRWaXNpYmxlRXh0ZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpYmxlQm91bmRzLmFwcGx5TWF0cml4NCh0aGlzLm1hdHJpeFdvcmxkKTtcbiAgICB9XG4gICAgcGljayhyZW5kZXJlciwgY2FtZXJhLCByYXksIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIHRoaXMucGlja2VyID0gdGhpcy5waWNrZXIgfHwgbmV3IFBvaW50Q2xvdWRPY3RyZWVQaWNrZXIoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGlja2VyLnBpY2socmVuZGVyZXIsIGNhbWVyYSwgcmF5LCBbdGhpc10sIHBhcmFtcyk7XG4gICAgfVxuICAgIGdldCBwcm9ncmVzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaWJsZUdlb21ldHJ5Lmxlbmd0aCA9PT0gMFxuICAgICAgICAgICAgPyAwXG4gICAgICAgICAgICA6IHRoaXMudmlzaWJsZU5vZGVzLmxlbmd0aCAvIHRoaXMudmlzaWJsZUdlb21ldHJ5Lmxlbmd0aDtcbiAgICB9XG59XG4iLCJjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbmNvbnN0IGdsID0gY2FudmFzLmdldENvbnRleHQoJ3dlYmdsJyk7XG5leHBvcnQgY29uc3QgRkVBVFVSRVMgPSB7XG4gICAgU0hBREVSX0lOVEVSUE9MQVRJT046IGhhc0V4dGVuc2lvbignRVhUX2ZyYWdfZGVwdGgnKSAmJiBoYXNNaW5WYXJ5aW5nVmVjdG9ycyg4KSxcbiAgICBTSEFERVJfU1BMQVRTOiBoYXNFeHRlbnNpb24oJ0VYVF9mcmFnX2RlcHRoJykgJiYgaGFzRXh0ZW5zaW9uKCdPRVNfdGV4dHVyZV9mbG9hdCcpICYmIGhhc01pblZhcnlpbmdWZWN0b3JzKDgpLFxuICAgIFNIQURFUl9FREw6IGhhc0V4dGVuc2lvbignT0VTX3RleHR1cmVfZmxvYXQnKSAmJiBoYXNNaW5WYXJ5aW5nVmVjdG9ycyg4KSxcbiAgICBwcmVjaXNpb246IGdldFByZWNpc2lvbigpLFxufTtcbmZ1bmN0aW9uIGhhc0V4dGVuc2lvbihleHQpIHtcbiAgICByZXR1cm4gZ2wgIT09IG51bGwgJiYgQm9vbGVhbihnbC5nZXRFeHRlbnNpb24oZXh0KSk7XG59XG5mdW5jdGlvbiBoYXNNaW5WYXJ5aW5nVmVjdG9ycyh2YWx1ZSkge1xuICAgIHJldHVybiBnbCAhPT0gbnVsbCAmJiBnbC5nZXRQYXJhbWV0ZXIoZ2wuTUFYX1ZBUllJTkdfVkVDVE9SUykgPj0gdmFsdWU7XG59XG5mdW5jdGlvbiBnZXRQcmVjaXNpb24oKSB7XG4gICAgaWYgKGdsID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgY29uc3QgdnNIaWdocEZsb2F0ID0gZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KGdsLlZFUlRFWF9TSEFERVIsIGdsLkhJR0hfRkxPQVQpO1xuICAgIGNvbnN0IHZzTWVkaXVtcEZsb2F0ID0gZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KGdsLlZFUlRFWF9TSEFERVIsIGdsLk1FRElVTV9GTE9BVCk7XG4gICAgY29uc3QgZnNIaWdocEZsb2F0ID0gZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KGdsLkZSQUdNRU5UX1NIQURFUiwgZ2wuSElHSF9GTE9BVCk7XG4gICAgY29uc3QgZnNNZWRpdW1wRmxvYXQgPSBnbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoZ2wuRlJBR01FTlRfU0hBREVSLCBnbC5NRURJVU1fRkxPQVQpO1xuICAgIGNvbnN0IGhpZ2hwQXZhaWxhYmxlID0gdnNIaWdocEZsb2F0ICYmIGZzSGlnaHBGbG9hdCAmJiB2c0hpZ2hwRmxvYXQucHJlY2lzaW9uID4gMCAmJiBmc0hpZ2hwRmxvYXQucHJlY2lzaW9uID4gMDtcbiAgICBjb25zdCBtZWRpdW1wQXZhaWxhYmxlID0gdnNNZWRpdW1wRmxvYXQgJiZcbiAgICAgICAgZnNNZWRpdW1wRmxvYXQgJiZcbiAgICAgICAgdnNNZWRpdW1wRmxvYXQucHJlY2lzaW9uID4gMCAmJlxuICAgICAgICBmc01lZGl1bXBGbG9hdC5wcmVjaXNpb24gPiAwO1xuICAgIHJldHVybiBoaWdocEF2YWlsYWJsZSA/ICdoaWdocCcgOiBtZWRpdW1wQXZhaWxhYmxlID8gJ21lZGl1bXAnIDogJ2xvd3AnO1xufVxuIiwiZXhwb3J0IGNsYXNzIEFzeW5jQmxvY2tpbmdRdWV1ZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMucmVzb2x2ZXJzID0gW107XG4gICAgICAgIHRoaXMucHJvbWlzZXMgPSBbXTtcbiAgICB9XG4gICAgZW5xdWV1ZSh0KSB7XG4gICAgICAgIGlmICghdGhpcy5yZXNvbHZlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmFkZCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc29sdmUgPSB0aGlzLnJlc29sdmVycy5zaGlmdCgpO1xuICAgICAgICByZXNvbHZlKHQpO1xuICAgIH1cbiAgICBkZXF1ZXVlKCkge1xuICAgICAgICBpZiAoIXRoaXMucHJvbWlzZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmFkZCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnByb21pc2VzLnNoaWZ0KCk7XG4gICAgfVxuICAgIGFkZCgpIHtcbiAgICAgICAgdGhpcy5wcm9taXNlcy5wdXNoKG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZXNvbHZlcnMucHVzaChyZXNvbHZlKTtcbiAgICAgICAgfSkpO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IEFzeW5jQmxvY2tpbmdRdWV1ZSB9IGZyb20gJy4vYXN5bmMtYmxvY2tpbmctcXVldWUnO1xuZXhwb3J0IGNsYXNzIEF1dG9UZXJtaW5hdGluZ1dvcmtlciB7XG4gICAgY29uc3RydWN0b3Iod3JhcHBlZFdvcmtlciwgbWF4SWRsZSkge1xuICAgICAgICB0aGlzLndyYXBwZWRXb3JrZXIgPSB3cmFwcGVkV29ya2VyO1xuICAgICAgICB0aGlzLm1heElkbGUgPSBtYXhJZGxlO1xuICAgICAgICB0aGlzLnRpbWVvdXRJZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy50ZXJtaW5hdGVkID0gZmFsc2U7XG4gICAgfVxuICAgIGdldCB3b3JrZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndyYXBwZWRXb3JrZXI7XG4gICAgfVxuICAgIGdldCBpc1Rlcm1pbmF0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRlcm1pbmF0ZWQ7XG4gICAgfVxuICAgIG1hcmtJZGxlKCkge1xuICAgICAgICB0aGlzLnRpbWVvdXRJZCA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMudGVybWluYXRlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLndyYXBwZWRXb3JrZXIudGVybWluYXRlKCk7XG4gICAgICAgIH0sIHRoaXMubWF4SWRsZSk7XG4gICAgfVxuICAgIG1hcmtJblVzZSgpIHtcbiAgICAgICAgaWYgKHRoaXMudGltZW91dElkKSB7XG4gICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dElkKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBXb3JrZXJQb29sIHtcbiAgICBjb25zdHJ1Y3RvcihtYXhXb3JrZXJzLCB3b3JrZXJUeXBlKSB7XG4gICAgICAgIHRoaXMubWF4V29ya2VycyA9IG1heFdvcmtlcnM7XG4gICAgICAgIHRoaXMud29ya2VyVHlwZSA9IHdvcmtlclR5cGU7XG4gICAgICAgIHRoaXMucG9vbCA9IG5ldyBBc3luY0Jsb2NraW5nUXVldWUoKTtcbiAgICAgICAgdGhpcy5wb29sU2l6ZSA9IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSB3b3JrZXIgcHJvbWlzZSB3aGljaCBpcyByZXNvbHZlZCB3aGVuIG9uZSBpcyBhdmFpbGFibGUuXG4gICAgICovXG4gICAgZ2V0V29ya2VyKCkge1xuICAgICAgICAvLyBJZiB0aGUgbnVtYmVyIG9mIGFjdGl2ZSB3b3JrZXJzIGlzIHNtYWxsZXIgdGhhbiB0aGUgbWF4aW11bSwgcmV0dXJuIGEgbmV3IG9uZS5cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCByZXR1cm4gYSBwcm9taXNlIGZvciB3b3JrZXIgZnJvbSB0aGUgcG9vbC5cbiAgICAgICAgaWYgKHRoaXMucG9vbFNpemUgPCB0aGlzLm1heFdvcmtlcnMpIHtcbiAgICAgICAgICAgIHRoaXMucG9vbFNpemUrKztcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEF1dG9UZXJtaW5hdGluZ1dvcmtlcihuZXcgdGhpcy53b3JrZXJUeXBlKCksIFdvcmtlclBvb2wuUE9PTF9NQVhfSURMRSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucG9vbC5kZXF1ZXVlKCkudGhlbih3b3JrZXIgPT4ge1xuICAgICAgICAgICAgICAgIHdvcmtlci5tYXJrSW5Vc2UoKTtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgZGVxdWV1ZWQgd29ya2VyIGhhcyBiZWVuIHRlcm1pbmF0ZWQsIGRlY3JlYXNlIHRoZSBwb29sIHNpemUgYW5kIG1ha2UgYSByZWN1cnNpdmUgY2FsbCB0byBnZXQgYSBuZXcgd29ya2VyXG4gICAgICAgICAgICAgICAgaWYgKHdvcmtlci5pc1Rlcm1pbmF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb29sU2l6ZS0tO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRXb3JrZXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdvcmtlcjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbGVhc2VzIGEgV29ya2VyIGJhY2sgaW50byB0aGUgcG9vbFxuICAgICAqIEBwYXJhbSB3b3JrZXJcbiAgICAgKi9cbiAgICByZWxlYXNlV29ya2VyKHdvcmtlcikge1xuICAgICAgICB3b3JrZXIubWFya0lkbGUoKTtcbiAgICAgICAgdGhpcy5wb29sLmVucXVldWUod29ya2VyKTtcbiAgICB9XG59XG4vKipcbiAqIFRoZSBtYXhpbXVtIGFtb3VudCBvZiBpZGxlIHRpbWUgdGhhdCBjYW4gZWxhcHNlIGJlZm9yZSBhIHdvcmtlciBmcm9tIHRoaXMgcG9vbCBpcyBhdXRvbWF0aWNhbGx5IHRlcm1pbmF0ZWRcbiAqL1xuV29ya2VyUG9vbC5QT09MX01BWF9JRExFID0gNzAwMDtcbiIsImV4cG9ydCBjbGFzcyBWZXJzaW9uIHtcbiAgICBjb25zdHJ1Y3Rvcih2ZXJzaW9uKSB7XG4gICAgICAgIHRoaXMudmVyc2lvbk1pbm9yID0gMDtcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgY29uc3Qgdm1MZW5ndGggPSB2ZXJzaW9uLmluZGV4T2YoJy4nKSA9PT0gLTEgPyB2ZXJzaW9uLmxlbmd0aCA6IHZlcnNpb24uaW5kZXhPZignLicpO1xuICAgICAgICB0aGlzLnZlcnNpb25NYWpvciA9IHBhcnNlSW50KHZlcnNpb24uc3Vic3RyKDAsIHZtTGVuZ3RoKSwgMTApO1xuICAgICAgICB0aGlzLnZlcnNpb25NaW5vciA9IHBhcnNlSW50KHZlcnNpb24uc3Vic3RyKHZtTGVuZ3RoICsgMSksIDEwKTtcbiAgICAgICAgaWYgKGlzTmFOKHRoaXMudmVyc2lvbk1pbm9yKSkge1xuICAgICAgICAgICAgdGhpcy52ZXJzaW9uTWlub3IgPSAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5ld2VyVGhhbih2ZXJzaW9uKSB7XG4gICAgICAgIGNvbnN0IHYgPSBuZXcgVmVyc2lvbih2ZXJzaW9uKTtcbiAgICAgICAgaWYgKHRoaXMudmVyc2lvbk1ham9yID4gdi52ZXJzaW9uTWFqb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMudmVyc2lvbk1ham9yID09PSB2LnZlcnNpb25NYWpvciAmJiB0aGlzLnZlcnNpb25NaW5vciA+IHYudmVyc2lvbk1pbm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlcXVhbE9ySGlnaGVyKHZlcnNpb24pIHtcbiAgICAgICAgY29uc3QgdiA9IG5ldyBWZXJzaW9uKHZlcnNpb24pO1xuICAgICAgICBpZiAodGhpcy52ZXJzaW9uTWFqb3IgPiB2LnZlcnNpb25NYWpvcikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy52ZXJzaW9uTWFqb3IgPT09IHYudmVyc2lvbk1ham9yICYmIHRoaXMudmVyc2lvbk1pbm9yID49IHYudmVyc2lvbk1pbm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cFRvKHZlcnNpb24pIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLm5ld2VyVGhhbih2ZXJzaW9uKTtcbiAgICB9XG59XG4iLCIvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBDb252ZXJ0ZWQgdG8gVHlwZXNjcmlwdCBhbmQgYWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9wb3RyZWUvcG90cmVlXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5pbXBvcnQgeyBCb3gzLCBCdWZmZXJBdHRyaWJ1dGUsIEJ1ZmZlckdlb21ldHJ5LCBVaW50OEJ1ZmZlckF0dHJpYnV0ZSwgVmVjdG9yMyB9IGZyb20gJ3RocmVlJztcbmltcG9ydCB7IFBvaW50QXR0cmlidXRlTmFtZSB9IGZyb20gJy4uL3BvaW50LWF0dHJpYnV0ZXMnO1xuaW1wb3J0IHsgaGFuZGxlRW1wdHlCdWZmZXIsIGhhbmRsZUZhaWxlZFJlcXVlc3QgfSBmcm9tICcuLi91dGlscy91dGlscyc7XG5pbXBvcnQgeyBXb3JrZXJQb29sIH0gZnJvbSAnLi4vdXRpbHMvd29ya2VyLXBvb2wnO1xuaW1wb3J0IHsgVmVyc2lvbiB9IGZyb20gJy4uL3ZlcnNpb24nO1xuZXhwb3J0IGNsYXNzIEJpbmFyeUxvYWRlciB7XG4gICAgY29uc3RydWN0b3IoeyBnZXRVcmwgPSBzID0+IFByb21pc2UucmVzb2x2ZShzKSwgdmVyc2lvbiwgYm91bmRpbmdCb3gsIHNjYWxlLCB4aHJSZXF1ZXN0LCB9KSB7XG4gICAgICAgIHRoaXMuZGlzcG9zZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHR5cGVvZiB2ZXJzaW9uID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhpcy52ZXJzaW9uID0gbmV3IFZlcnNpb24odmVyc2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMueGhyUmVxdWVzdCA9IHhoclJlcXVlc3Q7XG4gICAgICAgIHRoaXMuZ2V0VXJsID0gZ2V0VXJsO1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94ID0gYm91bmRpbmdCb3g7XG4gICAgICAgIHRoaXMuc2NhbGUgPSBzY2FsZTtcbiAgICAgICAgdGhpcy5jYWxsYmFja3MgPSBbXTtcbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgdGhpcy5kaXNwb3NlZCA9IHRydWU7XG4gICAgfVxuICAgIGxvYWQobm9kZSkge1xuICAgICAgICBpZiAobm9kZS5sb2FkZWQgfHwgdGhpcy5kaXNwb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5nZXRVcmwodGhpcy5nZXROb2RlVXJsKG5vZGUpKSlcbiAgICAgICAgICAgIC50aGVuKHVybCA9PiB0aGlzLnhoclJlcXVlc3QodXJsLCB7IG1vZGU6ICdjb3JzJyB9KSlcbiAgICAgICAgICAgIC50aGVuKHJlcyA9PiBoYW5kbGVGYWlsZWRSZXF1ZXN0KHJlcykpXG4gICAgICAgICAgICAudGhlbihva1JlcyA9PiBva1Jlcy5hcnJheUJ1ZmZlcigpKVxuICAgICAgICAgICAgLnRoZW4oYnVmZmVyID0+IGhhbmRsZUVtcHR5QnVmZmVyKGJ1ZmZlcikpXG4gICAgICAgICAgICAudGhlbihva0J1ZmZlciA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB0aGlzLnBhcnNlKG5vZGUsIG9rQnVmZmVyLCByZXNvbHZlKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXROb2RlVXJsKG5vZGUpIHtcbiAgICAgICAgbGV0IHVybCA9IG5vZGUuZ2V0VXJsKCk7XG4gICAgICAgIGlmICh0aGlzLnZlcnNpb24uZXF1YWxPckhpZ2hlcignMS40JykpIHtcbiAgICAgICAgICAgIHVybCArPSAnLmJpbic7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVybDtcbiAgICB9XG4gICAgcGFyc2Uobm9kZSwgYnVmZmVyLCByZXNvbHZlKSB7XG4gICAgICAgIGlmICh0aGlzLmRpc3Bvc2VkKSB7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgQmluYXJ5TG9hZGVyLldPUktFUl9QT09MLmdldFdvcmtlcigpLnRoZW4oYXV0b1Rlcm1pbmF0aW5nV29ya2VyID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBvaW50QXR0cmlidXRlcyA9IG5vZGUucGNvR2VvbWV0cnkucG9pbnRBdHRyaWJ1dGVzO1xuICAgICAgICAgICAgY29uc3QgbnVtUG9pbnRzID0gYnVmZmVyLmJ5dGVMZW5ndGggLyBwb2ludEF0dHJpYnV0ZXMuYnl0ZVNpemU7XG4gICAgICAgICAgICBpZiAodGhpcy52ZXJzaW9uLnVwVG8oJzEuNScpKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5udW1Qb2ludHMgPSBudW1Qb2ludHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhdXRvVGVybWluYXRpbmdXb3JrZXIud29ya2VyLm9ubWVzc2FnZSA9IChlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGlzcG9zZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICBCaW5hcnlMb2FkZXIuV09SS0VSX1BPT0wucmVsZWFzZVdvcmtlcihhdXRvVGVybWluYXRpbmdXb3JrZXIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBlLmRhdGE7XG4gICAgICAgICAgICAgICAgY29uc3QgZ2VvbWV0cnkgPSAobm9kZS5nZW9tZXRyeSA9IG5vZGUuZ2VvbWV0cnkgfHwgbmV3IEJ1ZmZlckdlb21ldHJ5KCkpO1xuICAgICAgICAgICAgICAgIGdlb21ldHJ5LmJvdW5kaW5nQm94ID0gbm9kZS5ib3VuZGluZ0JveDtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEJ1ZmZlckF0dHJpYnV0ZXMoZ2VvbWV0cnksIGRhdGEuYXR0cmlidXRlQnVmZmVycyk7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRJbmRpY2VzKGdlb21ldHJ5LCBkYXRhLmluZGljZXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkTm9ybWFsQXR0cmlidXRlKGdlb21ldHJ5LCBudW1Qb2ludHMpO1xuICAgICAgICAgICAgICAgIG5vZGUubWVhbiA9IG5ldyBWZWN0b3IzKCkuZnJvbUFycmF5KGRhdGEubWVhbik7XG4gICAgICAgICAgICAgICAgbm9kZS50aWdodEJvdW5kaW5nQm94ID0gdGhpcy5nZXRUaWdodEJvdW5kaW5nQm94KGRhdGEudGlnaHRCb3VuZGluZ0JveCk7XG4gICAgICAgICAgICAgICAgbm9kZS5sb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIG5vZGUubG9hZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIG5vZGUuZmFpbGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbm9kZS5wY29HZW9tZXRyeS5udW1Ob2Rlc0xvYWRpbmctLTtcbiAgICAgICAgICAgICAgICBub2RlLnBjb0dlb21ldHJ5Lm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrcy5mb3JFYWNoKGNhbGxiYWNrID0+IGNhbGxiYWNrKG5vZGUpKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgQmluYXJ5TG9hZGVyLldPUktFUl9QT09MLnJlbGVhc2VXb3JrZXIoYXV0b1Rlcm1pbmF0aW5nV29ya2VyKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0ge1xuICAgICAgICAgICAgICAgIGJ1ZmZlcixcbiAgICAgICAgICAgICAgICBwb2ludEF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgdmVyc2lvbjogdGhpcy52ZXJzaW9uLnZlcnNpb24sXG4gICAgICAgICAgICAgICAgbWluOiBub2RlLmJvdW5kaW5nQm94Lm1pbi50b0FycmF5KCksXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiBub2RlLnBjb0dlb21ldHJ5Lm9mZnNldC50b0FycmF5KCksXG4gICAgICAgICAgICAgICAgc2NhbGU6IHRoaXMuc2NhbGUsXG4gICAgICAgICAgICAgICAgc3BhY2luZzogbm9kZS5zcGFjaW5nLFxuICAgICAgICAgICAgICAgIGhhc0NoaWxkcmVuOiBub2RlLmhhc0NoaWxkcmVuLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGF1dG9UZXJtaW5hdGluZ1dvcmtlci53b3JrZXIucG9zdE1lc3NhZ2UobWVzc2FnZSwgW21lc3NhZ2UuYnVmZmVyXSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRUaWdodEJvdW5kaW5nQm94KHsgbWluLCBtYXggfSkge1xuICAgICAgICBjb25zdCBib3ggPSBuZXcgQm94MyhuZXcgVmVjdG9yMygpLmZyb21BcnJheShtaW4pLCBuZXcgVmVjdG9yMygpLmZyb21BcnJheShtYXgpKTtcbiAgICAgICAgYm94Lm1heC5zdWIoYm94Lm1pbik7XG4gICAgICAgIGJveC5taW4uc2V0KDAsIDAsIDApO1xuICAgICAgICByZXR1cm4gYm94O1xuICAgIH1cbiAgICBhZGRCdWZmZXJBdHRyaWJ1dGVzKGdlb21ldHJ5LCBidWZmZXJzKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKGJ1ZmZlcnMpLmZvckVhY2gocHJvcGVydHkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYnVmZmVyID0gYnVmZmVyc1twcm9wZXJ0eV0uYnVmZmVyO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNBdHRyaWJ1dGUocHJvcGVydHksIFBvaW50QXR0cmlidXRlTmFtZS5QT1NJVElPTl9DQVJURVNJQU4pKSB7XG4gICAgICAgICAgICAgICAgZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCdwb3NpdGlvbicsIG5ldyBCdWZmZXJBdHRyaWJ1dGUobmV3IEZsb2F0MzJBcnJheShidWZmZXIpLCAzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmlzQXR0cmlidXRlKHByb3BlcnR5LCBQb2ludEF0dHJpYnV0ZU5hbWUuQ09MT1JfUEFDS0VEKSkge1xuICAgICAgICAgICAgICAgIGdlb21ldHJ5LnNldEF0dHJpYnV0ZSgnY29sb3InLCBuZXcgQnVmZmVyQXR0cmlidXRlKG5ldyBVaW50OEFycmF5KGJ1ZmZlciksIDMsIHRydWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuaXNBdHRyaWJ1dGUocHJvcGVydHksIFBvaW50QXR0cmlidXRlTmFtZS5JTlRFTlNJVFkpKSB7XG4gICAgICAgICAgICAgICAgZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCdpbnRlbnNpdHknLCBuZXcgQnVmZmVyQXR0cmlidXRlKG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyKSwgMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5pc0F0dHJpYnV0ZShwcm9wZXJ0eSwgUG9pbnRBdHRyaWJ1dGVOYW1lLkNMQVNTSUZJQ0FUSU9OKSkge1xuICAgICAgICAgICAgICAgIGdlb21ldHJ5LnNldEF0dHJpYnV0ZSgnY2xhc3NpZmljYXRpb24nLCBuZXcgQnVmZmVyQXR0cmlidXRlKG5ldyBVaW50OEFycmF5KGJ1ZmZlciksIDEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuaXNBdHRyaWJ1dGUocHJvcGVydHksIFBvaW50QXR0cmlidXRlTmFtZS5OT1JNQUxfU1BIRVJFTUFQUEVEKSkge1xuICAgICAgICAgICAgICAgIGdlb21ldHJ5LnNldEF0dHJpYnV0ZSgnbm9ybWFsJywgbmV3IEJ1ZmZlckF0dHJpYnV0ZShuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlciksIDMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuaXNBdHRyaWJ1dGUocHJvcGVydHksIFBvaW50QXR0cmlidXRlTmFtZS5OT1JNQUxfT0NUMTYpKSB7XG4gICAgICAgICAgICAgICAgZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCdub3JtYWwnLCBuZXcgQnVmZmVyQXR0cmlidXRlKG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyKSwgMykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5pc0F0dHJpYnV0ZShwcm9wZXJ0eSwgUG9pbnRBdHRyaWJ1dGVOYW1lLk5PUk1BTCkpIHtcbiAgICAgICAgICAgICAgICBnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ25vcm1hbCcsIG5ldyBCdWZmZXJBdHRyaWJ1dGUobmV3IEZsb2F0MzJBcnJheShidWZmZXIpLCAzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhZGRJbmRpY2VzKGdlb21ldHJ5LCBpbmRpY2VzKSB7XG4gICAgICAgIGNvbnN0IGluZGljZXNBdHRyaWJ1dGUgPSBuZXcgVWludDhCdWZmZXJBdHRyaWJ1dGUoaW5kaWNlcywgNCk7XG4gICAgICAgIGluZGljZXNBdHRyaWJ1dGUubm9ybWFsaXplZCA9IHRydWU7XG4gICAgICAgIGdlb21ldHJ5LnNldEF0dHJpYnV0ZSgnaW5kaWNlcycsIGluZGljZXNBdHRyaWJ1dGUpO1xuICAgIH1cbiAgICBhZGROb3JtYWxBdHRyaWJ1dGUoZ2VvbWV0cnksIG51bVBvaW50cykge1xuICAgICAgICBpZiAoIWdlb21ldHJ5LmdldEF0dHJpYnV0ZSgnbm9ybWFsJykpIHtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBGbG9hdDMyQXJyYXkobnVtUG9pbnRzICogMyk7XG4gICAgICAgICAgICBnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ25vcm1hbCcsIG5ldyBCdWZmZXJBdHRyaWJ1dGUobmV3IEZsb2F0MzJBcnJheShidWZmZXIpLCAzKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaXNBdHRyaWJ1dGUocHJvcGVydHksIG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KHByb3BlcnR5LCAxMCkgPT09IG5hbWU7XG4gICAgfVxufVxuQmluYXJ5TG9hZGVyLldPUktFUl9QT09MID0gbmV3IFdvcmtlclBvb2woMzIsIHJlcXVpcmUoJy4uL3dvcmtlcnMvYmluYXJ5LWRlY29kZXIud29ya2VyLmpzJykuZGVmYXVsdCk7XG4iLCIvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBDb252ZXJ0ZWQgdG8gVHlwZXNjcmlwdCBhbmQgYWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9wb3RyZWUvcG90cmVlXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5pbXBvcnQgeyBCb3gzLCBWZWN0b3IzIH0gZnJvbSAndGhyZWUnO1xuaW1wb3J0IHsgUG9pbnRBdHRyaWJ1dGVzIH0gZnJvbSAnLi4vcG9pbnQtYXR0cmlidXRlcyc7XG5pbXBvcnQgeyBQb2ludENsb3VkT2N0cmVlR2VvbWV0cnkgfSBmcm9tICcuLi9wb2ludC1jbG91ZC1vY3RyZWUtZ2VvbWV0cnknO1xuaW1wb3J0IHsgUG9pbnRDbG91ZE9jdHJlZUdlb21ldHJ5Tm9kZSB9IGZyb20gJy4uL3BvaW50LWNsb3VkLW9jdHJlZS1nZW9tZXRyeS1ub2RlJztcbmltcG9ydCB7IGNyZWF0ZUNoaWxkQUFCQiB9IGZyb20gJy4uL3V0aWxzL2JvdW5kcyc7XG5pbXBvcnQgeyBnZXRJbmRleEZyb21OYW1lLCBoYW5kbGVGYWlsZWRSZXF1ZXN0IH0gZnJvbSAnLi4vdXRpbHMvdXRpbHMnO1xuaW1wb3J0IHsgVmVyc2lvbiB9IGZyb20gJy4uL3ZlcnNpb24nO1xuaW1wb3J0IHsgQmluYXJ5TG9hZGVyIH0gZnJvbSAnLi9iaW5hcnktbG9hZGVyJztcbi8qKlxuICpcbiAqIEBwYXJhbSB1cmxcbiAqICAgIFRoZSB1cmwgb2YgdGhlIHBvaW50IGNsb3VkIGZpbGUgKHVzdWFsbHkgY2xvdWQuanMpLlxuICogQHBhcmFtIGdldFVybFxuICogICAgRnVuY3Rpb24gd2hpY2ggcmVjZWl2ZXMgdGhlIHJlbGF0aXZlIFVSTCBvZiBhIHBvaW50IGNsb3VkIGNodW5rIGZpbGUgd2hpY2ggaXMgdG8gYmUgbG9hZGVkXG4gKiAgICBhbmQgc2hvdWQgcmV0dXJuIGEgbmV3IHVybCAoZS5nLiBzaWduZWQpIGluIHRoZSBmb3JtIG9mIGEgc3RyaW5nIG9yIGEgcHJvbWlzZS5cbiAqIEBwYXJhbSB4aHJSZXF1ZXN0IEFuIGFycm93IGZ1bmN0aW9uIGZvciBhIGZldGNoIHJlcXVlc3RcbiAqIEByZXR1cm5zXG4gKiAgICBBbiBvYnNlcnZhYmxlIHdoaWNoIGVtaXRzIG9uY2Ugd2hlbiB0aGUgZmlyc3QgTE9EIG9mIHRoZSBwb2ludCBjbG91ZCBpcyBsb2FkZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsb2FkUE9DKHVybCwgZ2V0VXJsLCB4aHJSZXF1ZXN0KSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShnZXRVcmwodXJsKSkudGhlbih0cmFuc2Zvcm1lZFVybCA9PiB7XG4gICAgICAgIHJldHVybiB4aHJSZXF1ZXN0KHRyYW5zZm9ybWVkVXJsLCB7IG1vZGU6ICdjb3JzJyB9KVxuICAgICAgICAgICAgLnRoZW4ocmVzID0+IGhhbmRsZUZhaWxlZFJlcXVlc3QocmVzKSlcbiAgICAgICAgICAgIC50aGVuKG9rUmVzID0+IG9rUmVzLmpzb24oKSlcbiAgICAgICAgICAgIC50aGVuKHBhcnNlKHRyYW5zZm9ybWVkVXJsLCBnZXRVcmwsIHhoclJlcXVlc3QpKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHBhcnNlKHVybCwgZ2V0VXJsLCB4aHJSZXF1ZXN0KSB7XG4gICAgcmV0dXJuIChkYXRhKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgb2Zmc2V0LCBib3VuZGluZ0JveCwgdGlnaHRCb3VuZGluZ0JveCB9ID0gZ2V0Qm91bmRpbmdCb3hlcyhkYXRhKTtcbiAgICAgICAgY29uc3QgbG9hZGVyID0gbmV3IEJpbmFyeUxvYWRlcih7XG4gICAgICAgICAgICBnZXRVcmwsXG4gICAgICAgICAgICB2ZXJzaW9uOiBkYXRhLnZlcnNpb24sXG4gICAgICAgICAgICBib3VuZGluZ0JveCxcbiAgICAgICAgICAgIHNjYWxlOiBkYXRhLnNjYWxlLFxuICAgICAgICAgICAgeGhyUmVxdWVzdCxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHBjbyA9IG5ldyBQb2ludENsb3VkT2N0cmVlR2VvbWV0cnkobG9hZGVyLCBib3VuZGluZ0JveCwgdGlnaHRCb3VuZGluZ0JveCwgb2Zmc2V0LCB4aHJSZXF1ZXN0KTtcbiAgICAgICAgcGNvLnVybCA9IHVybDtcbiAgICAgICAgcGNvLm9jdHJlZURpciA9IGRhdGEub2N0cmVlRGlyO1xuICAgICAgICBwY28ubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICBwY28uc3BhY2luZyA9IGRhdGEuc3BhY2luZztcbiAgICAgICAgcGNvLmhpZXJhcmNoeVN0ZXBTaXplID0gZGF0YS5oaWVyYXJjaHlTdGVwU2l6ZTtcbiAgICAgICAgcGNvLnByb2plY3Rpb24gPSBkYXRhLnByb2plY3Rpb247XG4gICAgICAgIHBjby5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIHBjby5wb2ludEF0dHJpYnV0ZXMgPSBuZXcgUG9pbnRBdHRyaWJ1dGVzKGRhdGEucG9pbnRBdHRyaWJ1dGVzKTtcbiAgICAgICAgY29uc3Qgbm9kZXMgPSB7fTtcbiAgICAgICAgY29uc3QgdmVyc2lvbiA9IG5ldyBWZXJzaW9uKGRhdGEudmVyc2lvbik7XG4gICAgICAgIHJldHVybiBsb2FkUm9vdChwY28sIGRhdGEsIG5vZGVzLCB2ZXJzaW9uKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGlmICh2ZXJzaW9uLnVwVG8oJzEuNCcpKSB7XG4gICAgICAgICAgICAgICAgbG9hZFJlbWFpbmluZ0hpZXJhcmNoeShwY28sIGRhdGEsIG5vZGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBjby5ub2RlcyA9IG5vZGVzO1xuICAgICAgICAgICAgcmV0dXJuIHBjbztcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldEJvdW5kaW5nQm94ZXMoZGF0YSkge1xuICAgIGNvbnN0IG1pbiA9IG5ldyBWZWN0b3IzKGRhdGEuYm91bmRpbmdCb3gubHgsIGRhdGEuYm91bmRpbmdCb3gubHksIGRhdGEuYm91bmRpbmdCb3gubHopO1xuICAgIGNvbnN0IG1heCA9IG5ldyBWZWN0b3IzKGRhdGEuYm91bmRpbmdCb3gudXgsIGRhdGEuYm91bmRpbmdCb3gudXksIGRhdGEuYm91bmRpbmdCb3gudXopO1xuICAgIGNvbnN0IGJvdW5kaW5nQm94ID0gbmV3IEJveDMobWluLCBtYXgpO1xuICAgIGNvbnN0IHRpZ2h0Qm91bmRpbmdCb3ggPSBib3VuZGluZ0JveC5jbG9uZSgpO1xuICAgIGNvbnN0IG9mZnNldCA9IG1pbi5jbG9uZSgpO1xuICAgIGlmIChkYXRhLnRpZ2h0Qm91bmRpbmdCb3gpIHtcbiAgICAgICAgY29uc3QgeyBseCwgbHksIGx6LCB1eCwgdXksIHV6IH0gPSBkYXRhLnRpZ2h0Qm91bmRpbmdCb3g7XG4gICAgICAgIHRpZ2h0Qm91bmRpbmdCb3gubWluLnNldChseCwgbHksIGx6KTtcbiAgICAgICAgdGlnaHRCb3VuZGluZ0JveC5tYXguc2V0KHV4LCB1eSwgdXopO1xuICAgIH1cbiAgICBib3VuZGluZ0JveC5taW4uc3ViKG9mZnNldCk7XG4gICAgYm91bmRpbmdCb3gubWF4LnN1YihvZmZzZXQpO1xuICAgIHRpZ2h0Qm91bmRpbmdCb3gubWluLnN1YihvZmZzZXQpO1xuICAgIHRpZ2h0Qm91bmRpbmdCb3gubWF4LnN1YihvZmZzZXQpO1xuICAgIHJldHVybiB7IG9mZnNldCwgYm91bmRpbmdCb3gsIHRpZ2h0Qm91bmRpbmdCb3ggfTtcbn1cbmZ1bmN0aW9uIGxvYWRSb290KHBjbywgZGF0YSwgbm9kZXMsIHZlcnNpb24pIHtcbiAgICBjb25zdCBuYW1lID0gJ3InO1xuICAgIGNvbnN0IHJvb3QgPSBuZXcgUG9pbnRDbG91ZE9jdHJlZUdlb21ldHJ5Tm9kZShuYW1lLCBwY28sIHBjby5ib3VuZGluZ0JveCk7XG4gICAgcm9vdC5oYXNDaGlsZHJlbiA9IHRydWU7XG4gICAgcm9vdC5zcGFjaW5nID0gcGNvLnNwYWNpbmc7XG4gICAgaWYgKHZlcnNpb24udXBUbygnMS41JykpIHtcbiAgICAgICAgcm9vdC5udW1Qb2ludHMgPSBkYXRhLmhpZXJhcmNoeVswXVsxXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJvb3QubnVtUG9pbnRzID0gMDtcbiAgICB9XG4gICAgcGNvLnJvb3QgPSByb290O1xuICAgIG5vZGVzW25hbWVdID0gcm9vdDtcbiAgICByZXR1cm4gcGNvLnJvb3QubG9hZCgpO1xufVxuZnVuY3Rpb24gbG9hZFJlbWFpbmluZ0hpZXJhcmNoeShwY28sIGRhdGEsIG5vZGVzKSB7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBkYXRhLmhpZXJhcmNoeS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBbbmFtZSwgbnVtUG9pbnRzXSA9IGRhdGEuaGllcmFyY2h5W2ldO1xuICAgICAgICBjb25zdCB7IGluZGV4LCBwYXJlbnROYW1lLCBsZXZlbCB9ID0gcGFyc2VOYW1lKG5hbWUpO1xuICAgICAgICBjb25zdCBwYXJlbnROb2RlID0gbm9kZXNbcGFyZW50TmFtZV07XG4gICAgICAgIGNvbnN0IGJvdW5kaW5nQm94ID0gY3JlYXRlQ2hpbGRBQUJCKHBhcmVudE5vZGUuYm91bmRpbmdCb3gsIGluZGV4KTtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5ldyBQb2ludENsb3VkT2N0cmVlR2VvbWV0cnlOb2RlKG5hbWUsIHBjbywgYm91bmRpbmdCb3gpO1xuICAgICAgICBub2RlLmxldmVsID0gbGV2ZWw7XG4gICAgICAgIG5vZGUubnVtUG9pbnRzID0gbnVtUG9pbnRzO1xuICAgICAgICBub2RlLnNwYWNpbmcgPSBwY28uc3BhY2luZyAvIE1hdGgucG93KDIsIG5vZGUubGV2ZWwpO1xuICAgICAgICBub2Rlc1tuYW1lXSA9IG5vZGU7XG4gICAgICAgIHBhcmVudE5vZGUuYWRkQ2hpbGQobm9kZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gcGFyc2VOYW1lKG5hbWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBpbmRleDogZ2V0SW5kZXhGcm9tTmFtZShuYW1lKSxcbiAgICAgICAgcGFyZW50TmFtZTogbmFtZS5zdWJzdHJpbmcoMCwgbmFtZS5sZW5ndGggLSAxKSxcbiAgICAgICAgbGV2ZWw6IG5hbWUubGVuZ3RoIC0gMSxcbiAgICB9O1xufVxuIiwiZXhwb3J0ICogZnJvbSAnLi9iaW5hcnktbG9hZGVyJztcbmV4cG9ydCAqIGZyb20gJy4vbG9hZC1wb2MnO1xuZXhwb3J0ICogZnJvbSAnLi90eXBlcyc7XG4iLCJpbXBvcnQgeyBTcGhlcmUgfSBmcm9tICd0aHJlZSc7XG5leHBvcnQgY2xhc3MgT2N0cmVlR2VvbWV0cnlOb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBvY3RyZWVHZW9tZXRyeSwgYm91bmRpbmdCb3gpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5vY3RyZWVHZW9tZXRyeSA9IG9jdHJlZUdlb21ldHJ5O1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94ID0gYm91bmRpbmdCb3g7XG4gICAgICAgIHRoaXMubG9hZGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubG9hZGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuZ2VvbWV0cnkgPSBudWxsO1xuICAgICAgICB0aGlzLmhhc0NoaWxkcmVuID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNMZWFmTm9kZSA9IHRydWU7XG4gICAgICAgIHRoaXMuaXNUcmVlTm9kZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzR2VvbWV0cnlOb2RlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IFtcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBudWxsXG4gICAgICAgIF07XG4gICAgICAgIHRoaXMuaWQgPSBPY3RyZWVHZW9tZXRyeU5vZGUuSURDb3VudCsrO1xuICAgICAgICB0aGlzLmluZGV4ID0gcGFyc2VJbnQobmFtZS5jaGFyQXQobmFtZS5sZW5ndGggLSAxKSk7XG4gICAgICAgIHRoaXMuYm91bmRpbmdTcGhlcmUgPSBib3VuZGluZ0JveC5nZXRCb3VuZGluZ1NwaGVyZShuZXcgU3BoZXJlKCkpO1xuICAgICAgICB0aGlzLm51bVBvaW50cyA9IDA7XG4gICAgICAgIHRoaXMub25lVGltZURpc3Bvc2VIYW5kbGVycyA9IFtdO1xuICAgIH1cbiAgICBnZXRMZXZlbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGV2ZWw7XG4gICAgfVxuICAgIGlzTG9hZGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2FkZWQ7XG4gICAgfVxuICAgIGdldEJvdW5kaW5nU3BoZXJlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ib3VuZGluZ1NwaGVyZTtcbiAgICB9XG4gICAgZ2V0Qm91bmRpbmdCb3goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJvdW5kaW5nQm94O1xuICAgIH1cbiAgICBsb2FkKCkge1xuICAgICAgICBpZiAodGhpcy5vY3RyZWVHZW9tZXRyeS5udW1Ob2Rlc0xvYWRpbmcgPj0gdGhpcy5vY3RyZWVHZW9tZXRyeS5tYXhOdW1Ob2Rlc0xvYWRpbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vY3RyZWVHZW9tZXRyeS5sb2FkZXIpIHtcbiAgICAgICAgICAgIHRoaXMub2N0cmVlR2VvbWV0cnkubG9hZGVyLmxvYWQodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0TnVtUG9pbnRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5udW1Qb2ludHM7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLmdlb21ldHJ5ICYmIHRoaXMucGFyZW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZ2VvbWV0cnkuZGlzcG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5nZW9tZXRyeSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmxvYWRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm9uZVRpbWVEaXNwb3NlSGFuZGxlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBoYW5kbGVyID0gdGhpcy5vbmVUaW1lRGlzcG9zZUhhbmRsZXJzW2ldO1xuICAgICAgICAgICAgICAgIGhhbmRsZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMub25lVGltZURpc3Bvc2VIYW5kbGVycyA9IFtdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRyYXZlcnNlKGNiLCBpbmNsdWRlU2VsZiA9IHRydWUpIHtcbiAgICAgICAgY29uc3Qgc3RhY2sgPSBpbmNsdWRlU2VsZiA/IFt0aGlzXSA6IFtdO1xuICAgICAgICBsZXQgY3VycmVudDtcbiAgICAgICAgd2hpbGUgKChjdXJyZW50ID0gc3RhY2sucG9wKCkpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNiKGN1cnJlbnQpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBjdXJyZW50LmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbk9jdHJlZUdlb21ldHJ5Tm9kZS5JRENvdW50ID0gMDtcbk9jdHJlZUdlb21ldHJ5Tm9kZS5JRENvdW50ID0gMDtcbiIsIi8qKlxuICogU29tZSB0eXBlcyBvZiBwb3NzaWJsZSBwb2ludCBhdHRyaWJ1dGUgZGF0YSBmb3JtYXRzXG4gKlxuICogQGNsYXNzXG4gKi9cbmNvbnN0IFBvaW50QXR0cmlidXRlVHlwZXMgPSB7XG4gICAgREFUQV9UWVBFX0RPVUJMRTogeyBvcmRpbmFsOiAwLCBuYW1lOiAnZG91YmxlJywgc2l6ZTogOCB9LFxuICAgIERBVEFfVFlQRV9GTE9BVDogeyBvcmRpbmFsOiAxLCBuYW1lOiAnZmxvYXQnLCBzaXplOiA0IH0sXG4gICAgREFUQV9UWVBFX0lOVDg6IHsgb3JkaW5hbDogMiwgbmFtZTogJ2ludDgnLCBzaXplOiAxIH0sXG4gICAgREFUQV9UWVBFX1VJTlQ4OiB7IG9yZGluYWw6IDMsIG5hbWU6ICd1aW50OCcsIHNpemU6IDEgfSxcbiAgICBEQVRBX1RZUEVfSU5UMTY6IHsgb3JkaW5hbDogNCwgbmFtZTogJ2ludDE2Jywgc2l6ZTogMiB9LFxuICAgIERBVEFfVFlQRV9VSU5UMTY6IHsgb3JkaW5hbDogNSwgbmFtZTogJ3VpbnQxNicsIHNpemU6IDIgfSxcbiAgICBEQVRBX1RZUEVfSU5UMzI6IHsgb3JkaW5hbDogNiwgbmFtZTogJ2ludDMyJywgc2l6ZTogNCB9LFxuICAgIERBVEFfVFlQRV9VSU5UMzI6IHsgb3JkaW5hbDogNywgbmFtZTogJ3VpbnQzMicsIHNpemU6IDQgfSxcbiAgICBEQVRBX1RZUEVfSU5UNjQ6IHsgb3JkaW5hbDogOCwgbmFtZTogJ2ludDY0Jywgc2l6ZTogOCB9LFxuICAgIERBVEFfVFlQRV9VSU5UNjQ6IHsgb3JkaW5hbDogOSwgbmFtZTogJ3VpbnQ2NCcsIHNpemU6IDggfVxufTtcbmxldCBpID0gMDtcbmZvciAoY29uc3Qgb2JqIGluIFBvaW50QXR0cmlidXRlVHlwZXMpIHtcbiAgICBQb2ludEF0dHJpYnV0ZVR5cGVzW2ldID0gUG9pbnRBdHRyaWJ1dGVUeXBlc1tvYmpdO1xuICAgIGkrKztcbn1cbmV4cG9ydCB7IFBvaW50QXR0cmlidXRlVHlwZXMgfTtcbmNsYXNzIFBvaW50QXR0cmlidXRlIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCB0eXBlLCBudW1FbGVtZW50cywgcmFuZ2UgPSBbSW5maW5pdHksIC1JbmZpbml0eV0pIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5udW1FbGVtZW50cyA9IG51bUVsZW1lbnRzO1xuICAgICAgICB0aGlzLnJhbmdlID0gcmFuZ2U7XG4gICAgICAgIHRoaXMuYnl0ZVNpemUgPSB0aGlzLm51bUVsZW1lbnRzICogdGhpcy50eXBlLnNpemU7XG4gICAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSAnJztcbiAgICB9XG59XG5leHBvcnQgeyBQb2ludEF0dHJpYnV0ZSB9O1xuZXhwb3J0IGNvbnN0IFBPSU5UX0FUVFJJQlVURVMgPSB7XG4gICAgUE9TSVRJT05fQ0FSVEVTSUFOOiBuZXcgUG9pbnRBdHRyaWJ1dGUoJ1BPU0lUSU9OX0NBUlRFU0lBTicsIFBvaW50QXR0cmlidXRlVHlwZXMuREFUQV9UWVBFX0ZMT0FULCAzKSxcbiAgICBSR0JBX1BBQ0tFRDogbmV3IFBvaW50QXR0cmlidXRlKCdDT0xPUl9QQUNLRUQnLCBQb2ludEF0dHJpYnV0ZVR5cGVzLkRBVEFfVFlQRV9JTlQ4LCA0KSxcbiAgICBDT0xPUl9QQUNLRUQ6IG5ldyBQb2ludEF0dHJpYnV0ZSgnQ09MT1JfUEFDS0VEJywgUG9pbnRBdHRyaWJ1dGVUeXBlcy5EQVRBX1RZUEVfSU5UOCwgNCksXG4gICAgUkdCX1BBQ0tFRDogbmV3IFBvaW50QXR0cmlidXRlKCdDT0xPUl9QQUNLRUQnLCBQb2ludEF0dHJpYnV0ZVR5cGVzLkRBVEFfVFlQRV9JTlQ4LCAzKSxcbiAgICBOT1JNQUxfRkxPQVRTOiBuZXcgUG9pbnRBdHRyaWJ1dGUoJ05PUk1BTF9GTE9BVFMnLCBQb2ludEF0dHJpYnV0ZVR5cGVzLkRBVEFfVFlQRV9GTE9BVCwgMyksXG4gICAgSU5URU5TSVRZOiBuZXcgUG9pbnRBdHRyaWJ1dGUoJ0lOVEVOU0lUWScsIFBvaW50QXR0cmlidXRlVHlwZXMuREFUQV9UWVBFX1VJTlQxNiwgMSksXG4gICAgQ0xBU1NJRklDQVRJT046IG5ldyBQb2ludEF0dHJpYnV0ZSgnQ0xBU1NJRklDQVRJT04nLCBQb2ludEF0dHJpYnV0ZVR5cGVzLkRBVEFfVFlQRV9VSU5UOCwgMSksXG4gICAgTk9STUFMX1NQSEVSRU1BUFBFRDogbmV3IFBvaW50QXR0cmlidXRlKCdOT1JNQUxfU1BIRVJFTUFQUEVEJywgUG9pbnRBdHRyaWJ1dGVUeXBlcy5EQVRBX1RZUEVfVUlOVDgsIDIpLFxuICAgIE5PUk1BTF9PQ1QxNjogbmV3IFBvaW50QXR0cmlidXRlKCdOT1JNQUxfT0NUMTYnLCBQb2ludEF0dHJpYnV0ZVR5cGVzLkRBVEFfVFlQRV9VSU5UOCwgMiksXG4gICAgTk9STUFMOiBuZXcgUG9pbnRBdHRyaWJ1dGUoJ05PUk1BTCcsIFBvaW50QXR0cmlidXRlVHlwZXMuREFUQV9UWVBFX0ZMT0FULCAzKSxcbiAgICBSRVRVUk5fTlVNQkVSOiBuZXcgUG9pbnRBdHRyaWJ1dGUoJ1JFVFVSTl9OVU1CRVInLCBQb2ludEF0dHJpYnV0ZVR5cGVzLkRBVEFfVFlQRV9VSU5UOCwgMSksXG4gICAgTlVNQkVSX09GX1JFVFVSTlM6IG5ldyBQb2ludEF0dHJpYnV0ZSgnTlVNQkVSX09GX1JFVFVSTlMnLCBQb2ludEF0dHJpYnV0ZVR5cGVzLkRBVEFfVFlQRV9VSU5UOCwgMSksXG4gICAgU09VUkNFX0lEOiBuZXcgUG9pbnRBdHRyaWJ1dGUoJ1NPVVJDRV9JRCcsIFBvaW50QXR0cmlidXRlVHlwZXMuREFUQV9UWVBFX1VJTlQxNiwgMSksXG4gICAgSU5ESUNFUzogbmV3IFBvaW50QXR0cmlidXRlKCdJTkRJQ0VTJywgUG9pbnRBdHRyaWJ1dGVUeXBlcy5EQVRBX1RZUEVfVUlOVDMyLCAxKSxcbiAgICBTUEFDSU5HOiBuZXcgUG9pbnRBdHRyaWJ1dGUoJ1NQQUNJTkcnLCBQb2ludEF0dHJpYnV0ZVR5cGVzLkRBVEFfVFlQRV9GTE9BVCwgMSksXG4gICAgR1BTX1RJTUU6IG5ldyBQb2ludEF0dHJpYnV0ZSgnR1BTX1RJTUUnLCBQb2ludEF0dHJpYnV0ZVR5cGVzLkRBVEFfVFlQRV9ET1VCTEUsIDEpXG59O1xuZXhwb3J0IGNsYXNzIFBvaW50QXR0cmlidXRlcyB7XG4gICAgY29uc3RydWN0b3IocG9pbnRBdHRyaWJ1dGVzLCBhdHRyaWJ1dGVzID0gW10sIGJ5dGVTaXplID0gMCwgc2l6ZSA9IDAsIHZlY3RvcnMgPSBbXSkge1xuICAgICAgICB0aGlzLmF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzO1xuICAgICAgICB0aGlzLmJ5dGVTaXplID0gYnl0ZVNpemU7XG4gICAgICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgICAgIHRoaXMudmVjdG9ycyA9IHZlY3RvcnM7XG4gICAgICAgIGlmIChwb2ludEF0dHJpYnV0ZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludEF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwb2ludEF0dHJpYnV0ZU5hbWUgPSBwb2ludEF0dHJpYnV0ZXNbaV07XG4gICAgICAgICAgICAgICAgY29uc3QgcG9pbnRBdHRyaWJ1dGUgPSBQT0lOVF9BVFRSSUJVVEVTW3BvaW50QXR0cmlidXRlTmFtZV07XG4gICAgICAgICAgICAgICAgdGhpcy5hdHRyaWJ1dGVzLnB1c2gocG9pbnRBdHRyaWJ1dGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuYnl0ZVNpemUgKz0gcG9pbnRBdHRyaWJ1dGUuYnl0ZVNpemU7XG4gICAgICAgICAgICAgICAgdGhpcy5zaXplKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkKHBvaW50QXR0cmlidXRlKSB7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlcy5wdXNoKHBvaW50QXR0cmlidXRlKTtcbiAgICAgICAgdGhpcy5ieXRlU2l6ZSArPSBwb2ludEF0dHJpYnV0ZS5ieXRlU2l6ZTtcbiAgICAgICAgdGhpcy5zaXplKys7XG4gICAgfVxuICAgIGFkZFZlY3Rvcih2ZWN0b3IpIHtcbiAgICAgICAgdGhpcy52ZWN0b3JzLnB1c2godmVjdG9yKTtcbiAgICB9XG4gICAgaGFzTm9ybWFscygpIHtcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIHRoaXMuYXR0cmlidXRlcykge1xuICAgICAgICAgICAgY29uc3QgcG9pbnRBdHRyaWJ1dGUgPSB0aGlzLmF0dHJpYnV0ZXNbbmFtZV07XG4gICAgICAgICAgICBpZiAocG9pbnRBdHRyaWJ1dGUgPT09IFBPSU5UX0FUVFJJQlVURVMuTk9STUFMX1NQSEVSRU1BUFBFRCB8fFxuICAgICAgICAgICAgICAgIHBvaW50QXR0cmlidXRlID09PSBQT0lOVF9BVFRSSUJVVEVTLk5PUk1BTF9GTE9BVFMgfHxcbiAgICAgICAgICAgICAgICBwb2ludEF0dHJpYnV0ZSA9PT0gUE9JTlRfQVRUUklCVVRFUy5OT1JNQUwgfHxcbiAgICAgICAgICAgICAgICBwb2ludEF0dHJpYnV0ZSA9PT0gUE9JTlRfQVRUUklCVVRFUy5OT1JNQUxfT0NUMTYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuIiwiY29uc3QgRGVjb2RlcldvcmtlciA9IHJlcXVpcmUoJy4vZGVjb2Rlci53b3JrZXIuanMnKS5kZWZhdWx0O1xuLy8gQ3JlYXRlIGVudW1zIGZvciBkaWZmZXJlbnQgdHlwZXMgb2Ygd29ya2Vyc1xuZXhwb3J0IHZhciBXb3JrZXJUeXBlO1xuKGZ1bmN0aW9uIChXb3JrZXJUeXBlKSB7XG4gICAgV29ya2VyVHlwZVtcIkRFQ09ERVJfV09SS0VSXCJdID0gXCJERUNPREVSX1dPUktFUlwiO1xufSkoV29ya2VyVHlwZSB8fCAoV29ya2VyVHlwZSA9IHt9KSk7XG4vLyBXb3JrZXIgSlMgbmFtZXM6ICdCaW5hcnlEZWNvZGVyV29ya2VyLmpzJywgJ0RFTVdvcmtlci5qcycsICdFcHRCaW5hcnlEZWNvZGVyV29ya2VyLmpzJywgJ0VwdExhc3ppcERlY29kZXJXb3JrZXIuanMnLFxuLy8gRXB0WnN0YW5kYXJkRGVjb2Rlcl9wcmVhbWJsZS5qcycsICdFcHRac3RhbmRhcmREZWNvZGVyV29ya2VyLmpzJywgJ0xBU0RlY29kZXJXb3JrZXIuanMnLCAnTEFTTEFaV29ya2VyLmpzJywgJ0xhekxvYWRlcldvcmtlci5qcydcbmZ1bmN0aW9uIGNyZWF0ZVdvcmtlcih0eXBlKSB7XG4gICAgLy8gY29uc29sZS5sb2codHlwZSlcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBXb3JrZXJUeXBlLkRFQ09ERVJfV09SS0VSOiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERlY29kZXJXb3JrZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHdvcmtlciB0eXBlJyk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFdvcmtlclBvb2wge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvLyBXb3JrZXJzIHdpbGwgYmUgYW4gb2JqZWN0IHRoYXQgaGFzIGEga2V5IGZvciBlYWNoIHdvcmtlciB0eXBlIGFuZCB0aGUgdmFsdWUgaXMgYW4gYXJyYXkgb2YgV29ya2VycyB0aGF0IGNhbiBiZSBlbXB0eVxuICAgICAgICB0aGlzLndvcmtlcnMgPSB7IERFQ09ERVJfV09SS0VSOiBbXSB9O1xuICAgIH1cbiAgICBnZXRXb3JrZXIod29ya2VyVHlwZSkge1xuICAgICAgICAvLyBUaHJvdyBlcnJvciBpZiB3b3JrZXJUeXBlIGlzIG5vdCByZWNvZ25pemVkXG4gICAgICAgIGlmICh0aGlzLndvcmtlcnNbd29ya2VyVHlwZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHdvcmtlciB0eXBlJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2l2ZW4gYSB3b3JrZXIgVVJMLCBpZiBVUkwgZG9lcyBub3QgZXhpc3QgaW4gdGhlIHdvcmtlciBvYmplY3QsIGNyZWF0ZSBhIG5ldyBhcnJheSB3aXRoIHRoZSBVUkwgYXMgYSBrZXlcbiAgICAgICAgaWYgKHRoaXMud29ya2Vyc1t3b3JrZXJUeXBlXS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHdvcmtlciA9IGNyZWF0ZVdvcmtlcih3b3JrZXJUeXBlKTtcbiAgICAgICAgICAgIHRoaXMud29ya2Vyc1t3b3JrZXJUeXBlXS5wdXNoKHdvcmtlcik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgd29ya2VyID0gdGhpcy53b3JrZXJzW3dvcmtlclR5cGVdLnBvcCgpO1xuICAgICAgICBpZiAod29ya2VyID09PSB1bmRlZmluZWQpIHsgLy8gVHlwZXNjcmlwdCBuZWVkcyB0aGlzXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHdvcmtlcnMgYXZhaWxhYmxlJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmV0dXJuIHRoZSBsYXN0IHdvcmtlciBpbiB0aGUgYXJyYXkgYW5kIHJlbW92ZSBpdCBmcm9tIHRoZSBhcnJheVxuICAgICAgICByZXR1cm4gd29ya2VyO1xuICAgIH1cbiAgICByZXR1cm5Xb3JrZXIod29ya2VyVHlwZSwgd29ya2VyKSB7XG4gICAgICAgIHRoaXMud29ya2Vyc1t3b3JrZXJUeXBlXS5wdXNoKHdvcmtlcik7XG4gICAgfVxufVxuIiwidmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5pbXBvcnQgeyBCdWZmZXJBdHRyaWJ1dGUsIEJ1ZmZlckdlb21ldHJ5LCBWZWN0b3IzIH0gZnJvbSAndGhyZWUnO1xuaW1wb3J0IHsgQm94MywgU3BoZXJlIH0gZnJvbSAndGhyZWUnO1xuaW1wb3J0IHsgT2N0cmVlR2VvbWV0cnkgfSBmcm9tICcuL29jdHJlZS1nZW9tZXRyeSc7XG5pbXBvcnQgeyBPY3RyZWVHZW9tZXRyeU5vZGUgfSBmcm9tICcuL29jdHJlZS1nZW9tZXRyeS1ub2RlJztcbmltcG9ydCB7IFBvaW50QXR0cmlidXRlLCBQb2ludEF0dHJpYnV0ZXMsIFBvaW50QXR0cmlidXRlVHlwZXMgfSBmcm9tICcuL3BvaW50LWF0dHJpYnV0ZXMnO1xuaW1wb3J0IHsgV29ya2VyUG9vbCwgV29ya2VyVHlwZSB9IGZyb20gJy4vd29ya2VyLXBvb2wnO1xuZXhwb3J0IGNsYXNzIE5vZGVMb2FkZXIge1xuICAgIGNvbnN0cnVjdG9yKHVybCwgd29ya2VyUG9vbCwgbWV0YWRhdGEpIHtcbiAgICAgICAgdGhpcy51cmwgPSB1cmw7XG4gICAgICAgIHRoaXMud29ya2VyUG9vbCA9IHdvcmtlclBvb2w7XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgICB9XG4gICAgbG9hZChub2RlKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5sb2FkZWQgfHwgbm9kZS5sb2FkaW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZS5sb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIG5vZGUub2N0cmVlR2VvbWV0cnkubnVtTm9kZXNMb2FkaW5nKys7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMubG9hZEhpZXJhcmNoeShub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgeyBieXRlT2Zmc2V0LCBieXRlU2l6ZSB9ID0gbm9kZTtcbiAgICAgICAgICAgICAgICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkIHx8IGJ5dGVTaXplID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdieXRlT2Zmc2V0IGFuZCBieXRlU2l6ZSBhcmUgcmVxdWlyZWQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgdXJsT2N0cmVlID0gdGhpcy51cmwucmVwbGFjZSgnL21ldGFkYXRhLmpzb24nLCAnL29jdHJlZS5iaW4nKTtcbiAgICAgICAgICAgICAgICBjb25zdCBmaXJzdCA9IGJ5dGVPZmZzZXQ7XG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdCA9IGJ5dGVPZmZzZXQgKyBieXRlU2l6ZSAtIEJpZ0ludCgxKTtcbiAgICAgICAgICAgICAgICBsZXQgYnVmZmVyO1xuICAgICAgICAgICAgICAgIGlmIChieXRlU2l6ZSA9PT0gQmlnSW50KDApKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcigwKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBsb2FkZWQgbm9kZSB3aXRoIDAgYnl0ZXM6ICR7bm9kZS5uYW1lfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCBmZXRjaCh1cmxPY3RyZWUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnY29udGVudC10eXBlJzogJ211bHRpcGFydC9ieXRlcmFuZ2VzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBSYW5nZTogYGJ5dGVzPSR7Zmlyc3R9LSR7bGFzdH1gXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBidWZmZXIgPSB5aWVsZCByZXNwb25zZS5hcnJheUJ1ZmZlcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB3b3JrZXJUeXBlID0gV29ya2VyVHlwZS5ERUNPREVSX1dPUktFUjtcbiAgICAgICAgICAgICAgICBjb25zdCB3b3JrZXIgPSB0aGlzLndvcmtlclBvb2wuZ2V0V29ya2VyKHdvcmtlclR5cGUpO1xuICAgICAgICAgICAgICAgIHdvcmtlci5vbm1lc3NhZ2UgPSAoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gZS5kYXRhO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBidWZmZXJzID0gZGF0YS5hdHRyaWJ1dGVCdWZmZXJzO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLndvcmtlclBvb2wucmV0dXJuV29ya2VyKHdvcmtlclR5cGUsIHdvcmtlcik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcHJvcGVydHkgaW4gYnVmZmVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYnVmZmVyID0gYnVmZmVyc1twcm9wZXJ0eV0uYnVmZmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnR5ID09PSAncG9zaXRpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCdwb3NpdGlvbicsIG5ldyBCdWZmZXJBdHRyaWJ1dGUobmV3IEZsb2F0MzJBcnJheShidWZmZXIpLCAzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwcm9wZXJ0eSA9PT0gJ3JnYmEnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCdyZ2JhJywgbmV3IEJ1ZmZlckF0dHJpYnV0ZShuZXcgVWludDhBcnJheShidWZmZXIpLCA0LCB0cnVlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwcm9wZXJ0eSA9PT0gJ05PUk1BTCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ25vcm1hbCcsIG5ldyBCdWZmZXJBdHRyaWJ1dGUobmV3IEZsb2F0MzJBcnJheShidWZmZXIpLCAzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwcm9wZXJ0eSA9PT0gJ0lORElDRVMnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYnVmZmVyQXR0cmlidXRlID0gbmV3IEJ1ZmZlckF0dHJpYnV0ZShuZXcgVWludDhBcnJheShidWZmZXIpLCA0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJBdHRyaWJ1dGUubm9ybWFsaXplZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCdpbmRpY2VzJywgYnVmZmVyQXR0cmlidXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJ1ZmZlckF0dHJpYnV0ZSA9IG5ldyBCdWZmZXJBdHRyaWJ1dGUobmV3IEZsb2F0MzJBcnJheShidWZmZXIpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBiYXRjaEF0dHJpYnV0ZSA9IGJ1ZmZlcnNbcHJvcGVydHldLmF0dHJpYnV0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJBdHRyaWJ1dGUucG90cmVlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IGJ1ZmZlcnNbcHJvcGVydHldLm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGU6IGJ1ZmZlcnNbcHJvcGVydHldLnNjYWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVjaXNlQnVmZmVyOiBidWZmZXJzW3Byb3BlcnR5XS5wcmVjaXNlQnVmZmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZTogYmF0Y2hBdHRyaWJ1dGUucmFuZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5LnNldEF0dHJpYnV0ZShwcm9wZXJ0eSwgYnVmZmVyQXR0cmlidXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBub2RlLmRlbnNpdHkgPSBkYXRhLmRlbnNpdHk7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuZ2VvbWV0cnkgPSBnZW9tZXRyeTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5sb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBub2RlLmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5vY3RyZWVHZW9tZXRyeS5udW1Ob2Rlc0xvYWRpbmctLTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IHBvaW50QXR0cmlidXRlcyA9IG5vZGUub2N0cmVlR2VvbWV0cnkucG9pbnRBdHRyaWJ1dGVzO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNjYWxlID0gbm9kZS5vY3RyZWVHZW9tZXRyeS5zY2FsZTtcbiAgICAgICAgICAgICAgICBjb25zdCBib3ggPSBub2RlLmJvdW5kaW5nQm94O1xuICAgICAgICAgICAgICAgIGNvbnN0IG1pbiA9IG5vZGUub2N0cmVlR2VvbWV0cnkub2Zmc2V0LmNsb25lKCkuYWRkKGJveC5taW4pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNpemUgPSBib3gubWF4LmNsb25lKCkuc3ViKGJveC5taW4pO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1heCA9IG1pbi5jbG9uZSgpLmFkZChzaXplKTtcbiAgICAgICAgICAgICAgICBjb25zdCBudW1Qb2ludHMgPSBub2RlLm51bVBvaW50cztcbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBub2RlLm9jdHJlZUdlb21ldHJ5LmxvYWRlci5vZmZzZXQ7XG4gICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogbm9kZS5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBidWZmZXI6IGJ1ZmZlcixcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRBdHRyaWJ1dGVzOiBwb2ludEF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgICAgIHNjYWxlOiBzY2FsZSxcbiAgICAgICAgICAgICAgICAgICAgbWluOiBtaW4sXG4gICAgICAgICAgICAgICAgICAgIG1heDogbWF4LFxuICAgICAgICAgICAgICAgICAgICBzaXplOiBzaXplLFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgbnVtUG9pbnRzOiBudW1Qb2ludHNcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZShtZXNzYWdlLCBbbWVzc2FnZS5idWZmZXJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5sb2FkZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBub2RlLmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBub2RlLm9jdHJlZUdlb21ldHJ5Lm51bU5vZGVzTG9hZGluZy0tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcGFyc2VIaWVyYXJjaHkobm9kZSwgYnVmZmVyKSB7XG4gICAgICAgIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyKTtcbiAgICAgICAgY29uc3QgYnl0ZXNQZXJOb2RlID0gMjI7XG4gICAgICAgIGNvbnN0IG51bU5vZGVzID0gYnVmZmVyLmJ5dGVMZW5ndGggLyBieXRlc1Blck5vZGU7XG4gICAgICAgIGNvbnN0IG9jdHJlZSA9IG5vZGUub2N0cmVlR2VvbWV0cnk7XG4gICAgICAgIGNvbnN0IG5vZGVzID0gbmV3IEFycmF5KG51bU5vZGVzKTtcbiAgICAgICAgbm9kZXNbMF0gPSBub2RlO1xuICAgICAgICBsZXQgbm9kZVBvcyA9IDE7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudCA9IG5vZGVzW2ldO1xuICAgICAgICAgICAgY29uc3QgdHlwZSA9IHZpZXcuZ2V0VWludDgoaSAqIGJ5dGVzUGVyTm9kZSArIDApO1xuICAgICAgICAgICAgY29uc3QgY2hpbGRNYXNrID0gdmlldy5nZXRVaW50OChpICogYnl0ZXNQZXJOb2RlICsgMSk7XG4gICAgICAgICAgICBjb25zdCBudW1Qb2ludHMgPSB2aWV3LmdldFVpbnQzMihpICogYnl0ZXNQZXJOb2RlICsgMiwgdHJ1ZSk7XG4gICAgICAgICAgICBjb25zdCBieXRlT2Zmc2V0ID0gdmlldy5nZXRCaWdJbnQ2NChpICogYnl0ZXNQZXJOb2RlICsgNiwgdHJ1ZSk7XG4gICAgICAgICAgICBjb25zdCBieXRlU2l6ZSA9IHZpZXcuZ2V0QmlnSW50NjQoaSAqIGJ5dGVzUGVyTm9kZSArIDE0LCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50Lm5vZGVUeXBlID09PSAyKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVwbGFjZSBwcm94eSB3aXRoIHJlYWwgbm9kZVxuICAgICAgICAgICAgICAgIGN1cnJlbnQuYnl0ZU9mZnNldCA9IGJ5dGVPZmZzZXQ7XG4gICAgICAgICAgICAgICAgY3VycmVudC5ieXRlU2l6ZSA9IGJ5dGVTaXplO1xuICAgICAgICAgICAgICAgIGN1cnJlbnQubnVtUG9pbnRzID0gbnVtUG9pbnRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gMikge1xuICAgICAgICAgICAgICAgIC8vIGxvYWQgcHJveHlcbiAgICAgICAgICAgICAgICBjdXJyZW50LmhpZXJhcmNoeUJ5dGVPZmZzZXQgPSBieXRlT2Zmc2V0O1xuICAgICAgICAgICAgICAgIGN1cnJlbnQuaGllcmFyY2h5Qnl0ZVNpemUgPSBieXRlU2l6ZTtcbiAgICAgICAgICAgICAgICBjdXJyZW50Lm51bVBvaW50cyA9IG51bVBvaW50cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGxvYWQgcmVhbCBub2RlXG4gICAgICAgICAgICAgICAgY3VycmVudC5ieXRlT2Zmc2V0ID0gYnl0ZU9mZnNldDtcbiAgICAgICAgICAgICAgICBjdXJyZW50LmJ5dGVTaXplID0gYnl0ZVNpemU7XG4gICAgICAgICAgICAgICAgY3VycmVudC5udW1Qb2ludHMgPSBudW1Qb2ludHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50Lm5vZGVUeXBlID0gdHlwZTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50Lm5vZGVUeXBlID09PSAyKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBjaGlsZEluZGV4ID0gMDsgY2hpbGRJbmRleCA8IDg7IGNoaWxkSW5kZXgrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkRXhpc3RzID0gKDEgPDwgY2hpbGRJbmRleCAmIGNoaWxkTWFzaykgIT09IDA7XG4gICAgICAgICAgICAgICAgaWYgKCFjaGlsZEV4aXN0cykge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGROYW1lID0gY3VycmVudC5uYW1lICsgY2hpbGRJbmRleDtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZEFBQkIgPSBjcmVhdGVDaGlsZEFBQkIoY3VycmVudC5ib3VuZGluZ0JveCwgY2hpbGRJbmRleCk7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBuZXcgT2N0cmVlR2VvbWV0cnlOb2RlKGNoaWxkTmFtZSwgb2N0cmVlLCBjaGlsZEFBQkIpO1xuICAgICAgICAgICAgICAgIGNoaWxkLm5hbWUgPSBjaGlsZE5hbWU7XG4gICAgICAgICAgICAgICAgY2hpbGQuc3BhY2luZyA9IGN1cnJlbnQuc3BhY2luZyAvIDI7XG4gICAgICAgICAgICAgICAgY2hpbGQubGV2ZWwgPSBjdXJyZW50LmxldmVsICsgMTtcbiAgICAgICAgICAgICAgICBjdXJyZW50LmNoaWxkcmVuW2NoaWxkSW5kZXhdID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgY2hpbGQucGFyZW50ID0gY3VycmVudDtcbiAgICAgICAgICAgICAgICBub2Rlc1tub2RlUG9zXSA9IGNoaWxkO1xuICAgICAgICAgICAgICAgIG5vZGVQb3MrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBsb2FkSGllcmFyY2h5KG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgaGllcmFyY2h5Qnl0ZU9mZnNldCwgaGllcmFyY2h5Qnl0ZVNpemUgfSA9IG5vZGU7XG4gICAgICAgICAgICBpZiAoaGllcmFyY2h5Qnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkIHx8IGhpZXJhcmNoeUJ5dGVTaXplID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGhpZXJhcmNoeUJ5dGVPZmZzZXQgYW5kIGhpZXJhcmNoeUJ5dGVTaXplIGFyZSB1bmRlZmluZWQgZm9yIG5vZGUgJHtub2RlLm5hbWV9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoaWVyYXJjaHlQYXRoID0gdGhpcy51cmwucmVwbGFjZSgnL21ldGFkYXRhLmpzb24nLCAnL2hpZXJhcmNoeS5iaW4nKTtcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0ID0gaGllcmFyY2h5Qnl0ZU9mZnNldDtcbiAgICAgICAgICAgIGNvbnN0IGxhc3QgPSBmaXJzdCArIGhpZXJhcmNoeUJ5dGVTaXplIC0gQmlnSW50KDEpO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCBmZXRjaChoaWVyYXJjaHlQYXRoLCB7XG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAnY29udGVudC10eXBlJzogJ211bHRpcGFydC9ieXRlcmFuZ2VzJyxcbiAgICAgICAgICAgICAgICAgICAgUmFuZ2U6IGBieXRlcz0ke2ZpcnN0fS0ke2xhc3R9YFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgYnVmZmVyID0geWllbGQgcmVzcG9uc2UuYXJyYXlCdWZmZXIoKTtcbiAgICAgICAgICAgIHRoaXMucGFyc2VIaWVyYXJjaHkobm9kZSwgYnVmZmVyKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuY29uc3QgdG1wVmVjMyA9IG5ldyBWZWN0b3IzKCk7XG5mdW5jdGlvbiBjcmVhdGVDaGlsZEFBQkIoYWFiYiwgaW5kZXgpIHtcbiAgICBjb25zdCBtaW4gPSBhYWJiLm1pbi5jbG9uZSgpO1xuICAgIGNvbnN0IG1heCA9IGFhYmIubWF4LmNsb25lKCk7XG4gICAgY29uc3Qgc2l6ZSA9IHRtcFZlYzMuc3ViVmVjdG9ycyhtYXgsIG1pbik7XG4gICAgaWYgKChpbmRleCAmIDBiMDAwMSkgPiAwKSB7XG4gICAgICAgIG1pbi56ICs9IHNpemUueiAvIDI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBtYXgueiAtPSBzaXplLnogLyAyO1xuICAgIH1cbiAgICBpZiAoKGluZGV4ICYgMGIwMDEwKSA+IDApIHtcbiAgICAgICAgbWluLnkgKz0gc2l6ZS55IC8gMjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG1heC55IC09IHNpemUueSAvIDI7XG4gICAgfVxuICAgIGlmICgoaW5kZXggJiAwYjAxMDApID4gMCkge1xuICAgICAgICBtaW4ueCArPSBzaXplLnggLyAyO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbWF4LnggLT0gc2l6ZS54IC8gMjtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBCb3gzKG1pbiwgbWF4KTtcbn1cbmNvbnN0IHR5cGVuYW1lVHlwZWF0dHJpYnV0ZU1hcCA9IHtcbiAgICBkb3VibGU6IFBvaW50QXR0cmlidXRlVHlwZXMuREFUQV9UWVBFX0RPVUJMRSxcbiAgICBmbG9hdDogUG9pbnRBdHRyaWJ1dGVUeXBlcy5EQVRBX1RZUEVfRkxPQVQsXG4gICAgaW50ODogUG9pbnRBdHRyaWJ1dGVUeXBlcy5EQVRBX1RZUEVfSU5UOCxcbiAgICB1aW50ODogUG9pbnRBdHRyaWJ1dGVUeXBlcy5EQVRBX1RZUEVfVUlOVDgsXG4gICAgaW50MTY6IFBvaW50QXR0cmlidXRlVHlwZXMuREFUQV9UWVBFX0lOVDE2LFxuICAgIHVpbnQxNjogUG9pbnRBdHRyaWJ1dGVUeXBlcy5EQVRBX1RZUEVfVUlOVDE2LFxuICAgIGludDMyOiBQb2ludEF0dHJpYnV0ZVR5cGVzLkRBVEFfVFlQRV9JTlQzMixcbiAgICB1aW50MzI6IFBvaW50QXR0cmlidXRlVHlwZXMuREFUQV9UWVBFX1VJTlQzMixcbiAgICBpbnQ2NDogUG9pbnRBdHRyaWJ1dGVUeXBlcy5EQVRBX1RZUEVfSU5UNjQsXG4gICAgdWludDY0OiBQb2ludEF0dHJpYnV0ZVR5cGVzLkRBVEFfVFlQRV9VSU5UNjRcbn07XG5leHBvcnQgY2xhc3MgT2N0cmVlTG9hZGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy53b3JrZXJQb29sID0gbmV3IFdvcmtlclBvb2woKTtcbiAgICB9XG4gICAgc3RhdGljIHBhcnNlQXR0cmlidXRlcyhqc29uQXR0cmlidXRlcykge1xuICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0gbmV3IFBvaW50QXR0cmlidXRlcygpO1xuICAgICAgICBjb25zdCByZXBsYWNlbWVudHMgPSB7IHJnYjogJ3JnYmEnIH07XG4gICAgICAgIGZvciAoY29uc3QganNvbkF0dHJpYnV0ZSBvZiBqc29uQXR0cmlidXRlcykge1xuICAgICAgICAgICAgY29uc3QgeyBuYW1lLCBudW1FbGVtZW50cywgbWluLCBtYXggfSA9IGpzb25BdHRyaWJ1dGU7XG4gICAgICAgICAgICBjb25zdCB0eXBlID0gdHlwZW5hbWVUeXBlYXR0cmlidXRlTWFwW2pzb25BdHRyaWJ1dGUudHlwZV07XG4gICAgICAgICAgICBjb25zdCBwb3RyZWVBdHRyaWJ1dGVOYW1lID0gcmVwbGFjZW1lbnRzW25hbWVdID8gcmVwbGFjZW1lbnRzW25hbWVdIDogbmFtZTtcbiAgICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IG5ldyBQb2ludEF0dHJpYnV0ZShwb3RyZWVBdHRyaWJ1dGVOYW1lLCB0eXBlLCBudW1FbGVtZW50cyk7XG4gICAgICAgICAgICBpZiAobnVtRWxlbWVudHMgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGUucmFuZ2UgPSBbbWluWzBdLCBtYXhbMF1dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYXR0cmlidXRlLnJhbmdlID0gW21pbiwgbWF4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuYW1lID09PSAnZ3BzLXRpbWUnKSB7IC8vIEhBQ0s6IEd1YXJkIGFnYWluc3QgYmFkIGdwc1RpbWUgcmFuZ2UgaW4gbWV0YWRhdGEsIHNlZSBwb3RyZWUvcG90cmVlIzkwOVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYXR0cmlidXRlLnJhbmdlWzBdID09PSAnbnVtYmVyJyAmJiBhdHRyaWJ1dGUucmFuZ2VbMF0gPT09IGF0dHJpYnV0ZS5yYW5nZVsxXSkge1xuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGUucmFuZ2VbMV0gKz0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhdHRyaWJ1dGUuaW5pdGlhbFJhbmdlID0gYXR0cmlidXRlLnJhbmdlO1xuICAgICAgICAgICAgYXR0cmlidXRlcy5hZGQoYXR0cmlidXRlKTtcbiAgICAgICAgfVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBoYXNOb3JtYWxzID0gYXR0cmlidXRlcy5hdHRyaWJ1dGVzLmZpbmQoKGEpID0+IGEubmFtZSA9PT0gJ05vcm1hbFgnKSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlcy5hdHRyaWJ1dGVzLmZpbmQoKGEpID0+IGEubmFtZSA9PT0gJ05vcm1hbFknKSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlcy5hdHRyaWJ1dGVzLmZpbmQoKGEpID0+IGEubmFtZSA9PT0gJ05vcm1hbFonKSAhPT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKGhhc05vcm1hbHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2ZWN0b3IgPSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdOT1JNQUwnLFxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBbJ05vcm1hbFgnLCAnTm9ybWFsWScsICdOb3JtYWxaJ11cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMuYWRkVmVjdG9yKHZlY3Rvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZXM7XG4gICAgfVxuICAgIGxvYWQodXJsLCB4aHJSZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHhoclJlcXVlc3QodXJsKTtcbiAgICAgICAgICAgIGNvbnN0IG1ldGFkYXRhID0geWllbGQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IE9jdHJlZUxvYWRlci5wYXJzZUF0dHJpYnV0ZXMobWV0YWRhdGEuYXR0cmlidXRlcyk7XG4gICAgICAgICAgICBjb25zdCBsb2FkZXIgPSBuZXcgTm9kZUxvYWRlcih1cmwsIHRoaXMud29ya2VyUG9vbCwgbWV0YWRhdGEpO1xuICAgICAgICAgICAgbG9hZGVyLmF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzO1xuICAgICAgICAgICAgbG9hZGVyLnNjYWxlID0gbWV0YWRhdGEuc2NhbGU7XG4gICAgICAgICAgICBsb2FkZXIub2Zmc2V0ID0gbWV0YWRhdGEub2Zmc2V0O1xuICAgICAgICAgICAgY29uc3Qgb2N0cmVlID0gbmV3IE9jdHJlZUdlb21ldHJ5KGxvYWRlciwgbmV3IEJveDMobmV3IFZlY3RvcjMoLi4ubWV0YWRhdGEuYm91bmRpbmdCb3gubWluKSwgbmV3IFZlY3RvcjMoLi4ubWV0YWRhdGEuYm91bmRpbmdCb3gubWF4KSkpO1xuICAgICAgICAgICAgb2N0cmVlLnVybCA9IHVybDtcbiAgICAgICAgICAgIG9jdHJlZS5zcGFjaW5nID0gbWV0YWRhdGEuc3BhY2luZztcbiAgICAgICAgICAgIG9jdHJlZS5zY2FsZSA9IG1ldGFkYXRhLnNjYWxlO1xuICAgICAgICAgICAgY29uc3QgbWluID0gbmV3IFZlY3RvcjMoLi4ubWV0YWRhdGEuYm91bmRpbmdCb3gubWluKTtcbiAgICAgICAgICAgIGNvbnN0IG1heCA9IG5ldyBWZWN0b3IzKC4uLm1ldGFkYXRhLmJvdW5kaW5nQm94Lm1heCk7XG4gICAgICAgICAgICBjb25zdCBib3VuZGluZ0JveCA9IG5ldyBCb3gzKG1pbiwgbWF4KTtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IG1pbi5jbG9uZSgpO1xuICAgICAgICAgICAgYm91bmRpbmdCb3gubWluLnN1YihvZmZzZXQpO1xuICAgICAgICAgICAgYm91bmRpbmdCb3gubWF4LnN1YihvZmZzZXQpO1xuICAgICAgICAgICAgb2N0cmVlLnByb2plY3Rpb24gPSBtZXRhZGF0YS5wcm9qZWN0aW9uO1xuICAgICAgICAgICAgb2N0cmVlLmJvdW5kaW5nQm94ID0gYm91bmRpbmdCb3g7XG4gICAgICAgICAgICBvY3RyZWUudGlnaHRCb3VuZGluZ0JveCA9IGJvdW5kaW5nQm94LmNsb25lKCk7XG4gICAgICAgICAgICBvY3RyZWUuYm91bmRpbmdTcGhlcmUgPSBib3VuZGluZ0JveC5nZXRCb3VuZGluZ1NwaGVyZShuZXcgU3BoZXJlKCkpO1xuICAgICAgICAgICAgb2N0cmVlLnRpZ2h0Qm91bmRpbmdTcGhlcmUgPSBib3VuZGluZ0JveC5nZXRCb3VuZGluZ1NwaGVyZShuZXcgU3BoZXJlKCkpO1xuICAgICAgICAgICAgb2N0cmVlLm9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgICAgIG9jdHJlZS5wb2ludEF0dHJpYnV0ZXMgPSBPY3RyZWVMb2FkZXIucGFyc2VBdHRyaWJ1dGVzKG1ldGFkYXRhLmF0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgY29uc3Qgcm9vdCA9IG5ldyBPY3RyZWVHZW9tZXRyeU5vZGUoJ3InLCBvY3RyZWUsIGJvdW5kaW5nQm94KTtcbiAgICAgICAgICAgIHJvb3QubGV2ZWwgPSAwO1xuICAgICAgICAgICAgcm9vdC5ub2RlVHlwZSA9IDI7XG4gICAgICAgICAgICByb290LmhpZXJhcmNoeUJ5dGVPZmZzZXQgPSBCaWdJbnQoMCk7XG4gICAgICAgICAgICByb290LmhpZXJhcmNoeUJ5dGVTaXplID0gQmlnSW50KG1ldGFkYXRhLmhpZXJhcmNoeS5maXJzdENodW5rU2l6ZSk7XG4gICAgICAgICAgICByb290LnNwYWNpbmcgPSBvY3RyZWUuc3BhY2luZztcbiAgICAgICAgICAgIHJvb3QuYnl0ZU9mZnNldCA9IEJpZ0ludCgwKTtcbiAgICAgICAgICAgIG9jdHJlZS5yb290ID0gcm9vdDtcbiAgICAgICAgICAgIGxvYWRlci5sb2FkKHJvb3QpO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geyBnZW9tZXRyeTogb2N0cmVlIH07XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KTtcbiAgICB9XG59XG4iLCJ2YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbmltcG9ydCB7IE9jdHJlZUxvYWRlciB9IGZyb20gJy4vb2N0cmVlLWxvYWRlcic7XG5leHBvcnQgZnVuY3Rpb24gbG9hZE9jdHJlZSh1cmwsIGdldFVybCwgeGhyUmVxdWVzdCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IHRydWVVcmwgPSB5aWVsZCBnZXRVcmwodXJsKTtcbiAgICAgICAgY29uc3QgbG9hZGVyID0gbmV3IE9jdHJlZUxvYWRlcigpO1xuICAgICAgICBjb25zdCB7IGdlb21ldHJ5IH0gPSB5aWVsZCBsb2FkZXIubG9hZCh0cnVlVXJsLCB4aHJSZXF1ZXN0KTtcbiAgICAgICAgcmV0dXJuIGdlb21ldHJ5O1xuICAgIH0pO1xufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIGlzR2VvbWV0cnlOb2RlKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZSAhPT0gdW5kZWZpbmVkICYmIG5vZGUgIT09IG51bGwgJiYgbm9kZS5pc0dlb21ldHJ5Tm9kZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc1RyZWVOb2RlKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZSAhPT0gdW5kZWZpbmVkICYmIG5vZGUgIT09IG51bGwgJiYgbm9kZS5pc1RyZWVOb2RlO1xufVxuIiwiLyoqXG4gKiBmcm9tOiBodHRwOi8vZWxvcXVlbnRqYXZhc2NyaXB0Lm5ldC8xc3RfZWRpdGlvbi9hcHBlbmRpeDIuaHRtbFxuICpcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gQmluYXJ5SGVhcChzY29yZUZ1bmN0aW9uKSB7XG4gIHRoaXMuY29udGVudCA9IFtdO1xuICB0aGlzLnNjb3JlRnVuY3Rpb24gPSBzY29yZUZ1bmN0aW9uO1xufVxuQmluYXJ5SGVhcC5wcm90b3R5cGUgPSB7XG4gIHB1c2g6IGZ1bmN0aW9uIHB1c2goZWxlbWVudCkge1xuICAgIC8vIEFkZCB0aGUgbmV3IGVsZW1lbnQgdG8gdGhlIGVuZCBvZiB0aGUgYXJyYXkuXG4gICAgdGhpcy5jb250ZW50LnB1c2goZWxlbWVudCk7XG4gICAgLy8gQWxsb3cgaXQgdG8gYnViYmxlIHVwLlxuICAgIHRoaXMuYnViYmxlVXAodGhpcy5jb250ZW50Lmxlbmd0aCAtIDEpO1xuICB9LFxuICBwb3A6IGZ1bmN0aW9uIHBvcCgpIHtcbiAgICAvLyBTdG9yZSB0aGUgZmlyc3QgZWxlbWVudCBzbyB3ZSBjYW4gcmV0dXJuIGl0IGxhdGVyLlxuICAgIHZhciByZXN1bHQgPSB0aGlzLmNvbnRlbnRbMF07XG4gICAgLy8gR2V0IHRoZSBlbGVtZW50IGF0IHRoZSBlbmQgb2YgdGhlIGFycmF5LlxuICAgIHZhciBlbmQgPSB0aGlzLmNvbnRlbnQucG9wKCk7XG4gICAgLy8gSWYgdGhlcmUgYXJlIGFueSBlbGVtZW50cyBsZWZ0LCBwdXQgdGhlIGVuZCBlbGVtZW50IGF0IHRoZVxuICAgIC8vIHN0YXJ0LCBhbmQgbGV0IGl0IHNpbmsgZG93bi5cbiAgICBpZiAodGhpcy5jb250ZW50Lmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuY29udGVudFswXSA9IGVuZDtcbiAgICAgIHRoaXMuc2lua0Rvd24oMCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG4gIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKG5vZGUpIHtcbiAgICB2YXIgbGVuZ3RoID0gdGhpcy5jb250ZW50Lmxlbmd0aDtcbiAgICAvLyBUbyByZW1vdmUgYSB2YWx1ZSwgd2UgbXVzdCBzZWFyY2ggdGhyb3VnaCB0aGUgYXJyYXkgdG8gZmluZFxuICAgIC8vIGl0LlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLmNvbnRlbnRbaV0gIT0gbm9kZSkgY29udGludWU7XG4gICAgICAvLyBXaGVuIGl0IGlzIGZvdW5kLCB0aGUgcHJvY2VzcyBzZWVuIGluICdwb3AnIGlzIHJlcGVhdGVkXG4gICAgICAvLyB0byBmaWxsIHVwIHRoZSBob2xlLlxuICAgICAgdmFyIGVuZCA9IHRoaXMuY29udGVudC5wb3AoKTtcbiAgICAgIC8vIElmIHRoZSBlbGVtZW50IHdlIHBvcHBlZCB3YXMgdGhlIG9uZSB3ZSBuZWVkZWQgdG8gcmVtb3ZlLFxuICAgICAgLy8gd2UncmUgZG9uZS5cbiAgICAgIGlmIChpID09IGxlbmd0aCAtIDEpIGJyZWFrO1xuICAgICAgLy8gT3RoZXJ3aXNlLCB3ZSByZXBsYWNlIHRoZSByZW1vdmVkIGVsZW1lbnQgd2l0aCB0aGUgcG9wcGVkXG4gICAgICAvLyBvbmUsIGFuZCBhbGxvdyBpdCB0byBmbG9hdCB1cCBvciBzaW5rIGRvd24gYXMgYXBwcm9wcmlhdGUuXG4gICAgICB0aGlzLmNvbnRlbnRbaV0gPSBlbmQ7XG4gICAgICB0aGlzLmJ1YmJsZVVwKGkpO1xuICAgICAgdGhpcy5zaW5rRG93bihpKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSxcbiAgc2l6ZTogZnVuY3Rpb24gc2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZW50Lmxlbmd0aDtcbiAgfSxcbiAgYnViYmxlVXA6IGZ1bmN0aW9uIGJ1YmJsZVVwKG4pIHtcbiAgICAvLyBGZXRjaCB0aGUgZWxlbWVudCB0aGF0IGhhcyB0byBiZSBtb3ZlZC5cbiAgICB2YXIgZWxlbWVudCA9IHRoaXMuY29udGVudFtuXSxcbiAgICAgIHNjb3JlID0gdGhpcy5zY29yZUZ1bmN0aW9uKGVsZW1lbnQpO1xuICAgIC8vIFdoZW4gYXQgMCwgYW4gZWxlbWVudCBjYW4gbm90IGdvIHVwIGFueSBmdXJ0aGVyLlxuICAgIHdoaWxlIChuID4gMCkge1xuICAgICAgLy8gQ29tcHV0ZSB0aGUgcGFyZW50IGVsZW1lbnQncyBpbmRleCwgYW5kIGZldGNoIGl0LlxuICAgICAgdmFyIHBhcmVudE4gPSBNYXRoLmZsb29yKChuICsgMSkgLyAyKSAtIDEsXG4gICAgICAgIHBhcmVudCA9IHRoaXMuY29udGVudFtwYXJlbnROXTtcbiAgICAgIC8vIElmIHRoZSBwYXJlbnQgaGFzIGEgbGVzc2VyIHNjb3JlLCB0aGluZ3MgYXJlIGluIG9yZGVyIGFuZCB3ZVxuICAgICAgLy8gYXJlIGRvbmUuXG4gICAgICBpZiAoc2NvcmUgPj0gdGhpcy5zY29yZUZ1bmN0aW9uKHBhcmVudCkpIGJyZWFrO1xuXG4gICAgICAvLyBPdGhlcndpc2UsIHN3YXAgdGhlIHBhcmVudCB3aXRoIHRoZSBjdXJyZW50IGVsZW1lbnQgYW5kXG4gICAgICAvLyBjb250aW51ZS5cbiAgICAgIHRoaXMuY29udGVudFtwYXJlbnROXSA9IGVsZW1lbnQ7XG4gICAgICB0aGlzLmNvbnRlbnRbbl0gPSBwYXJlbnQ7XG4gICAgICBuID0gcGFyZW50TjtcbiAgICB9XG4gIH0sXG4gIHNpbmtEb3duOiBmdW5jdGlvbiBzaW5rRG93bihuKSB7XG4gICAgLy8gTG9vayB1cCB0aGUgdGFyZ2V0IGVsZW1lbnQgYW5kIGl0cyBzY29yZS5cbiAgICB2YXIgbGVuZ3RoID0gdGhpcy5jb250ZW50Lmxlbmd0aCxcbiAgICAgIGVsZW1lbnQgPSB0aGlzLmNvbnRlbnRbbl0sXG4gICAgICBlbGVtU2NvcmUgPSB0aGlzLnNjb3JlRnVuY3Rpb24oZWxlbWVudCk7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIC8vIENvbXB1dGUgdGhlIGluZGljZXMgb2YgdGhlIGNoaWxkIGVsZW1lbnRzLlxuICAgICAgdmFyIGNoaWxkMk4gPSAobiArIDEpICogMixcbiAgICAgICAgY2hpbGQxTiA9IGNoaWxkMk4gLSAxO1xuICAgICAgLy8gVGhpcyBpcyB1c2VkIHRvIHN0b3JlIHRoZSBuZXcgcG9zaXRpb24gb2YgdGhlIGVsZW1lbnQsXG4gICAgICAvLyBpZiBhbnkuXG4gICAgICB2YXIgc3dhcCA9IG51bGw7XG4gICAgICAvLyBJZiB0aGUgZmlyc3QgY2hpbGQgZXhpc3RzIChpcyBpbnNpZGUgdGhlIGFycmF5KS4uLlxuICAgICAgaWYgKGNoaWxkMU4gPCBsZW5ndGgpIHtcbiAgICAgICAgLy8gTG9vayBpdCB1cCBhbmQgY29tcHV0ZSBpdHMgc2NvcmUuXG4gICAgICAgIHZhciBjaGlsZDEgPSB0aGlzLmNvbnRlbnRbY2hpbGQxTl0sXG4gICAgICAgICAgY2hpbGQxU2NvcmUgPSB0aGlzLnNjb3JlRnVuY3Rpb24oY2hpbGQxKTtcbiAgICAgICAgLy8gSWYgdGhlIHNjb3JlIGlzIGxlc3MgdGhhbiBvdXIgZWxlbWVudCdzLCB3ZSBuZWVkIHRvIHN3YXAuXG4gICAgICAgIGlmIChjaGlsZDFTY29yZSA8IGVsZW1TY29yZSkgc3dhcCA9IGNoaWxkMU47XG4gICAgICB9XG4gICAgICAvLyBEbyB0aGUgc2FtZSBjaGVja3MgZm9yIHRoZSBvdGhlciBjaGlsZC5cbiAgICAgIGlmIChjaGlsZDJOIDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBjaGlsZDIgPSB0aGlzLmNvbnRlbnRbY2hpbGQyTl0sXG4gICAgICAgICAgY2hpbGQyU2NvcmUgPSB0aGlzLnNjb3JlRnVuY3Rpb24oY2hpbGQyKTtcbiAgICAgICAgaWYgKGNoaWxkMlNjb3JlIDwgKHN3YXAgPT0gbnVsbCA/IGVsZW1TY29yZSA6IGNoaWxkMVNjb3JlKSkgc3dhcCA9IGNoaWxkMk47XG4gICAgICB9XG5cbiAgICAgIC8vIE5vIG5lZWQgdG8gc3dhcCBmdXJ0aGVyLCB3ZSBhcmUgZG9uZS5cbiAgICAgIGlmIChzd2FwID09IG51bGwpIGJyZWFrO1xuXG4gICAgICAvLyBPdGhlcndpc2UsIHN3YXAgYW5kIGNvbnRpbnVlLlxuICAgICAgdGhpcy5jb250ZW50W25dID0gdGhpcy5jb250ZW50W3N3YXBdO1xuICAgICAgdGhpcy5jb250ZW50W3N3YXBdID0gZWxlbWVudDtcbiAgICAgIG4gPSBzd2FwO1xuICAgIH1cbiAgfVxufTsiLCJpbXBvcnQgeyBCdWZmZXJBdHRyaWJ1dGUsIEJ1ZmZlckdlb21ldHJ5LCBDb2xvciwgTGluZUJhc2ljTWF0ZXJpYWwsIExpbmVTZWdtZW50cywgfSBmcm9tICd0aHJlZSc7XG4vKipcbiAqXG4gKiBjb2RlIGFkYXB0ZWQgZnJvbSB0aHJlZS5qcyBCb3hIZWxwZXIuanNcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvYmxvYi9kZXYvc3JjL2hlbHBlcnMvQm94SGVscGVyLmpzXG4gKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgTXVnZW44NyAvIGh0dHA6Ly9naXRodWIuY29tL011Z2VuODdcbiAqIEBhdXRob3IgbXNjaHVldHogLyBodHRwOi8vcG90cmVlLm9yZ1xuICovXG5leHBvcnQgY2xhc3MgQm94M0hlbHBlciBleHRlbmRzIExpbmVTZWdtZW50cyB7XG4gICAgY29uc3RydWN0b3IoYm94LCBjb2xvciA9IG5ldyBDb2xvcigweGZmZmYwMCkpIHtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGNvbnN0IGluZGljZXMgPSBuZXcgVWludDE2QXJyYXkoWzAsIDEsIDEsIDIsIDIsIDMsIDMsIDAsIDQsIDUsIDUsIDYsIDYsIDcsIDcsIDQsIDAsIDQsIDEsIDUsIDIsIDYsIDMsIDddKTtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGNvbnN0IHBvc2l0aW9ucyA9IG5ldyBGbG9hdDMyQXJyYXkoW1xuICAgICAgICAgICAgYm94Lm1pbi54LCBib3gubWluLnksIGJveC5taW4ueixcbiAgICAgICAgICAgIGJveC5tYXgueCwgYm94Lm1pbi55LCBib3gubWluLnosXG4gICAgICAgICAgICBib3gubWF4LngsIGJveC5taW4ueSwgYm94Lm1heC56LFxuICAgICAgICAgICAgYm94Lm1pbi54LCBib3gubWluLnksIGJveC5tYXgueixcbiAgICAgICAgICAgIGJveC5taW4ueCwgYm94Lm1heC55LCBib3gubWluLnosXG4gICAgICAgICAgICBib3gubWF4LngsIGJveC5tYXgueSwgYm94Lm1pbi56LFxuICAgICAgICAgICAgYm94Lm1heC54LCBib3gubWF4LnksIGJveC5tYXgueixcbiAgICAgICAgICAgIGJveC5taW4ueCwgYm94Lm1heC55LCBib3gubWF4LnpcbiAgICAgICAgXSk7XG4gICAgICAgIGNvbnN0IGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG4gICAgICAgIGdlb21ldHJ5LnNldEluZGV4KG5ldyBCdWZmZXJBdHRyaWJ1dGUoaW5kaWNlcywgMSkpO1xuICAgICAgICBnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJywgbmV3IEJ1ZmZlckF0dHJpYnV0ZShwb3NpdGlvbnMsIDMpKTtcbiAgICAgICAgY29uc3QgbWF0ZXJpYWwgPSBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoeyBjb2xvcjogY29sb3IgfSk7XG4gICAgICAgIHN1cGVyKGdlb21ldHJ5LCBtYXRlcmlhbCk7XG4gICAgfVxufVxuIiwiZXhwb3J0IGNsYXNzIExSVUl0ZW0ge1xuICAgIGNvbnN0cnVjdG9yKG5vZGUpIHtcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5wcmV2aW91cyA9IG51bGw7XG4gICAgfVxufVxuLyoqXG4gKiBBIGRvdWJseS1saW5rZWQtbGlzdCBvZiB0aGUgbGVhc3QgcmVjZW50bHkgdXNlZCBlbGVtZW50cy5cbiAqL1xuZXhwb3J0IGNsYXNzIExSVSB7XG4gICAgY29uc3RydWN0b3IocG9pbnRCdWRnZXQgPSAxMDAwMDAwKSB7XG4gICAgICAgIHRoaXMucG9pbnRCdWRnZXQgPSBwb2ludEJ1ZGdldDtcbiAgICAgICAgLy8gdGhlIGxlYXN0IHJlY2VudGx5IHVzZWQgaXRlbVxuICAgICAgICB0aGlzLmZpcnN0ID0gbnVsbDtcbiAgICAgICAgLy8gdGhlIG1vc3QgcmVjZW50bHkgdXNlZCBpdGVtXG4gICAgICAgIHRoaXMubGFzdCA9IG51bGw7XG4gICAgICAgIHRoaXMubnVtUG9pbnRzID0gMDtcbiAgICAgICAgdGhpcy5pdGVtcyA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZW1zLnNpemU7XG4gICAgfVxuICAgIGhhcyhub2RlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZW1zLmhhcyhub2RlLmlkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFrZXMgdGhlIHNwZWNpZmllZCB0aGUgbW9zdCByZWNlbnRseSB1c2VkIGl0ZW0uIGlmIHRoZSBsaXN0IGRvZXMgbm90IGNvbnRhaW4gbm9kZSwgaXQgd2lsbFxuICAgICAqIGJlIGFkZGVkLlxuICAgICAqL1xuICAgIHRvdWNoKG5vZGUpIHtcbiAgICAgICAgaWYgKCFub2RlLmxvYWRlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLml0ZW1zLmdldChub2RlLmlkKTtcbiAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgIHRoaXMudG91Y2hFeGlzdGluZyhpdGVtKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYWRkTmV3KG5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZE5ldyhub2RlKSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSBuZXcgTFJVSXRlbShub2RlKTtcbiAgICAgICAgaXRlbS5wcmV2aW91cyA9IHRoaXMubGFzdDtcbiAgICAgICAgdGhpcy5sYXN0ID0gaXRlbTtcbiAgICAgICAgaWYgKGl0ZW0ucHJldmlvdXMpIHtcbiAgICAgICAgICAgIGl0ZW0ucHJldmlvdXMubmV4dCA9IGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmZpcnN0KSB7XG4gICAgICAgICAgICB0aGlzLmZpcnN0ID0gaXRlbTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLml0ZW1zLnNldChub2RlLmlkLCBpdGVtKTtcbiAgICAgICAgdGhpcy5udW1Qb2ludHMgKz0gbm9kZS5udW1Qb2ludHM7XG4gICAgfVxuICAgIHRvdWNoRXhpc3RpbmcoaXRlbSkge1xuICAgICAgICBpZiAoIWl0ZW0ucHJldmlvdXMpIHtcbiAgICAgICAgICAgIC8vIGhhbmRsZSB0b3VjaCBvbiBmaXJzdCBlbGVtZW50XG4gICAgICAgICAgICBpZiAoaXRlbS5uZXh0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJzdCA9IGl0ZW0ubmV4dDtcbiAgICAgICAgICAgICAgICB0aGlzLmZpcnN0LnByZXZpb3VzID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpdGVtLnByZXZpb3VzID0gdGhpcy5sYXN0O1xuICAgICAgICAgICAgICAgIGl0ZW0ubmV4dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0ID0gaXRlbTtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5wcmV2aW91cykge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLnByZXZpb3VzLm5leHQgPSBpdGVtO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghaXRlbS5uZXh0KSB7XG4gICAgICAgICAgICAvLyBoYW5kbGUgdG91Y2ggb24gbGFzdCBlbGVtZW50XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBoYW5kbGUgdG91Y2ggb24gYW55IG90aGVyIGVsZW1lbnRcbiAgICAgICAgICAgIGl0ZW0ucHJldmlvdXMubmV4dCA9IGl0ZW0ubmV4dDtcbiAgICAgICAgICAgIGl0ZW0ubmV4dC5wcmV2aW91cyA9IGl0ZW0ucHJldmlvdXM7XG4gICAgICAgICAgICBpdGVtLnByZXZpb3VzID0gdGhpcy5sYXN0O1xuICAgICAgICAgICAgaXRlbS5uZXh0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMubGFzdCA9IGl0ZW07XG4gICAgICAgICAgICBpZiAoaXRlbS5wcmV2aW91cykge1xuICAgICAgICAgICAgICAgIGl0ZW0ucHJldmlvdXMubmV4dCA9IGl0ZW07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlKG5vZGUpIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuaXRlbXMuZ2V0KG5vZGUuaWQpO1xuICAgICAgICBpZiAoIWl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pdGVtcy5zaXplID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzLmZpcnN0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMubGFzdCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWl0ZW0ucHJldmlvdXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpcnN0ID0gaXRlbS5uZXh0O1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyc3QucHJldmlvdXMgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpdGVtLm5leHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3QgPSBpdGVtLnByZXZpb3VzO1xuICAgICAgICAgICAgICAgIHRoaXMubGFzdC5uZXh0ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpdGVtLnByZXZpb3VzICYmIGl0ZW0ubmV4dCkge1xuICAgICAgICAgICAgICAgIGl0ZW0ucHJldmlvdXMubmV4dCA9IGl0ZW0ubmV4dDtcbiAgICAgICAgICAgICAgICBpdGVtLm5leHQucHJldmlvdXMgPSBpdGVtLnByZXZpb3VzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXRlbXMuZGVsZXRlKG5vZGUuaWQpO1xuICAgICAgICB0aGlzLm51bVBvaW50cyAtPSBub2RlLm51bVBvaW50cztcbiAgICB9XG4gICAgZ2V0TFJVSXRlbSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlyc3QgPyB0aGlzLmZpcnN0Lm5vZGUgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGZyZWVNZW1vcnkoKSB7XG4gICAgICAgIGlmICh0aGlzLml0ZW1zLnNpemUgPD0gMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlICh0aGlzLm51bVBvaW50cyA+IHRoaXMucG9pbnRCdWRnZXQgKiAyKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gdGhpcy5nZXRMUlVJdGVtKCk7XG4gICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcG9zZVN1YnRyZWUobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGlzcG9zZVN1YnRyZWUobm9kZSkge1xuICAgICAgICAvLyBDb2xsZWN0IGFsbCB0aGUgbm9kZXMgd2hpY2ggYXJlIHRvIGJlIGRpc3Bvc2VkIGFuZCByZW1vdmVkLlxuICAgICAgICBjb25zdCBub2Rlc1RvRGlzcG9zZSA9IFtub2RlXTtcbiAgICAgICAgbm9kZS50cmF2ZXJzZShuID0+IHtcbiAgICAgICAgICAgIGlmIChuLmxvYWRlZCkge1xuICAgICAgICAgICAgICAgIG5vZGVzVG9EaXNwb3NlLnB1c2gobik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBEaXNwb3NlIG9mIGFsbCB0aGUgbm9kZXMgaW4gb25lIGdvLlxuICAgICAgICBmb3IgKGNvbnN0IG4gb2Ygbm9kZXNUb0Rpc3Bvc2UpIHtcbiAgICAgICAgICAgIG4uZGlzcG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5yZW1vdmUobik7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCJpbXBvcnQgeyBCb3gzLCBGcnVzdHVtLCBNYXRyaXg0LCBWZWN0b3IyLCBWZWN0b3IzLCB9IGZyb20gJ3RocmVlJztcbmltcG9ydCB7IERFRkFVTFRfUE9JTlRfQlVER0VULCBNQVhfTE9BRFNfVE9fR1BVLCBNQVhfTlVNX05PREVTX0xPQURJTkcsIFBFUlNQRUNUSVZFX0NBTUVSQSwgfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBGRUFUVVJFUyB9IGZyb20gJy4vZmVhdHVyZXMnO1xuaW1wb3J0IHsgQmluYXJ5TG9hZGVyLCBsb2FkUE9DIH0gZnJvbSAnLi9sb2FkaW5nJztcbmltcG9ydCB7IGxvYWRPY3RyZWUgfSBmcm9tICcuL2xvYWRpbmcyL2xvYWQtb2N0cmVlJztcbmltcG9ydCB7IENsaXBNb2RlIH0gZnJvbSAnLi9tYXRlcmlhbHMnO1xuaW1wb3J0IHsgUG9pbnRDbG91ZE9jdHJlZSB9IGZyb20gJy4vcG9pbnQtY2xvdWQtb2N0cmVlJztcbmltcG9ydCB7IFBvaW50Q2xvdWRPY3RyZWVQaWNrZXIgfSBmcm9tICcuL3BvaW50LWNsb3VkLW9jdHJlZS1waWNrZXInO1xuaW1wb3J0IHsgaXNHZW9tZXRyeU5vZGUsIGlzVHJlZU5vZGUgfSBmcm9tICcuL3R5cGUtcHJlZGljYXRlcyc7XG5pbXBvcnQgeyBCaW5hcnlIZWFwIH0gZnJvbSAnLi91dGlscy9iaW5hcnktaGVhcCc7XG5pbXBvcnQgeyBCb3gzSGVscGVyIH0gZnJvbSAnLi91dGlscy9ib3gzLWhlbHBlcic7XG5pbXBvcnQgeyBMUlUgfSBmcm9tICcuL3V0aWxzL2xydSc7XG5leHBvcnQgY2xhc3MgUXVldWVJdGVtIHtcbiAgICBjb25zdHJ1Y3Rvcihwb2ludENsb3VkSW5kZXgsIHdlaWdodCwgbm9kZSwgcGFyZW50KSB7XG4gICAgICAgIHRoaXMucG9pbnRDbG91ZEluZGV4ID0gcG9pbnRDbG91ZEluZGV4O1xuICAgICAgICB0aGlzLndlaWdodCA9IHdlaWdodDtcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgfVxufVxuY29uc3QgR0VPTUVUUllfTE9BREVSUyA9IHtcbiAgICB2MTogbG9hZFBPQyxcbiAgICB2MjogbG9hZE9jdHJlZVxufTtcbmV4cG9ydCBjbGFzcyBQb3RyZWUge1xuICAgIGNvbnN0cnVjdG9yKHZlcnNpb24gPSBcInYxXCIpIHtcbiAgICAgICAgdGhpcy5fcG9pbnRCdWRnZXQgPSBERUZBVUxUX1BPSU5UX0JVREdFVDtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXJTaXplID0gbmV3IFZlY3RvcjIoKTtcbiAgICAgICAgdGhpcy5tYXhOdW1Ob2Rlc0xvYWRpbmcgPSBNQVhfTlVNX05PREVTX0xPQURJTkc7XG4gICAgICAgIHRoaXMuZmVhdHVyZXMgPSBGRUFUVVJFUztcbiAgICAgICAgdGhpcy5scnUgPSBuZXcgTFJVKHRoaXMuX3BvaW50QnVkZ2V0KTtcbiAgICAgICAgdGhpcy51cGRhdGVWaXNpYmlsaXR5U3RydWN0dXJlcyA9ICgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmcnVzdHVtTWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcbiAgICAgICAgICAgIGNvbnN0IGludmVyc2VXb3JsZE1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XG4gICAgICAgICAgICBjb25zdCBjYW1lcmFNYXRyaXggPSBuZXcgTWF0cml4NCgpO1xuICAgICAgICAgICAgcmV0dXJuIChwb2ludENsb3VkcywgY2FtZXJhKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZnJ1c3R1bXMgPSBbXTtcbiAgICAgICAgICAgICAgICBjb25zdCBjYW1lcmFQb3NpdGlvbnMgPSBbXTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmlvcml0eVF1ZXVlID0gbmV3IEJpbmFyeUhlYXAoeCA9PiAxIC8geC53ZWlnaHQpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRDbG91ZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9pbnRDbG91ZCA9IHBvaW50Q2xvdWRzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXBvaW50Q2xvdWQuaW5pdGlhbGl6ZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcG9pbnRDbG91ZC5udW1WaXNpYmxlUG9pbnRzID0gMDtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRDbG91ZC52aXNpYmxlTm9kZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRDbG91ZC52aXNpYmxlR2VvbWV0cnkgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgY2FtZXJhLnVwZGF0ZU1hdHJpeFdvcmxkKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gRnVyc3R1bSBpbiBvYmplY3Qgc3BhY2UuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGludmVyc2VWaWV3TWF0cml4ID0gY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgd29ybGRNYXRyaXggPSBwb2ludENsb3VkLm1hdHJpeFdvcmxkO1xuICAgICAgICAgICAgICAgICAgICBmcnVzdHVtTWF0cml4XG4gICAgICAgICAgICAgICAgICAgICAgICAuaWRlbnRpdHkoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm11bHRpcGx5KGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4KVxuICAgICAgICAgICAgICAgICAgICAgICAgLm11bHRpcGx5KGludmVyc2VWaWV3TWF0cml4KVxuICAgICAgICAgICAgICAgICAgICAgICAgLm11bHRpcGx5KHdvcmxkTWF0cml4KTtcbiAgICAgICAgICAgICAgICAgICAgZnJ1c3R1bXMucHVzaChuZXcgRnJ1c3R1bSgpLnNldEZyb21Qcm9qZWN0aW9uTWF0cml4KGZydXN0dW1NYXRyaXgpKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FtZXJhIHBvc2l0aW9uIGluIG9iamVjdCBzcGFjZVxuICAgICAgICAgICAgICAgICAgICBpbnZlcnNlV29ybGRNYXRyaXguY29weSh3b3JsZE1hdHJpeCkuaW52ZXJ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGNhbWVyYU1hdHJpeFxuICAgICAgICAgICAgICAgICAgICAgICAgLmlkZW50aXR5KClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tdWx0aXBseShpbnZlcnNlV29ybGRNYXRyaXgpXG4gICAgICAgICAgICAgICAgICAgICAgICAubXVsdGlwbHkoY2FtZXJhLm1hdHJpeFdvcmxkKTtcbiAgICAgICAgICAgICAgICAgICAgY2FtZXJhUG9zaXRpb25zLnB1c2gobmV3IFZlY3RvcjMoKS5zZXRGcm9tTWF0cml4UG9zaXRpb24oY2FtZXJhTWF0cml4KSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb2ludENsb3VkLnZpc2libGUgJiYgcG9pbnRDbG91ZC5yb290ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB3ZWlnaHQgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJpb3JpdHlRdWV1ZS5wdXNoKG5ldyBRdWV1ZUl0ZW0oaSwgd2VpZ2h0LCBwb2ludENsb3VkLnJvb3QpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBIaWRlIGFueSBwcmV2aW91c2x5IHZpc2libGUgbm9kZXMuIFdlIHdpbGwgbGF0ZXIgc2hvdyBvbmx5IHRoZSBuZWVkZWQgb25lcy5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzVHJlZU5vZGUocG9pbnRDbG91ZC5yb290KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRDbG91ZC5oaWRlRGVzY2VuZGFudHMocG9pbnRDbG91ZC5yb290LnNjZW5lTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBib3VuZGluZ0JveE5vZGUgb2YgcG9pbnRDbG91ZC5ib3VuZGluZ0JveE5vZGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib3VuZGluZ0JveE5vZGUudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7IGZydXN0dW1zLCBjYW1lcmFQb3NpdGlvbnMsIHByaW9yaXR5UXVldWUgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKCk7XG4gICAgICAgIHRoaXMubG9hZEdlb21ldHJ5ID0gR0VPTUVUUllfTE9BREVSU1t2ZXJzaW9uXTtcbiAgICB9XG4gICAgbG9hZFBvaW50Q2xvdWQodXJsLCBnZXRVcmwsIHhoclJlcXVlc3QgPSAoaW5wdXQsIGluaXQpID0+IGZldGNoKGlucHV0LCBpbml0KSkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2FkR2VvbWV0cnkodXJsLCBnZXRVcmwsIHhoclJlcXVlc3QpLnRoZW4oZ2VvbWV0cnkgPT4gbmV3IFBvaW50Q2xvdWRPY3RyZWUodGhpcywgZ2VvbWV0cnkpKTtcbiAgICB9XG4gICAgdXBkYXRlUG9pbnRDbG91ZHMocG9pbnRDbG91ZHMsIGNhbWVyYSwgcmVuZGVyZXIpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy51cGRhdGVWaXNpYmlsaXR5KHBvaW50Q2xvdWRzLCBjYW1lcmEsIHJlbmRlcmVyKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludENsb3Vkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcG9pbnRDbG91ZCA9IHBvaW50Q2xvdWRzW2ldO1xuICAgICAgICAgICAgaWYgKHBvaW50Q2xvdWQuZGlzcG9zZWQpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvaW50Q2xvdWQubWF0ZXJpYWwudXBkYXRlTWF0ZXJpYWwocG9pbnRDbG91ZCwgcG9pbnRDbG91ZC52aXNpYmxlTm9kZXMsIGNhbWVyYSwgcmVuZGVyZXIpO1xuICAgICAgICAgICAgcG9pbnRDbG91ZC51cGRhdGVWaXNpYmxlQm91bmRzKCk7XG4gICAgICAgICAgICBwb2ludENsb3VkLnVwZGF0ZUJvdW5kaW5nQm94ZXMoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxydS5mcmVlTWVtb3J5KCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHN0YXRpYyBwaWNrKHBvaW50Q2xvdWRzLCByZW5kZXJlciwgY2FtZXJhLCByYXksIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIFBvdHJlZS5waWNrZXIgPSBQb3RyZWUucGlja2VyIHx8IG5ldyBQb2ludENsb3VkT2N0cmVlUGlja2VyKCk7XG4gICAgICAgIHJldHVybiBQb3RyZWUucGlja2VyLnBpY2socmVuZGVyZXIsIGNhbWVyYSwgcmF5LCBwb2ludENsb3VkcywgcGFyYW1zKTtcbiAgICB9XG4gICAgZ2V0IHBvaW50QnVkZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcG9pbnRCdWRnZXQ7XG4gICAgfVxuICAgIHNldCBwb2ludEJ1ZGdldCh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMuX3BvaW50QnVkZ2V0KSB7XG4gICAgICAgICAgICB0aGlzLl9wb2ludEJ1ZGdldCA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5scnUucG9pbnRCdWRnZXQgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMubHJ1LmZyZWVNZW1vcnkoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgc2V0IG1heExvYWRlcldvcmtlcnModmFsdWUpIHtcbiAgICAgICAgQmluYXJ5TG9hZGVyLldPUktFUl9QT09MLm1heFdvcmtlcnMgPSB2YWx1ZTtcbiAgICB9XG4gICAgc3RhdGljIGdldCBtYXhMb2FkZXJXb3JrZXJzKCkge1xuICAgICAgICByZXR1cm4gQmluYXJ5TG9hZGVyLldPUktFUl9QT09MLm1heFdvcmtlcnM7XG4gICAgfVxuICAgIHVwZGF0ZVZpc2liaWxpdHkocG9pbnRDbG91ZHMsIGNhbWVyYSwgcmVuZGVyZXIpIHtcbiAgICAgICAgbGV0IG51bVZpc2libGVQb2ludHMgPSAwO1xuICAgICAgICBjb25zdCB2aXNpYmxlTm9kZXMgPSBbXTtcbiAgICAgICAgY29uc3QgdW5sb2FkZWRHZW9tZXRyeSA9IFtdO1xuICAgICAgICAvLyBjYWxjdWxhdGUgb2JqZWN0IHNwYWNlIGZydXN0dW0gYW5kIGNhbSBwb3MgYW5kIHNldHVwIHByaW9yaXR5IHF1ZXVlXG4gICAgICAgIGNvbnN0IHsgZnJ1c3R1bXMsIGNhbWVyYVBvc2l0aW9ucywgcHJpb3JpdHlRdWV1ZSB9ID0gdGhpcy51cGRhdGVWaXNpYmlsaXR5U3RydWN0dXJlcyhwb2ludENsb3VkcywgY2FtZXJhKTtcbiAgICAgICAgbGV0IGxvYWRlZFRvR1BVVGhpc0ZyYW1lID0gMDtcbiAgICAgICAgbGV0IGV4Y2VlZGVkTWF4TG9hZHNUb0dQVSA9IGZhbHNlO1xuICAgICAgICBsZXQgbm9kZUxvYWRGYWlsZWQgPSBmYWxzZTtcbiAgICAgICAgbGV0IHF1ZXVlSXRlbTtcbiAgICAgICAgd2hpbGUgKChxdWV1ZUl0ZW0gPSBwcmlvcml0eVF1ZXVlLnBvcCgpKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsZXQgbm9kZSA9IHF1ZXVlSXRlbS5ub2RlO1xuICAgICAgICAgICAgLy8gSWYgd2Ugd2lsbCBlbmQgdXAgd2l0aCB0b28gbWFueSBwb2ludHMsIHdlIHN0b3AgcmlnaHQgYXdheS5cbiAgICAgICAgICAgIGlmIChudW1WaXNpYmxlUG9pbnRzICsgbm9kZS5udW1Qb2ludHMgPiB0aGlzLnBvaW50QnVkZ2V0KSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwb2ludENsb3VkSW5kZXggPSBxdWV1ZUl0ZW0ucG9pbnRDbG91ZEluZGV4O1xuICAgICAgICAgICAgY29uc3QgcG9pbnRDbG91ZCA9IHBvaW50Q2xvdWRzW3BvaW50Q2xvdWRJbmRleF07XG4gICAgICAgICAgICBjb25zdCBtYXhMZXZlbCA9IHBvaW50Q2xvdWQubWF4TGV2ZWwgIT09IHVuZGVmaW5lZCA/IHBvaW50Q2xvdWQubWF4TGV2ZWwgOiBJbmZpbml0eTtcbiAgICAgICAgICAgIGlmIChub2RlLmxldmVsID4gbWF4TGV2ZWwgfHxcbiAgICAgICAgICAgICAgICAhZnJ1c3R1bXNbcG9pbnRDbG91ZEluZGV4XS5pbnRlcnNlY3RzQm94KG5vZGUuYm91bmRpbmdCb3gpIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5zaG91bGRDbGlwKHBvaW50Q2xvdWQsIG5vZGUuYm91bmRpbmdCb3gpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBudW1WaXNpYmxlUG9pbnRzICs9IG5vZGUubnVtUG9pbnRzO1xuICAgICAgICAgICAgcG9pbnRDbG91ZC5udW1WaXNpYmxlUG9pbnRzICs9IG5vZGUubnVtUG9pbnRzO1xuICAgICAgICAgICAgY29uc3QgcGFyZW50Tm9kZSA9IHF1ZXVlSXRlbS5wYXJlbnQ7XG4gICAgICAgICAgICBpZiAoaXNHZW9tZXRyeU5vZGUobm9kZSkgJiYgKCFwYXJlbnROb2RlIHx8IGlzVHJlZU5vZGUocGFyZW50Tm9kZSkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUubG9hZGVkICYmIGxvYWRlZFRvR1BVVGhpc0ZyYW1lIDwgTUFYX0xPQURTX1RPX0dQVSkge1xuICAgICAgICAgICAgICAgICAgICBub2RlID0gcG9pbnRDbG91ZC50b1RyZWVOb2RlKG5vZGUsIHBhcmVudE5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBsb2FkZWRUb0dQVVRoaXNGcmFtZSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghbm9kZS5mYWlsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUubG9hZGVkICYmIGxvYWRlZFRvR1BVVGhpc0ZyYW1lID49IE1BWF9MT0FEU19UT19HUFUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4Y2VlZGVkTWF4TG9hZHNUb0dQVSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdW5sb2FkZWRHZW9tZXRyeS5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBwb2ludENsb3VkLnZpc2libGVHZW9tZXRyeS5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZUxvYWRGYWlsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNUcmVlTm9kZShub2RlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlVHJlZU5vZGVWaXNpYmlsaXR5KHBvaW50Q2xvdWQsIG5vZGUsIHZpc2libGVOb2Rlcyk7XG4gICAgICAgICAgICAgICAgcG9pbnRDbG91ZC52aXNpYmxlR2VvbWV0cnkucHVzaChub2RlLmdlb21ldHJ5Tm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoYWxmSGVpZ2h0ID0gMC41ICogcmVuZGVyZXIuZ2V0U2l6ZSh0aGlzLl9yZW5kZXJlclNpemUpLmhlaWdodCAqIHJlbmRlcmVyLmdldFBpeGVsUmF0aW8oKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQ2hpbGRWaXNpYmlsaXR5KHF1ZXVlSXRlbSwgcHJpb3JpdHlRdWV1ZSwgcG9pbnRDbG91ZCwgbm9kZSwgY2FtZXJhUG9zaXRpb25zW3BvaW50Q2xvdWRJbmRleF0sIGNhbWVyYSwgaGFsZkhlaWdodCk7XG4gICAgICAgIH0gLy8gZW5kIHByaW9yaXR5IHF1ZXVlIGxvb3BcbiAgICAgICAgY29uc3QgbnVtTm9kZXNUb0xvYWQgPSBNYXRoLm1pbih0aGlzLm1heE51bU5vZGVzTG9hZGluZywgdW5sb2FkZWRHZW9tZXRyeS5sZW5ndGgpO1xuICAgICAgICBjb25zdCBub2RlTG9hZFByb21pc2VzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtTm9kZXNUb0xvYWQ7IGkrKykge1xuICAgICAgICAgICAgbm9kZUxvYWRQcm9taXNlcy5wdXNoKHVubG9hZGVkR2VvbWV0cnlbaV0ubG9hZCgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmlzaWJsZU5vZGVzOiB2aXNpYmxlTm9kZXMsXG4gICAgICAgICAgICBudW1WaXNpYmxlUG9pbnRzOiBudW1WaXNpYmxlUG9pbnRzLFxuICAgICAgICAgICAgZXhjZWVkZWRNYXhMb2Fkc1RvR1BVOiBleGNlZWRlZE1heExvYWRzVG9HUFUsXG4gICAgICAgICAgICBub2RlTG9hZEZhaWxlZDogbm9kZUxvYWRGYWlsZWQsXG4gICAgICAgICAgICBub2RlTG9hZFByb21pc2VzOiBub2RlTG9hZFByb21pc2VzLFxuICAgICAgICB9O1xuICAgIH1cbiAgICB1cGRhdGVUcmVlTm9kZVZpc2liaWxpdHkocG9pbnRDbG91ZCwgbm9kZSwgdmlzaWJsZU5vZGVzKSB7XG4gICAgICAgIHRoaXMubHJ1LnRvdWNoKG5vZGUuZ2VvbWV0cnlOb2RlKTtcbiAgICAgICAgY29uc3Qgc2NlbmVOb2RlID0gbm9kZS5zY2VuZU5vZGU7XG4gICAgICAgIHNjZW5lTm9kZS52aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgc2NlbmVOb2RlLm1hdGVyaWFsID0gcG9pbnRDbG91ZC5tYXRlcmlhbDtcbiAgICAgICAgc2NlbmVOb2RlLnVwZGF0ZU1hdHJpeCgpO1xuICAgICAgICBzY2VuZU5vZGUubWF0cml4V29ybGQubXVsdGlwbHlNYXRyaWNlcyhwb2ludENsb3VkLm1hdHJpeFdvcmxkLCBzY2VuZU5vZGUubWF0cml4KTtcbiAgICAgICAgdmlzaWJsZU5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgIHBvaW50Q2xvdWQudmlzaWJsZU5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgIHRoaXMudXBkYXRlQm91bmRpbmdCb3hWaXNpYmlsaXR5KHBvaW50Q2xvdWQsIG5vZGUpO1xuICAgIH1cbiAgICB1cGRhdGVDaGlsZFZpc2liaWxpdHkocXVldWVJdGVtLCBwcmlvcml0eVF1ZXVlLCBwb2ludENsb3VkLCBub2RlLCBjYW1lcmFQb3NpdGlvbiwgY2FtZXJhLCBoYWxmSGVpZ2h0KSB7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGlmIChjaGlsZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc3BoZXJlID0gY2hpbGQuYm91bmRpbmdTcGhlcmU7XG4gICAgICAgICAgICBjb25zdCBkaXN0YW5jZSA9IHNwaGVyZS5jZW50ZXIuZGlzdGFuY2VUbyhjYW1lcmFQb3NpdGlvbik7XG4gICAgICAgICAgICBjb25zdCByYWRpdXMgPSBzcGhlcmUucmFkaXVzO1xuICAgICAgICAgICAgbGV0IHByb2plY3Rpb25GYWN0b3IgPSAwLjA7XG4gICAgICAgICAgICBpZiAoY2FtZXJhLnR5cGUgPT09IFBFUlNQRUNUSVZFX0NBTUVSQSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBlcnNwZWN0aXZlID0gY2FtZXJhO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZvdiA9IChwZXJzcGVjdGl2ZS5mb3YgKiBNYXRoLlBJKSAvIDE4MC4wO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNsb3BlID0gTWF0aC50YW4oZm92IC8gMi4wKTtcbiAgICAgICAgICAgICAgICBwcm9qZWN0aW9uRmFjdG9yID0gaGFsZkhlaWdodCAvIChzbG9wZSAqIGRpc3RhbmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9ydGhvZ3JhcGhpYyA9IGNhbWVyYTtcbiAgICAgICAgICAgICAgICBwcm9qZWN0aW9uRmFjdG9yID0gKDIgKiBoYWxmSGVpZ2h0KSAvIChvcnRob2dyYXBoaWMudG9wIC0gb3J0aG9ncmFwaGljLmJvdHRvbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzY3JlZW5QaXhlbFJhZGl1cyA9IHJhZGl1cyAqIHByb2plY3Rpb25GYWN0b3I7XG4gICAgICAgICAgICAvLyBEb24ndCBhZGQgdGhlIG5vZGUgaWYgaXQnbGwgYmUgdG9vIHNtYWxsIG9uIHRoZSBzY3JlZW4uXG4gICAgICAgICAgICBpZiAoc2NyZWVuUGl4ZWxSYWRpdXMgPCBwb2ludENsb3VkLm1pbk5vZGVQaXhlbFNpemUpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5vZGVzIHdoaWNoIGFyZSBsYXJnZXIgd2lsbCBoYXZlIHByaW9yaXR5IGluIGxvYWRpbmcvZGlzcGxheWluZy5cbiAgICAgICAgICAgIGNvbnN0IHdlaWdodCA9IGRpc3RhbmNlIDwgcmFkaXVzID8gTnVtYmVyLk1BWF9WQUxVRSA6IHNjcmVlblBpeGVsUmFkaXVzICsgMSAvIGRpc3RhbmNlO1xuICAgICAgICAgICAgcHJpb3JpdHlRdWV1ZS5wdXNoKG5ldyBRdWV1ZUl0ZW0ocXVldWVJdGVtLnBvaW50Q2xvdWRJbmRleCwgd2VpZ2h0LCBjaGlsZCwgbm9kZSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZUJvdW5kaW5nQm94VmlzaWJpbGl0eShwb2ludENsb3VkLCBub2RlKSB7XG4gICAgICAgIGlmIChwb2ludENsb3VkLnNob3dCb3VuZGluZ0JveCAmJiAhbm9kZS5ib3VuZGluZ0JveE5vZGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGJveEhlbHBlciA9IG5ldyBCb3gzSGVscGVyKG5vZGUuYm91bmRpbmdCb3gpO1xuICAgICAgICAgICAgYm94SGVscGVyLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgICAgIHBvaW50Q2xvdWQuYm91bmRpbmdCb3hOb2Rlcy5wdXNoKGJveEhlbHBlcik7XG4gICAgICAgICAgICBub2RlLmJvdW5kaW5nQm94Tm9kZSA9IGJveEhlbHBlcjtcbiAgICAgICAgICAgIG5vZGUuYm91bmRpbmdCb3hOb2RlLm1hdHJpeC5jb3B5KHBvaW50Q2xvdWQubWF0cml4V29ybGQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBvaW50Q2xvdWQuc2hvd0JvdW5kaW5nQm94ICYmIG5vZGUuYm91bmRpbmdCb3hOb2RlKSB7XG4gICAgICAgICAgICBub2RlLmJvdW5kaW5nQm94Tm9kZS52aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIG5vZGUuYm91bmRpbmdCb3hOb2RlLm1hdHJpeC5jb3B5KHBvaW50Q2xvdWQubWF0cml4V29ybGQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFwb2ludENsb3VkLnNob3dCb3VuZGluZ0JveCAmJiBub2RlLmJvdW5kaW5nQm94Tm9kZSkge1xuICAgICAgICAgICAgbm9kZS5ib3VuZGluZ0JveE5vZGUudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNob3VsZENsaXAocG9pbnRDbG91ZCwgYm91bmRpbmdCb3gpIHtcbiAgICAgICAgY29uc3QgbWF0ZXJpYWwgPSBwb2ludENsb3VkLm1hdGVyaWFsO1xuICAgICAgICBpZiAobWF0ZXJpYWwubnVtQ2xpcEJveGVzID09PSAwIHx8IG1hdGVyaWFsLmNsaXBNb2RlICE9PSBDbGlwTW9kZS5DTElQX09VVFNJREUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBib3gyID0gYm91bmRpbmdCb3guY2xvbmUoKTtcbiAgICAgICAgcG9pbnRDbG91ZC51cGRhdGVNYXRyaXhXb3JsZCh0cnVlKTtcbiAgICAgICAgYm94Mi5hcHBseU1hdHJpeDQocG9pbnRDbG91ZC5tYXRyaXhXb3JsZCk7XG4gICAgICAgIGNvbnN0IGNsaXBCb3hlcyA9IG1hdGVyaWFsLmNsaXBCb3hlcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjbGlwQm94ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGNsaXBNYXRyaXhXb3JsZCA9IGNsaXBCb3hlc1tpXS5tYXRyaXg7XG4gICAgICAgICAgICBjb25zdCBjbGlwQm94V29ybGQgPSBuZXcgQm94MyhuZXcgVmVjdG9yMygtMC41LCAtMC41LCAtMC41KSwgbmV3IFZlY3RvcjMoMC41LCAwLjUsIDAuNSkpLmFwcGx5TWF0cml4NChjbGlwTWF0cml4V29ybGQpO1xuICAgICAgICAgICAgaWYgKGJveDIuaW50ZXJzZWN0c0JveChjbGlwQm94V29ybGQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbiIsImV4cG9ydCAqIGZyb20gJy4vbG9hZC1vY3RyZWUnO1xuIiwiZXhwb3J0ICogZnJvbSAnLi9tYXRlcmlhbHMnO1xuZXhwb3J0ICogZnJvbSAnLi9wb2ludC1hdHRyaWJ1dGVzJztcbmV4cG9ydCAqIGZyb20gJy4vcG9pbnQtY2xvdWQtb2N0cmVlLWdlb21ldHJ5LW5vZGUnO1xuZXhwb3J0ICogZnJvbSAnLi9wb2ludC1jbG91ZC1vY3RyZWUtZ2VvbWV0cnknO1xuZXhwb3J0ICogZnJvbSAnLi9wb2ludC1jbG91ZC1vY3RyZWUtbm9kZSc7XG5leHBvcnQgKiBmcm9tICcuL3BvaW50LWNsb3VkLW9jdHJlZS1waWNrZXInO1xuZXhwb3J0ICogZnJvbSAnLi9wb2ludC1jbG91ZC1vY3RyZWUnO1xuZXhwb3J0ICogZnJvbSAnLi9wb2ludC1jbG91ZC10cmVlJztcbmV4cG9ydCAqIGZyb20gJy4vcG90cmVlJztcbmV4cG9ydCAqIGZyb20gJy4vdHlwZXMnO1xuZXhwb3J0ICogZnJvbSAnLi92ZXJzaW9uJztcbmV4cG9ydCB7IGxvYWRQT0MgYXMgVjFfTE9BREVSIH0gZnJvbSAnLi9sb2FkaW5nJztcbmV4cG9ydCB7IGxvYWRPY3RyZWUgYXMgVjJfTE9BREVSIH0gZnJvbSAnLi9sb2FkaW5nMic7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///599\n")},300:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ Worker_fn)\n/* harmony export */ });\n/* harmony import */ var _node_modules_worker_loader_dist_runtime_inline_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(512);\n/* harmony import */ var _node_modules_worker_loader_dist_runtime_inline_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_worker_loader_dist_runtime_inline_js__WEBPACK_IMPORTED_MODULE_0__);\n\n\n\nfunction Worker_fn() {\n  return _node_modules_worker_loader_dist_runtime_inline_js__WEBPACK_IMPORTED_MODULE_0___default()(\"(()=>{\\\"use strict\\\";var __webpack_modules__={256:()=>{eval(\\\"\\\\n;// CONCATENATED MODULE: ./src/loading2/point-attributes.ts\\\\n/**\\\\n * Some types of possible point attribute data formats\\\\n *\\\\n * @class\\\\n */\\\\nconst PointAttributeTypes = {\\\\n    DATA_TYPE_DOUBLE: { ordinal: 0, name: 'double', size: 8 },\\\\n    DATA_TYPE_FLOAT: { ordinal: 1, name: 'float', size: 4 },\\\\n    DATA_TYPE_INT8: { ordinal: 2, name: 'int8', size: 1 },\\\\n    DATA_TYPE_UINT8: { ordinal: 3, name: 'uint8', size: 1 },\\\\n    DATA_TYPE_INT16: { ordinal: 4, name: 'int16', size: 2 },\\\\n    DATA_TYPE_UINT16: { ordinal: 5, name: 'uint16', size: 2 },\\\\n    DATA_TYPE_INT32: { ordinal: 6, name: 'int32', size: 4 },\\\\n    DATA_TYPE_UINT32: { ordinal: 7, name: 'uint32', size: 4 },\\\\n    DATA_TYPE_INT64: { ordinal: 8, name: 'int64', size: 8 },\\\\n    DATA_TYPE_UINT64: { ordinal: 9, name: 'uint64', size: 8 }\\\\n};\\\\nlet i = 0;\\\\nfor (const obj in PointAttributeTypes) {\\\\n    PointAttributeTypes[i] = PointAttributeTypes[obj];\\\\n    i++;\\\\n}\\\\n\\\\nclass PointAttribute {\\\\n    constructor(name, type, numElements, range = [Infinity, -Infinity]) {\\\\n        this.name = name;\\\\n        this.type = type;\\\\n        this.numElements = numElements;\\\\n        this.range = range;\\\\n        this.byteSize = this.numElements * this.type.size;\\\\n        this.description = '';\\\\n    }\\\\n}\\\\n\\\\nconst POINT_ATTRIBUTES = {\\\\n    POSITION_CARTESIAN: new PointAttribute('POSITION_CARTESIAN', PointAttributeTypes.DATA_TYPE_FLOAT, 3),\\\\n    RGBA_PACKED: new PointAttribute('COLOR_PACKED', PointAttributeTypes.DATA_TYPE_INT8, 4),\\\\n    COLOR_PACKED: new PointAttribute('COLOR_PACKED', PointAttributeTypes.DATA_TYPE_INT8, 4),\\\\n    RGB_PACKED: new PointAttribute('COLOR_PACKED', PointAttributeTypes.DATA_TYPE_INT8, 3),\\\\n    NORMAL_FLOATS: new PointAttribute('NORMAL_FLOATS', PointAttributeTypes.DATA_TYPE_FLOAT, 3),\\\\n    INTENSITY: new PointAttribute('INTENSITY', PointAttributeTypes.DATA_TYPE_UINT16, 1),\\\\n    CLASSIFICATION: new PointAttribute('CLASSIFICATION', PointAttributeTypes.DATA_TYPE_UINT8, 1),\\\\n    NORMAL_SPHEREMAPPED: new PointAttribute('NORMAL_SPHEREMAPPED', PointAttributeTypes.DATA_TYPE_UINT8, 2),\\\\n    NORMAL_OCT16: new PointAttribute('NORMAL_OCT16', PointAttributeTypes.DATA_TYPE_UINT8, 2),\\\\n    NORMAL: new PointAttribute('NORMAL', PointAttributeTypes.DATA_TYPE_FLOAT, 3),\\\\n    RETURN_NUMBER: new PointAttribute('RETURN_NUMBER', PointAttributeTypes.DATA_TYPE_UINT8, 1),\\\\n    NUMBER_OF_RETURNS: new PointAttribute('NUMBER_OF_RETURNS', PointAttributeTypes.DATA_TYPE_UINT8, 1),\\\\n    SOURCE_ID: new PointAttribute('SOURCE_ID', PointAttributeTypes.DATA_TYPE_UINT16, 1),\\\\n    INDICES: new PointAttribute('INDICES', PointAttributeTypes.DATA_TYPE_UINT32, 1),\\\\n    SPACING: new PointAttribute('SPACING', PointAttributeTypes.DATA_TYPE_FLOAT, 1),\\\\n    GPS_TIME: new PointAttribute('GPS_TIME', PointAttributeTypes.DATA_TYPE_DOUBLE, 1)\\\\n};\\\\nclass PointAttributes {\\\\n    constructor(pointAttributes, attributes = [], byteSize = 0, size = 0, vectors = []) {\\\\n        this.attributes = attributes;\\\\n        this.byteSize = byteSize;\\\\n        this.size = size;\\\\n        this.vectors = vectors;\\\\n        if (pointAttributes != null) {\\\\n            for (let i = 0; i < pointAttributes.length; i++) {\\\\n                const pointAttributeName = pointAttributes[i];\\\\n                const pointAttribute = POINT_ATTRIBUTES[pointAttributeName];\\\\n                this.attributes.push(pointAttribute);\\\\n                this.byteSize += pointAttribute.byteSize;\\\\n                this.size++;\\\\n            }\\\\n        }\\\\n    }\\\\n    add(pointAttribute) {\\\\n        this.attributes.push(pointAttribute);\\\\n        this.byteSize += pointAttribute.byteSize;\\\\n        this.size++;\\\\n    }\\\\n    addVector(vector) {\\\\n        this.vectors.push(vector);\\\\n    }\\\\n    hasNormals() {\\\\n        for (const name in this.attributes) {\\\\n            const pointAttribute = this.attributes[name];\\\\n            if (pointAttribute === POINT_ATTRIBUTES.NORMAL_SPHEREMAPPED ||\\\\n                pointAttribute === POINT_ATTRIBUTES.NORMAL_FLOATS ||\\\\n                pointAttribute === POINT_ATTRIBUTES.NORMAL ||\\\\n                pointAttribute === POINT_ATTRIBUTES.NORMAL_OCT16) {\\\\n                return true;\\\\n            }\\\\n        }\\\\n        return false;\\\\n    }\\\\n}\\\\n\\\\n;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./src/loading2/decoder.worker.js\\\\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\\\\nfunction _nonIterableRest() { throw new TypeError(\\\\\\\"Invalid attempt to destructure non-iterable instance.\\\\\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\\\\\\\"); }\\\\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \\\\\\\"undefined\\\\\\\" != typeof Symbol && r[Symbol.iterator] || r[\\\\\\\"@@iterator\\\\\\\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\\\\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\\\\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \\\\\\\"undefined\\\\\\\" && o[Symbol.iterator] || o[\\\\\\\"@@iterator\\\\\\\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \\\\\\\"number\\\\\\\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\\\\\\\"Invalid attempt to iterate non-iterable instance.\\\\\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\\\\\\\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\\\\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \\\\\\\"string\\\\\\\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \\\\\\\"Object\\\\\\\" && o.constructor) n = o.constructor.name; if (n === \\\\\\\"Map\\\\\\\" || n === \\\\\\\"Set\\\\\\\") return Array.from(o); if (n === \\\\\\\"Arguments\\\\\\\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\\\\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\\\\n\\\\nvar typedArrayMapping = {\\\\n  'int8': Int8Array,\\\\n  'int16': Int16Array,\\\\n  'int32': Int32Array,\\\\n  'int64': Float64Array,\\\\n  'uint8': Uint8Array,\\\\n  'uint16': Uint16Array,\\\\n  'uint32': Uint32Array,\\\\n  'uint64': Float64Array,\\\\n  'float': Float32Array,\\\\n  'double': Float64Array\\\\n};\\\\nonmessage = function onmessage(event) {\\\\n  var _event$data = event.data,\\\\n    buffer = _event$data.buffer,\\\\n    pointAttributes = _event$data.pointAttributes,\\\\n    scale = _event$data.scale,\\\\n    name = _event$data.name,\\\\n    min = _event$data.min,\\\\n    max = _event$data.max,\\\\n    size = _event$data.size,\\\\n    offset = _event$data.offset,\\\\n    numPoints = _event$data.numPoints;\\\\n  var view = new DataView(buffer);\\\\n  var attributeBuffers = {};\\\\n  var attributeOffset = 0;\\\\n  var bytesPerPoint = 0;\\\\n  var _iterator = _createForOfIteratorHelper(pointAttributes.attributes),\\\\n    _step;\\\\n  try {\\\\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\\\\n      var pointAttribute = _step.value;\\\\n      bytesPerPoint += pointAttribute.byteSize;\\\\n    }\\\\n  } catch (err) {\\\\n    _iterator.e(err);\\\\n  } finally {\\\\n    _iterator.f();\\\\n  }\\\\n  var gridSize = 32;\\\\n  var grid = new Uint32Array(Math.pow(gridSize, 3));\\\\n  var toIndex = function toIndex(x, y, z) {\\\\n    // min is already subtracted\\\\n    var dx = gridSize * x / size.x;\\\\n    var dy = gridSize * y / size.y;\\\\n    var dz = gridSize * z / size.z;\\\\n    var ix = Math.min(parseInt(dx), gridSize - 1);\\\\n    var iy = Math.min(parseInt(dy), gridSize - 1);\\\\n    var iz = Math.min(parseInt(dz), gridSize - 1);\\\\n    var index = ix + iy * gridSize + iz * gridSize * gridSize;\\\\n    return index;\\\\n  };\\\\n  var numOccupiedCells = 0;\\\\n  var _iterator2 = _createForOfIteratorHelper(pointAttributes.attributes),\\\\n    _step2;\\\\n  try {\\\\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\\\\n      var _pointAttribute = _step2.value;\\\\n      if (['POSITION_CARTESIAN', 'position'].includes(_pointAttribute.name)) {\\\\n        var _buff = new ArrayBuffer(numPoints * 4 * 3);\\\\n        var positions = new Float32Array(_buff);\\\\n        for (var _j = 0; _j < numPoints; _j++) {\\\\n          var pointOffset = _j * bytesPerPoint;\\\\n          var x = view.getInt32(pointOffset + attributeOffset + 0, true) * scale[0] + offset[0] - min.x;\\\\n          var y = view.getInt32(pointOffset + attributeOffset + 4, true) * scale[1] + offset[1] - min.y;\\\\n          var z = view.getInt32(pointOffset + attributeOffset + 8, true) * scale[2] + offset[2] - min.z;\\\\n          var index = toIndex(x, y, z);\\\\n          var count = grid[index]++;\\\\n          if (count === 0) {\\\\n            numOccupiedCells++;\\\\n          }\\\\n          positions[3 * _j + 0] = x;\\\\n          positions[3 * _j + 1] = y;\\\\n          positions[3 * _j + 2] = z;\\\\n        }\\\\n        attributeBuffers[_pointAttribute.name] = {\\\\n          buffer: _buff,\\\\n          attribute: _pointAttribute\\\\n        };\\\\n      } else if (['RGBA', 'rgba'].includes(_pointAttribute.name)) {\\\\n        var _buff2 = new ArrayBuffer(numPoints * 4);\\\\n        var colors = new Uint8Array(_buff2);\\\\n        for (var _j2 = 0; _j2 < numPoints; _j2++) {\\\\n          var _pointOffset = _j2 * bytesPerPoint;\\\\n          var r = view.getUint16(_pointOffset + attributeOffset + 0, true);\\\\n          var g = view.getUint16(_pointOffset + attributeOffset + 2, true);\\\\n          var b = view.getUint16(_pointOffset + attributeOffset + 4, true);\\\\n          colors[4 * _j2 + 0] = r > 255 ? r / 256 : r;\\\\n          colors[4 * _j2 + 1] = g > 255 ? g / 256 : g;\\\\n          colors[4 * _j2 + 2] = b > 255 ? b / 256 : b;\\\\n        }\\\\n        attributeBuffers[_pointAttribute.name] = {\\\\n          buffer: _buff2,\\\\n          attribute: _pointAttribute\\\\n        };\\\\n      } else {\\\\n        var _buff3 = new ArrayBuffer(numPoints * 4);\\\\n        var _f = new Float32Array(_buff3);\\\\n        var TypedArray = typedArrayMapping[_pointAttribute.type.name];\\\\n        var preciseBuffer = new TypedArray(numPoints);\\\\n        var _offset2 = 0,\\\\n          _scale2 = 1;\\\\n        var getterMap = {\\\\n          'int8': view.getInt8,\\\\n          'int16': view.getInt16,\\\\n          'int32': view.getInt32,\\\\n          // 'int64':  view.getInt64,\\\\n          'uint8': view.getUint8,\\\\n          'uint16': view.getUint16,\\\\n          'uint32': view.getUint32,\\\\n          // 'uint64': view.getUint64,\\\\n          'float': view.getFloat32,\\\\n          'double': view.getFloat64\\\\n        };\\\\n        var _getter = getterMap[_pointAttribute.type.name].bind(view);\\\\n\\\\n        // compute offset and scale to pack larger types into 32 bit floats\\\\n        if (_pointAttribute.type.size > 4) {\\\\n          var _pointAttribute$range = _slicedToArray(_pointAttribute.range, 2),\\\\n            amin = _pointAttribute$range[0],\\\\n            amax = _pointAttribute$range[1];\\\\n          _offset2 = amin;\\\\n          _scale2 = 1 / (amax - amin);\\\\n        }\\\\n        for (var _j3 = 0; _j3 < numPoints; _j3++) {\\\\n          var _pointOffset2 = _j3 * bytesPerPoint;\\\\n          var _value = _getter(_pointOffset2 + attributeOffset, true);\\\\n          _f[_j3] = (_value - _offset2) * _scale2;\\\\n          preciseBuffer[_j3] = _value;\\\\n        }\\\\n        attributeBuffers[_pointAttribute.name] = {\\\\n          buffer: _buff3,\\\\n          preciseBuffer: preciseBuffer,\\\\n          attribute: _pointAttribute,\\\\n          offset: _offset2,\\\\n          scale: _scale2\\\\n        };\\\\n      }\\\\n      attributeOffset += _pointAttribute.byteSize;\\\\n    }\\\\n  } catch (err) {\\\\n    _iterator2.e(err);\\\\n  } finally {\\\\n    _iterator2.f();\\\\n  }\\\\n  var occupancy = parseInt(numPoints / numOccupiedCells);\\\\n  {\\\\n    // add indices\\\\n    var buff = new ArrayBuffer(numPoints * 4);\\\\n    var indices = new Uint32Array(buff);\\\\n    for (var i = 0; i < numPoints; i++) {\\\\n      indices[i] = i;\\\\n    }\\\\n    attributeBuffers['INDICES'] = {\\\\n      buffer: buff,\\\\n      attribute: PointAttribute.INDICES\\\\n    };\\\\n  }\\\\n  {\\\\n    // handle attribute vectors\\\\n    var vectors = pointAttributes.vectors;\\\\n    var _iterator3 = _createForOfIteratorHelper(vectors),\\\\n      _step3;\\\\n    try {\\\\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\\\\n        var vector = _step3.value;\\\\n        var _name = vector.name,\\\\n          attributes = vector.attributes;\\\\n        var numVectorElements = attributes.length;\\\\n        var _buffer = new ArrayBuffer(numVectorElements * numPoints * 4);\\\\n        var f32 = new Float32Array(_buffer);\\\\n        var iElement = 0;\\\\n        var _iterator4 = _createForOfIteratorHelper(attributes),\\\\n          _step4;\\\\n        try {\\\\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\\\\n            var sourceName = _step4.value;\\\\n            var sourceBuffer = attributeBuffers[sourceName];\\\\n            var _offset = sourceBuffer.offset,\\\\n              _scale = sourceBuffer.scale;\\\\n            var _view = new DataView(sourceBuffer.buffer);\\\\n            var getter = _view.getFloat32.bind(_view);\\\\n            for (var j = 0; j < numPoints; j++) {\\\\n              var value = getter(j * 4, true);\\\\n              f32[j * numVectorElements + iElement] = value / _scale + _offset;\\\\n            }\\\\n            iElement++;\\\\n          }\\\\n        } catch (err) {\\\\n          _iterator4.e(err);\\\\n        } finally {\\\\n          _iterator4.f();\\\\n        }\\\\n        var vecAttribute = new PointAttribute(_name, PointAttributeTypes.DATA_TYPE_FLOAT, 3);\\\\n        attributeBuffers[_name] = {\\\\n          buffer: _buffer,\\\\n          attribute: vecAttribute\\\\n        };\\\\n      }\\\\n    } catch (err) {\\\\n      _iterator3.e(err);\\\\n    } finally {\\\\n      _iterator3.f();\\\\n    }\\\\n  }\\\\n  var message = {\\\\n    buffer: buffer,\\\\n    attributeBuffers: attributeBuffers,\\\\n    density: occupancy\\\\n  };\\\\n  var transferables = [];\\\\n  for (var property in message.attributeBuffers) {\\\\n    transferables.push(message.attributeBuffers[property].buffer);\\\\n  }\\\\n  transferables.push(buffer);\\\\n  postMessage(message, transferables);\\\\n};//# sourceURL=[module]\\\\n\\\")}},__webpack_exports__={};__webpack_modules__[256]()})();\", \"Worker\", undefined, undefined);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzAwLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG90cmVlLy4vc3JjL2xvYWRpbmcyL2RlY29kZXIud29ya2VyLmpzP2RiNzgiXSwic291cmNlc0NvbnRlbnQiOlsiXG5pbXBvcnQgd29ya2VyIGZyb20gXCIhIS4uLy4uL25vZGVfbW9kdWxlcy93b3JrZXItbG9hZGVyL2Rpc3QvcnVudGltZS9pbmxpbmUuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gV29ya2VyX2ZuKCkge1xuICByZXR1cm4gd29ya2VyKFwiKCgpPT57XFxcInVzZSBzdHJpY3RcXFwiO3ZhciBfX3dlYnBhY2tfbW9kdWxlc19fPXsyNTY6KCk9PntldmFsKFxcXCJcXFxcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9sb2FkaW5nMi9wb2ludC1hdHRyaWJ1dGVzLnRzXFxcXG4vKipcXFxcbiAqIFNvbWUgdHlwZXMgb2YgcG9zc2libGUgcG9pbnQgYXR0cmlidXRlIGRhdGEgZm9ybWF0c1xcXFxuICpcXFxcbiAqIEBjbGFzc1xcXFxuICovXFxcXG5jb25zdCBQb2ludEF0dHJpYnV0ZVR5cGVzID0ge1xcXFxuICAgIERBVEFfVFlQRV9ET1VCTEU6IHsgb3JkaW5hbDogMCwgbmFtZTogJ2RvdWJsZScsIHNpemU6IDggfSxcXFxcbiAgICBEQVRBX1RZUEVfRkxPQVQ6IHsgb3JkaW5hbDogMSwgbmFtZTogJ2Zsb2F0Jywgc2l6ZTogNCB9LFxcXFxuICAgIERBVEFfVFlQRV9JTlQ4OiB7IG9yZGluYWw6IDIsIG5hbWU6ICdpbnQ4Jywgc2l6ZTogMSB9LFxcXFxuICAgIERBVEFfVFlQRV9VSU5UODogeyBvcmRpbmFsOiAzLCBuYW1lOiAndWludDgnLCBzaXplOiAxIH0sXFxcXG4gICAgREFUQV9UWVBFX0lOVDE2OiB7IG9yZGluYWw6IDQsIG5hbWU6ICdpbnQxNicsIHNpemU6IDIgfSxcXFxcbiAgICBEQVRBX1RZUEVfVUlOVDE2OiB7IG9yZGluYWw6IDUsIG5hbWU6ICd1aW50MTYnLCBzaXplOiAyIH0sXFxcXG4gICAgREFUQV9UWVBFX0lOVDMyOiB7IG9yZGluYWw6IDYsIG5hbWU6ICdpbnQzMicsIHNpemU6IDQgfSxcXFxcbiAgICBEQVRBX1RZUEVfVUlOVDMyOiB7IG9yZGluYWw6IDcsIG5hbWU6ICd1aW50MzInLCBzaXplOiA0IH0sXFxcXG4gICAgREFUQV9UWVBFX0lOVDY0OiB7IG9yZGluYWw6IDgsIG5hbWU6ICdpbnQ2NCcsIHNpemU6IDggfSxcXFxcbiAgICBEQVRBX1RZUEVfVUlOVDY0OiB7IG9yZGluYWw6IDksIG5hbWU6ICd1aW50NjQnLCBzaXplOiA4IH1cXFxcbn07XFxcXG5sZXQgaSA9IDA7XFxcXG5mb3IgKGNvbnN0IG9iaiBpbiBQb2ludEF0dHJpYnV0ZVR5cGVzKSB7XFxcXG4gICAgUG9pbnRBdHRyaWJ1dGVUeXBlc1tpXSA9IFBvaW50QXR0cmlidXRlVHlwZXNbb2JqXTtcXFxcbiAgICBpKys7XFxcXG59XFxcXG5cXFxcbmNsYXNzIFBvaW50QXR0cmlidXRlIHtcXFxcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCB0eXBlLCBudW1FbGVtZW50cywgcmFuZ2UgPSBbSW5maW5pdHksIC1JbmZpbml0eV0pIHtcXFxcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcXFxcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcXFxcbiAgICAgICAgdGhpcy5udW1FbGVtZW50cyA9IG51bUVsZW1lbnRzO1xcXFxuICAgICAgICB0aGlzLnJhbmdlID0gcmFuZ2U7XFxcXG4gICAgICAgIHRoaXMuYnl0ZVNpemUgPSB0aGlzLm51bUVsZW1lbnRzICogdGhpcy50eXBlLnNpemU7XFxcXG4gICAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSAnJztcXFxcbiAgICB9XFxcXG59XFxcXG5cXFxcbmNvbnN0IFBPSU5UX0FUVFJJQlVURVMgPSB7XFxcXG4gICAgUE9TSVRJT05fQ0FSVEVTSUFOOiBuZXcgUG9pbnRBdHRyaWJ1dGUoJ1BPU0lUSU9OX0NBUlRFU0lBTicsIFBvaW50QXR0cmlidXRlVHlwZXMuREFUQV9UWVBFX0ZMT0FULCAzKSxcXFxcbiAgICBSR0JBX1BBQ0tFRDogbmV3IFBvaW50QXR0cmlidXRlKCdDT0xPUl9QQUNLRUQnLCBQb2ludEF0dHJpYnV0ZVR5cGVzLkRBVEFfVFlQRV9JTlQ4LCA0KSxcXFxcbiAgICBDT0xPUl9QQUNLRUQ6IG5ldyBQb2ludEF0dHJpYnV0ZSgnQ09MT1JfUEFDS0VEJywgUG9pbnRBdHRyaWJ1dGVUeXBlcy5EQVRBX1RZUEVfSU5UOCwgNCksXFxcXG4gICAgUkdCX1BBQ0tFRDogbmV3IFBvaW50QXR0cmlidXRlKCdDT0xPUl9QQUNLRUQnLCBQb2ludEF0dHJpYnV0ZVR5cGVzLkRBVEFfVFlQRV9JTlQ4LCAzKSxcXFxcbiAgICBOT1JNQUxfRkxPQVRTOiBuZXcgUG9pbnRBdHRyaWJ1dGUoJ05PUk1BTF9GTE9BVFMnLCBQb2ludEF0dHJpYnV0ZVR5cGVzLkRBVEFfVFlQRV9GTE9BVCwgMyksXFxcXG4gICAgSU5URU5TSVRZOiBuZXcgUG9pbnRBdHRyaWJ1dGUoJ0lOVEVOU0lUWScsIFBvaW50QXR0cmlidXRlVHlwZXMuREFUQV9UWVBFX1VJTlQxNiwgMSksXFxcXG4gICAgQ0xBU1NJRklDQVRJT046IG5ldyBQb2ludEF0dHJpYnV0ZSgnQ0xBU1NJRklDQVRJT04nLCBQb2ludEF0dHJpYnV0ZVR5cGVzLkRBVEFfVFlQRV9VSU5UOCwgMSksXFxcXG4gICAgTk9STUFMX1NQSEVSRU1BUFBFRDogbmV3IFBvaW50QXR0cmlidXRlKCdOT1JNQUxfU1BIRVJFTUFQUEVEJywgUG9pbnRBdHRyaWJ1dGVUeXBlcy5EQVRBX1RZUEVfVUlOVDgsIDIpLFxcXFxuICAgIE5PUk1BTF9PQ1QxNjogbmV3IFBvaW50QXR0cmlidXRlKCdOT1JNQUxfT0NUMTYnLCBQb2ludEF0dHJpYnV0ZVR5cGVzLkRBVEFfVFlQRV9VSU5UOCwgMiksXFxcXG4gICAgTk9STUFMOiBuZXcgUG9pbnRBdHRyaWJ1dGUoJ05PUk1BTCcsIFBvaW50QXR0cmlidXRlVHlwZXMuREFUQV9UWVBFX0ZMT0FULCAzKSxcXFxcbiAgICBSRVRVUk5fTlVNQkVSOiBuZXcgUG9pbnRBdHRyaWJ1dGUoJ1JFVFVSTl9OVU1CRVInLCBQb2ludEF0dHJpYnV0ZVR5cGVzLkRBVEFfVFlQRV9VSU5UOCwgMSksXFxcXG4gICAgTlVNQkVSX09GX1JFVFVSTlM6IG5ldyBQb2ludEF0dHJpYnV0ZSgnTlVNQkVSX09GX1JFVFVSTlMnLCBQb2ludEF0dHJpYnV0ZVR5cGVzLkRBVEFfVFlQRV9VSU5UOCwgMSksXFxcXG4gICAgU09VUkNFX0lEOiBuZXcgUG9pbnRBdHRyaWJ1dGUoJ1NPVVJDRV9JRCcsIFBvaW50QXR0cmlidXRlVHlwZXMuREFUQV9UWVBFX1VJTlQxNiwgMSksXFxcXG4gICAgSU5ESUNFUzogbmV3IFBvaW50QXR0cmlidXRlKCdJTkRJQ0VTJywgUG9pbnRBdHRyaWJ1dGVUeXBlcy5EQVRBX1RZUEVfVUlOVDMyLCAxKSxcXFxcbiAgICBTUEFDSU5HOiBuZXcgUG9pbnRBdHRyaWJ1dGUoJ1NQQUNJTkcnLCBQb2ludEF0dHJpYnV0ZVR5cGVzLkRBVEFfVFlQRV9GTE9BVCwgMSksXFxcXG4gICAgR1BTX1RJTUU6IG5ldyBQb2ludEF0dHJpYnV0ZSgnR1BTX1RJTUUnLCBQb2ludEF0dHJpYnV0ZVR5cGVzLkRBVEFfVFlQRV9ET1VCTEUsIDEpXFxcXG59O1xcXFxuY2xhc3MgUG9pbnRBdHRyaWJ1dGVzIHtcXFxcbiAgICBjb25zdHJ1Y3Rvcihwb2ludEF0dHJpYnV0ZXMsIGF0dHJpYnV0ZXMgPSBbXSwgYnl0ZVNpemUgPSAwLCBzaXplID0gMCwgdmVjdG9ycyA9IFtdKSB7XFxcXG4gICAgICAgIHRoaXMuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XFxcXG4gICAgICAgIHRoaXMuYnl0ZVNpemUgPSBieXRlU2l6ZTtcXFxcbiAgICAgICAgdGhpcy5zaXplID0gc2l6ZTtcXFxcbiAgICAgICAgdGhpcy52ZWN0b3JzID0gdmVjdG9ycztcXFxcbiAgICAgICAgaWYgKHBvaW50QXR0cmlidXRlcyAhPSBudWxsKSB7XFxcXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50QXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xcXFxuICAgICAgICAgICAgICAgIGNvbnN0IHBvaW50QXR0cmlidXRlTmFtZSA9IHBvaW50QXR0cmlidXRlc1tpXTtcXFxcbiAgICAgICAgICAgICAgICBjb25zdCBwb2ludEF0dHJpYnV0ZSA9IFBPSU5UX0FUVFJJQlVURVNbcG9pbnRBdHRyaWJ1dGVOYW1lXTtcXFxcbiAgICAgICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZXMucHVzaChwb2ludEF0dHJpYnV0ZSk7XFxcXG4gICAgICAgICAgICAgICAgdGhpcy5ieXRlU2l6ZSArPSBwb2ludEF0dHJpYnV0ZS5ieXRlU2l6ZTtcXFxcbiAgICAgICAgICAgICAgICB0aGlzLnNpemUrKztcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgfVxcXFxuICAgIH1cXFxcbiAgICBhZGQocG9pbnRBdHRyaWJ1dGUpIHtcXFxcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVzLnB1c2gocG9pbnRBdHRyaWJ1dGUpO1xcXFxuICAgICAgICB0aGlzLmJ5dGVTaXplICs9IHBvaW50QXR0cmlidXRlLmJ5dGVTaXplO1xcXFxuICAgICAgICB0aGlzLnNpemUrKztcXFxcbiAgICB9XFxcXG4gICAgYWRkVmVjdG9yKHZlY3Rvcikge1xcXFxuICAgICAgICB0aGlzLnZlY3RvcnMucHVzaCh2ZWN0b3IpO1xcXFxuICAgIH1cXFxcbiAgICBoYXNOb3JtYWxzKCkge1xcXFxuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gdGhpcy5hdHRyaWJ1dGVzKSB7XFxcXG4gICAgICAgICAgICBjb25zdCBwb2ludEF0dHJpYnV0ZSA9IHRoaXMuYXR0cmlidXRlc1tuYW1lXTtcXFxcbiAgICAgICAgICAgIGlmIChwb2ludEF0dHJpYnV0ZSA9PT0gUE9JTlRfQVRUUklCVVRFUy5OT1JNQUxfU1BIRVJFTUFQUEVEIHx8XFxcXG4gICAgICAgICAgICAgICAgcG9pbnRBdHRyaWJ1dGUgPT09IFBPSU5UX0FUVFJJQlVURVMuTk9STUFMX0ZMT0FUUyB8fFxcXFxuICAgICAgICAgICAgICAgIHBvaW50QXR0cmlidXRlID09PSBQT0lOVF9BVFRSSUJVVEVTLk5PUk1BTCB8fFxcXFxuICAgICAgICAgICAgICAgIHBvaW50QXR0cmlidXRlID09PSBQT0lOVF9BVFRSSUJVVEVTLk5PUk1BTF9PQ1QxNikge1xcXFxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICB9XFxcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXFxcbiAgICB9XFxcXG59XFxcXG5cXFxcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4vc3JjL2xvYWRpbmcyL2RlY29kZXIud29ya2VyLmpzXFxcXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHsgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTsgfVxcXFxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFxcXFxcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxcXFxcXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlxcXFxcXFwiKTsgfVxcXFxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KHIsIGwpIHsgdmFyIHQgPSBudWxsID09IHIgPyBudWxsIDogXFxcXFxcXCJ1bmRlZmluZWRcXFxcXFxcIiAhPSB0eXBlb2YgU3ltYm9sICYmIHJbU3ltYm9sLml0ZXJhdG9yXSB8fCByW1xcXFxcXFwiQEBpdGVyYXRvclxcXFxcXFwiXTsgaWYgKG51bGwgIT0gdCkgeyB2YXIgZSwgbiwgaSwgdSwgYSA9IFtdLCBmID0gITAsIG8gPSAhMTsgdHJ5IHsgaWYgKGkgPSAodCA9IHQuY2FsbChyKSkubmV4dCwgMCA9PT0gbCkgeyBpZiAoT2JqZWN0KHQpICE9PSB0KSByZXR1cm47IGYgPSAhMTsgfSBlbHNlIGZvciAoOyAhKGYgPSAoZSA9IGkuY2FsbCh0KSkuZG9uZSkgJiYgKGEucHVzaChlLnZhbHVlKSwgYS5sZW5ndGggIT09IGwpOyBmID0gITApOyB9IGNhdGNoIChyKSB7IG8gPSAhMCwgbiA9IHI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghZiAmJiBudWxsICE9IHQucmV0dXJuICYmICh1ID0gdC5yZXR1cm4oKSwgT2JqZWN0KHUpICE9PSB1KSkgcmV0dXJuOyB9IGZpbmFsbHkgeyBpZiAobykgdGhyb3cgbjsgfSB9IHJldHVybiBhOyB9IH1cXFxcbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjsgfVxcXFxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0ID0gdHlwZW9mIFN5bWJvbCAhPT0gXFxcXFxcXCJ1bmRlZmluZWRcXFxcXFxcIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0gfHwgb1tcXFxcXFxcIkBAaXRlcmF0b3JcXFxcXFxcIl07IGlmICghaXQpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXFxcXFxcXCJudW1iZXJcXFxcXFxcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXFxcXFxcXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxcXFxcXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlxcXFxcXFwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gaXQuY2FsbChvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdC5yZXR1cm4gIT0gbnVsbCkgaXQucmV0dXJuKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cXFxcbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXFxcXFxcXCJzdHJpbmdcXFxcXFxcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFxcXFxcXFwiT2JqZWN0XFxcXFxcXCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFxcXFxcXFwiTWFwXFxcXFxcXCIgfHwgbiA9PT0gXFxcXFxcXCJTZXRcXFxcXFxcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcXFxcXFxcIkFyZ3VtZW50c1xcXFxcXFwiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxcXFxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTsgcmV0dXJuIGFycjI7IH1cXFxcblxcXFxudmFyIHR5cGVkQXJyYXlNYXBwaW5nID0ge1xcXFxuICAnaW50OCc6IEludDhBcnJheSxcXFxcbiAgJ2ludDE2JzogSW50MTZBcnJheSxcXFxcbiAgJ2ludDMyJzogSW50MzJBcnJheSxcXFxcbiAgJ2ludDY0JzogRmxvYXQ2NEFycmF5LFxcXFxuICAndWludDgnOiBVaW50OEFycmF5LFxcXFxuICAndWludDE2JzogVWludDE2QXJyYXksXFxcXG4gICd1aW50MzInOiBVaW50MzJBcnJheSxcXFxcbiAgJ3VpbnQ2NCc6IEZsb2F0NjRBcnJheSxcXFxcbiAgJ2Zsb2F0JzogRmxvYXQzMkFycmF5LFxcXFxuICAnZG91YmxlJzogRmxvYXQ2NEFycmF5XFxcXG59O1xcXFxub25tZXNzYWdlID0gZnVuY3Rpb24gb25tZXNzYWdlKGV2ZW50KSB7XFxcXG4gIHZhciBfZXZlbnQkZGF0YSA9IGV2ZW50LmRhdGEsXFxcXG4gICAgYnVmZmVyID0gX2V2ZW50JGRhdGEuYnVmZmVyLFxcXFxuICAgIHBvaW50QXR0cmlidXRlcyA9IF9ldmVudCRkYXRhLnBvaW50QXR0cmlidXRlcyxcXFxcbiAgICBzY2FsZSA9IF9ldmVudCRkYXRhLnNjYWxlLFxcXFxuICAgIG5hbWUgPSBfZXZlbnQkZGF0YS5uYW1lLFxcXFxuICAgIG1pbiA9IF9ldmVudCRkYXRhLm1pbixcXFxcbiAgICBtYXggPSBfZXZlbnQkZGF0YS5tYXgsXFxcXG4gICAgc2l6ZSA9IF9ldmVudCRkYXRhLnNpemUsXFxcXG4gICAgb2Zmc2V0ID0gX2V2ZW50JGRhdGEub2Zmc2V0LFxcXFxuICAgIG51bVBvaW50cyA9IF9ldmVudCRkYXRhLm51bVBvaW50cztcXFxcbiAgdmFyIHZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyKTtcXFxcbiAgdmFyIGF0dHJpYnV0ZUJ1ZmZlcnMgPSB7fTtcXFxcbiAgdmFyIGF0dHJpYnV0ZU9mZnNldCA9IDA7XFxcXG4gIHZhciBieXRlc1BlclBvaW50ID0gMDtcXFxcbiAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHBvaW50QXR0cmlidXRlcy5hdHRyaWJ1dGVzKSxcXFxcbiAgICBfc3RlcDtcXFxcbiAgdHJ5IHtcXFxcbiAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xcXFxuICAgICAgdmFyIHBvaW50QXR0cmlidXRlID0gX3N0ZXAudmFsdWU7XFxcXG4gICAgICBieXRlc1BlclBvaW50ICs9IHBvaW50QXR0cmlidXRlLmJ5dGVTaXplO1xcXFxuICAgIH1cXFxcbiAgfSBjYXRjaCAoZXJyKSB7XFxcXG4gICAgX2l0ZXJhdG9yLmUoZXJyKTtcXFxcbiAgfSBmaW5hbGx5IHtcXFxcbiAgICBfaXRlcmF0b3IuZigpO1xcXFxuICB9XFxcXG4gIHZhciBncmlkU2l6ZSA9IDMyO1xcXFxuICB2YXIgZ3JpZCA9IG5ldyBVaW50MzJBcnJheShNYXRoLnBvdyhncmlkU2l6ZSwgMykpO1xcXFxuICB2YXIgdG9JbmRleCA9IGZ1bmN0aW9uIHRvSW5kZXgoeCwgeSwgeikge1xcXFxuICAgIC8vIG1pbiBpcyBhbHJlYWR5IHN1YnRyYWN0ZWRcXFxcbiAgICB2YXIgZHggPSBncmlkU2l6ZSAqIHggLyBzaXplLng7XFxcXG4gICAgdmFyIGR5ID0gZ3JpZFNpemUgKiB5IC8gc2l6ZS55O1xcXFxuICAgIHZhciBkeiA9IGdyaWRTaXplICogeiAvIHNpemUuejtcXFxcbiAgICB2YXIgaXggPSBNYXRoLm1pbihwYXJzZUludChkeCksIGdyaWRTaXplIC0gMSk7XFxcXG4gICAgdmFyIGl5ID0gTWF0aC5taW4ocGFyc2VJbnQoZHkpLCBncmlkU2l6ZSAtIDEpO1xcXFxuICAgIHZhciBpeiA9IE1hdGgubWluKHBhcnNlSW50KGR6KSwgZ3JpZFNpemUgLSAxKTtcXFxcbiAgICB2YXIgaW5kZXggPSBpeCArIGl5ICogZ3JpZFNpemUgKyBpeiAqIGdyaWRTaXplICogZ3JpZFNpemU7XFxcXG4gICAgcmV0dXJuIGluZGV4O1xcXFxuICB9O1xcXFxuICB2YXIgbnVtT2NjdXBpZWRDZWxscyA9IDA7XFxcXG4gIHZhciBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIocG9pbnRBdHRyaWJ1dGVzLmF0dHJpYnV0ZXMpLFxcXFxuICAgIF9zdGVwMjtcXFxcbiAgdHJ5IHtcXFxcbiAgICBmb3IgKF9pdGVyYXRvcjIucygpOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lOykge1xcXFxuICAgICAgdmFyIF9wb2ludEF0dHJpYnV0ZSA9IF9zdGVwMi52YWx1ZTtcXFxcbiAgICAgIGlmIChbJ1BPU0lUSU9OX0NBUlRFU0lBTicsICdwb3NpdGlvbiddLmluY2x1ZGVzKF9wb2ludEF0dHJpYnV0ZS5uYW1lKSkge1xcXFxuICAgICAgICB2YXIgX2J1ZmYgPSBuZXcgQXJyYXlCdWZmZXIobnVtUG9pbnRzICogNCAqIDMpO1xcXFxuICAgICAgICB2YXIgcG9zaXRpb25zID0gbmV3IEZsb2F0MzJBcnJheShfYnVmZik7XFxcXG4gICAgICAgIGZvciAodmFyIF9qID0gMDsgX2ogPCBudW1Qb2ludHM7IF9qKyspIHtcXFxcbiAgICAgICAgICB2YXIgcG9pbnRPZmZzZXQgPSBfaiAqIGJ5dGVzUGVyUG9pbnQ7XFxcXG4gICAgICAgICAgdmFyIHggPSB2aWV3LmdldEludDMyKHBvaW50T2Zmc2V0ICsgYXR0cmlidXRlT2Zmc2V0ICsgMCwgdHJ1ZSkgKiBzY2FsZVswXSArIG9mZnNldFswXSAtIG1pbi54O1xcXFxuICAgICAgICAgIHZhciB5ID0gdmlldy5nZXRJbnQzMihwb2ludE9mZnNldCArIGF0dHJpYnV0ZU9mZnNldCArIDQsIHRydWUpICogc2NhbGVbMV0gKyBvZmZzZXRbMV0gLSBtaW4ueTtcXFxcbiAgICAgICAgICB2YXIgeiA9IHZpZXcuZ2V0SW50MzIocG9pbnRPZmZzZXQgKyBhdHRyaWJ1dGVPZmZzZXQgKyA4LCB0cnVlKSAqIHNjYWxlWzJdICsgb2Zmc2V0WzJdIC0gbWluLno7XFxcXG4gICAgICAgICAgdmFyIGluZGV4ID0gdG9JbmRleCh4LCB5LCB6KTtcXFxcbiAgICAgICAgICB2YXIgY291bnQgPSBncmlkW2luZGV4XSsrO1xcXFxuICAgICAgICAgIGlmIChjb3VudCA9PT0gMCkge1xcXFxuICAgICAgICAgICAgbnVtT2NjdXBpZWRDZWxscysrO1xcXFxuICAgICAgICAgIH1cXFxcbiAgICAgICAgICBwb3NpdGlvbnNbMyAqIF9qICsgMF0gPSB4O1xcXFxuICAgICAgICAgIHBvc2l0aW9uc1szICogX2ogKyAxXSA9IHk7XFxcXG4gICAgICAgICAgcG9zaXRpb25zWzMgKiBfaiArIDJdID0gejtcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICBhdHRyaWJ1dGVCdWZmZXJzW19wb2ludEF0dHJpYnV0ZS5uYW1lXSA9IHtcXFxcbiAgICAgICAgICBidWZmZXI6IF9idWZmLFxcXFxuICAgICAgICAgIGF0dHJpYnV0ZTogX3BvaW50QXR0cmlidXRlXFxcXG4gICAgICAgIH07XFxcXG4gICAgICB9IGVsc2UgaWYgKFsnUkdCQScsICdyZ2JhJ10uaW5jbHVkZXMoX3BvaW50QXR0cmlidXRlLm5hbWUpKSB7XFxcXG4gICAgICAgIHZhciBfYnVmZjIgPSBuZXcgQXJyYXlCdWZmZXIobnVtUG9pbnRzICogNCk7XFxcXG4gICAgICAgIHZhciBjb2xvcnMgPSBuZXcgVWludDhBcnJheShfYnVmZjIpO1xcXFxuICAgICAgICBmb3IgKHZhciBfajIgPSAwOyBfajIgPCBudW1Qb2ludHM7IF9qMisrKSB7XFxcXG4gICAgICAgICAgdmFyIF9wb2ludE9mZnNldCA9IF9qMiAqIGJ5dGVzUGVyUG9pbnQ7XFxcXG4gICAgICAgICAgdmFyIHIgPSB2aWV3LmdldFVpbnQxNihfcG9pbnRPZmZzZXQgKyBhdHRyaWJ1dGVPZmZzZXQgKyAwLCB0cnVlKTtcXFxcbiAgICAgICAgICB2YXIgZyA9IHZpZXcuZ2V0VWludDE2KF9wb2ludE9mZnNldCArIGF0dHJpYnV0ZU9mZnNldCArIDIsIHRydWUpO1xcXFxuICAgICAgICAgIHZhciBiID0gdmlldy5nZXRVaW50MTYoX3BvaW50T2Zmc2V0ICsgYXR0cmlidXRlT2Zmc2V0ICsgNCwgdHJ1ZSk7XFxcXG4gICAgICAgICAgY29sb3JzWzQgKiBfajIgKyAwXSA9IHIgPiAyNTUgPyByIC8gMjU2IDogcjtcXFxcbiAgICAgICAgICBjb2xvcnNbNCAqIF9qMiArIDFdID0gZyA+IDI1NSA/IGcgLyAyNTYgOiBnO1xcXFxuICAgICAgICAgIGNvbG9yc1s0ICogX2oyICsgMl0gPSBiID4gMjU1ID8gYiAvIDI1NiA6IGI7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgYXR0cmlidXRlQnVmZmVyc1tfcG9pbnRBdHRyaWJ1dGUubmFtZV0gPSB7XFxcXG4gICAgICAgICAgYnVmZmVyOiBfYnVmZjIsXFxcXG4gICAgICAgICAgYXR0cmlidXRlOiBfcG9pbnRBdHRyaWJ1dGVcXFxcbiAgICAgICAgfTtcXFxcbiAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgIHZhciBfYnVmZjMgPSBuZXcgQXJyYXlCdWZmZXIobnVtUG9pbnRzICogNCk7XFxcXG4gICAgICAgIHZhciBfZiA9IG5ldyBGbG9hdDMyQXJyYXkoX2J1ZmYzKTtcXFxcbiAgICAgICAgdmFyIFR5cGVkQXJyYXkgPSB0eXBlZEFycmF5TWFwcGluZ1tfcG9pbnRBdHRyaWJ1dGUudHlwZS5uYW1lXTtcXFxcbiAgICAgICAgdmFyIHByZWNpc2VCdWZmZXIgPSBuZXcgVHlwZWRBcnJheShudW1Qb2ludHMpO1xcXFxuICAgICAgICB2YXIgX29mZnNldDIgPSAwLFxcXFxuICAgICAgICAgIF9zY2FsZTIgPSAxO1xcXFxuICAgICAgICB2YXIgZ2V0dGVyTWFwID0ge1xcXFxuICAgICAgICAgICdpbnQ4Jzogdmlldy5nZXRJbnQ4LFxcXFxuICAgICAgICAgICdpbnQxNic6IHZpZXcuZ2V0SW50MTYsXFxcXG4gICAgICAgICAgJ2ludDMyJzogdmlldy5nZXRJbnQzMixcXFxcbiAgICAgICAgICAvLyAnaW50NjQnOiAgdmlldy5nZXRJbnQ2NCxcXFxcbiAgICAgICAgICAndWludDgnOiB2aWV3LmdldFVpbnQ4LFxcXFxuICAgICAgICAgICd1aW50MTYnOiB2aWV3LmdldFVpbnQxNixcXFxcbiAgICAgICAgICAndWludDMyJzogdmlldy5nZXRVaW50MzIsXFxcXG4gICAgICAgICAgLy8gJ3VpbnQ2NCc6IHZpZXcuZ2V0VWludDY0LFxcXFxuICAgICAgICAgICdmbG9hdCc6IHZpZXcuZ2V0RmxvYXQzMixcXFxcbiAgICAgICAgICAnZG91YmxlJzogdmlldy5nZXRGbG9hdDY0XFxcXG4gICAgICAgIH07XFxcXG4gICAgICAgIHZhciBfZ2V0dGVyID0gZ2V0dGVyTWFwW19wb2ludEF0dHJpYnV0ZS50eXBlLm5hbWVdLmJpbmQodmlldyk7XFxcXG5cXFxcbiAgICAgICAgLy8gY29tcHV0ZSBvZmZzZXQgYW5kIHNjYWxlIHRvIHBhY2sgbGFyZ2VyIHR5cGVzIGludG8gMzIgYml0IGZsb2F0c1xcXFxuICAgICAgICBpZiAoX3BvaW50QXR0cmlidXRlLnR5cGUuc2l6ZSA+IDQpIHtcXFxcbiAgICAgICAgICB2YXIgX3BvaW50QXR0cmlidXRlJHJhbmdlID0gX3NsaWNlZFRvQXJyYXkoX3BvaW50QXR0cmlidXRlLnJhbmdlLCAyKSxcXFxcbiAgICAgICAgICAgIGFtaW4gPSBfcG9pbnRBdHRyaWJ1dGUkcmFuZ2VbMF0sXFxcXG4gICAgICAgICAgICBhbWF4ID0gX3BvaW50QXR0cmlidXRlJHJhbmdlWzFdO1xcXFxuICAgICAgICAgIF9vZmZzZXQyID0gYW1pbjtcXFxcbiAgICAgICAgICBfc2NhbGUyID0gMSAvIChhbWF4IC0gYW1pbik7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgZm9yICh2YXIgX2ozID0gMDsgX2ozIDwgbnVtUG9pbnRzOyBfajMrKykge1xcXFxuICAgICAgICAgIHZhciBfcG9pbnRPZmZzZXQyID0gX2ozICogYnl0ZXNQZXJQb2ludDtcXFxcbiAgICAgICAgICB2YXIgX3ZhbHVlID0gX2dldHRlcihfcG9pbnRPZmZzZXQyICsgYXR0cmlidXRlT2Zmc2V0LCB0cnVlKTtcXFxcbiAgICAgICAgICBfZltfajNdID0gKF92YWx1ZSAtIF9vZmZzZXQyKSAqIF9zY2FsZTI7XFxcXG4gICAgICAgICAgcHJlY2lzZUJ1ZmZlcltfajNdID0gX3ZhbHVlO1xcXFxuICAgICAgICB9XFxcXG4gICAgICAgIGF0dHJpYnV0ZUJ1ZmZlcnNbX3BvaW50QXR0cmlidXRlLm5hbWVdID0ge1xcXFxuICAgICAgICAgIGJ1ZmZlcjogX2J1ZmYzLFxcXFxuICAgICAgICAgIHByZWNpc2VCdWZmZXI6IHByZWNpc2VCdWZmZXIsXFxcXG4gICAgICAgICAgYXR0cmlidXRlOiBfcG9pbnRBdHRyaWJ1dGUsXFxcXG4gICAgICAgICAgb2Zmc2V0OiBfb2Zmc2V0MixcXFxcbiAgICAgICAgICBzY2FsZTogX3NjYWxlMlxcXFxuICAgICAgICB9O1xcXFxuICAgICAgfVxcXFxuICAgICAgYXR0cmlidXRlT2Zmc2V0ICs9IF9wb2ludEF0dHJpYnV0ZS5ieXRlU2l6ZTtcXFxcbiAgICB9XFxcXG4gIH0gY2F0Y2ggKGVycikge1xcXFxuICAgIF9pdGVyYXRvcjIuZShlcnIpO1xcXFxuICB9IGZpbmFsbHkge1xcXFxuICAgIF9pdGVyYXRvcjIuZigpO1xcXFxuICB9XFxcXG4gIHZhciBvY2N1cGFuY3kgPSBwYXJzZUludChudW1Qb2ludHMgLyBudW1PY2N1cGllZENlbGxzKTtcXFxcbiAge1xcXFxuICAgIC8vIGFkZCBpbmRpY2VzXFxcXG4gICAgdmFyIGJ1ZmYgPSBuZXcgQXJyYXlCdWZmZXIobnVtUG9pbnRzICogNCk7XFxcXG4gICAgdmFyIGluZGljZXMgPSBuZXcgVWludDMyQXJyYXkoYnVmZik7XFxcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Qb2ludHM7IGkrKykge1xcXFxuICAgICAgaW5kaWNlc1tpXSA9IGk7XFxcXG4gICAgfVxcXFxuICAgIGF0dHJpYnV0ZUJ1ZmZlcnNbJ0lORElDRVMnXSA9IHtcXFxcbiAgICAgIGJ1ZmZlcjogYnVmZixcXFxcbiAgICAgIGF0dHJpYnV0ZTogUG9pbnRBdHRyaWJ1dGUuSU5ESUNFU1xcXFxuICAgIH07XFxcXG4gIH1cXFxcbiAge1xcXFxuICAgIC8vIGhhbmRsZSBhdHRyaWJ1dGUgdmVjdG9yc1xcXFxuICAgIHZhciB2ZWN0b3JzID0gcG9pbnRBdHRyaWJ1dGVzLnZlY3RvcnM7XFxcXG4gICAgdmFyIF9pdGVyYXRvcjMgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih2ZWN0b3JzKSxcXFxcbiAgICAgIF9zdGVwMztcXFxcbiAgICB0cnkge1xcXFxuICAgICAgZm9yIChfaXRlcmF0b3IzLnMoKTsgIShfc3RlcDMgPSBfaXRlcmF0b3IzLm4oKSkuZG9uZTspIHtcXFxcbiAgICAgICAgdmFyIHZlY3RvciA9IF9zdGVwMy52YWx1ZTtcXFxcbiAgICAgICAgdmFyIF9uYW1lID0gdmVjdG9yLm5hbWUsXFxcXG4gICAgICAgICAgYXR0cmlidXRlcyA9IHZlY3Rvci5hdHRyaWJ1dGVzO1xcXFxuICAgICAgICB2YXIgbnVtVmVjdG9yRWxlbWVudHMgPSBhdHRyaWJ1dGVzLmxlbmd0aDtcXFxcbiAgICAgICAgdmFyIF9idWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIobnVtVmVjdG9yRWxlbWVudHMgKiBudW1Qb2ludHMgKiA0KTtcXFxcbiAgICAgICAgdmFyIGYzMiA9IG5ldyBGbG9hdDMyQXJyYXkoX2J1ZmZlcik7XFxcXG4gICAgICAgIHZhciBpRWxlbWVudCA9IDA7XFxcXG4gICAgICAgIHZhciBfaXRlcmF0b3I0ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoYXR0cmlidXRlcyksXFxcXG4gICAgICAgICAgX3N0ZXA0O1xcXFxuICAgICAgICB0cnkge1xcXFxuICAgICAgICAgIGZvciAoX2l0ZXJhdG9yNC5zKCk7ICEoX3N0ZXA0ID0gX2l0ZXJhdG9yNC5uKCkpLmRvbmU7KSB7XFxcXG4gICAgICAgICAgICB2YXIgc291cmNlTmFtZSA9IF9zdGVwNC52YWx1ZTtcXFxcbiAgICAgICAgICAgIHZhciBzb3VyY2VCdWZmZXIgPSBhdHRyaWJ1dGVCdWZmZXJzW3NvdXJjZU5hbWVdO1xcXFxuICAgICAgICAgICAgdmFyIF9vZmZzZXQgPSBzb3VyY2VCdWZmZXIub2Zmc2V0LFxcXFxuICAgICAgICAgICAgICBfc2NhbGUgPSBzb3VyY2VCdWZmZXIuc2NhbGU7XFxcXG4gICAgICAgICAgICB2YXIgX3ZpZXcgPSBuZXcgRGF0YVZpZXcoc291cmNlQnVmZmVyLmJ1ZmZlcik7XFxcXG4gICAgICAgICAgICB2YXIgZ2V0dGVyID0gX3ZpZXcuZ2V0RmxvYXQzMi5iaW5kKF92aWV3KTtcXFxcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbnVtUG9pbnRzOyBqKyspIHtcXFxcbiAgICAgICAgICAgICAgdmFyIHZhbHVlID0gZ2V0dGVyKGogKiA0LCB0cnVlKTtcXFxcbiAgICAgICAgICAgICAgZjMyW2ogKiBudW1WZWN0b3JFbGVtZW50cyArIGlFbGVtZW50XSA9IHZhbHVlIC8gX3NjYWxlICsgX29mZnNldDtcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIGlFbGVtZW50Kys7XFxcXG4gICAgICAgICAgfVxcXFxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcXFxcbiAgICAgICAgICBfaXRlcmF0b3I0LmUoZXJyKTtcXFxcbiAgICAgICAgfSBmaW5hbGx5IHtcXFxcbiAgICAgICAgICBfaXRlcmF0b3I0LmYoKTtcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICB2YXIgdmVjQXR0cmlidXRlID0gbmV3IFBvaW50QXR0cmlidXRlKF9uYW1lLCBQb2ludEF0dHJpYnV0ZVR5cGVzLkRBVEFfVFlQRV9GTE9BVCwgMyk7XFxcXG4gICAgICAgIGF0dHJpYnV0ZUJ1ZmZlcnNbX25hbWVdID0ge1xcXFxuICAgICAgICAgIGJ1ZmZlcjogX2J1ZmZlcixcXFxcbiAgICAgICAgICBhdHRyaWJ1dGU6IHZlY0F0dHJpYnV0ZVxcXFxuICAgICAgICB9O1xcXFxuICAgICAgfVxcXFxuICAgIH0gY2F0Y2ggKGVycikge1xcXFxuICAgICAgX2l0ZXJhdG9yMy5lKGVycik7XFxcXG4gICAgfSBmaW5hbGx5IHtcXFxcbiAgICAgIF9pdGVyYXRvcjMuZigpO1xcXFxuICAgIH1cXFxcbiAgfVxcXFxuICB2YXIgbWVzc2FnZSA9IHtcXFxcbiAgICBidWZmZXI6IGJ1ZmZlcixcXFxcbiAgICBhdHRyaWJ1dGVCdWZmZXJzOiBhdHRyaWJ1dGVCdWZmZXJzLFxcXFxuICAgIGRlbnNpdHk6IG9jY3VwYW5jeVxcXFxuICB9O1xcXFxuICB2YXIgdHJhbnNmZXJhYmxlcyA9IFtdO1xcXFxuICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBtZXNzYWdlLmF0dHJpYnV0ZUJ1ZmZlcnMpIHtcXFxcbiAgICB0cmFuc2ZlcmFibGVzLnB1c2gobWVzc2FnZS5hdHRyaWJ1dGVCdWZmZXJzW3Byb3BlcnR5XS5idWZmZXIpO1xcXFxuICB9XFxcXG4gIHRyYW5zZmVyYWJsZXMucHVzaChidWZmZXIpO1xcXFxuICBwb3N0TWVzc2FnZShtZXNzYWdlLCB0cmFuc2ZlcmFibGVzKTtcXFxcbn07Ly8jIHNvdXJjZVVSTD1bbW9kdWxlXVxcXFxuXFxcIil9fSxfX3dlYnBhY2tfZXhwb3J0c19fPXt9O19fd2VicGFja19tb2R1bGVzX19bMjU2XSgpfSkoKTtcIiwgXCJXb3JrZXJcIiwgdW5kZWZpbmVkLCB1bmRlZmluZWQpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///300\n")},91:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ Worker_fn)\n/* harmony export */ });\n/* harmony import */ var _node_modules_worker_loader_dist_runtime_inline_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(512);\n/* harmony import */ var _node_modules_worker_loader_dist_runtime_inline_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_worker_loader_dist_runtime_inline_js__WEBPACK_IMPORTED_MODULE_0__);\n\n\n\nfunction Worker_fn() {\n  return _node_modules_worker_loader_dist_runtime_inline_js__WEBPACK_IMPORTED_MODULE_0___default()("(()=>{\\"use strict\\";var __webpack_modules__={717:()=>{eval(\'\\\\n;// CONCATENATED MODULE: ./src/point-attributes.ts\\\\n// -------------------------------------------------------------------------------------------------\\\\n// Converted to Typescript and adapted from https://github.com/potree/potree\\\\n// -------------------------------------------------------------------------------------------------\\\\nvar PointAttributeName;\\\\n(function (PointAttributeName) {\\\\n    PointAttributeName[PointAttributeName[\\"POSITION_CARTESIAN\\"] = 0] = \\"POSITION_CARTESIAN\\";\\\\n    PointAttributeName[PointAttributeName[\\"COLOR_PACKED\\"] = 1] = \\"COLOR_PACKED\\";\\\\n    PointAttributeName[PointAttributeName[\\"COLOR_FLOATS_1\\"] = 2] = \\"COLOR_FLOATS_1\\";\\\\n    PointAttributeName[PointAttributeName[\\"COLOR_FLOATS_255\\"] = 3] = \\"COLOR_FLOATS_255\\";\\\\n    PointAttributeName[PointAttributeName[\\"NORMAL_FLOATS\\"] = 4] = \\"NORMAL_FLOATS\\";\\\\n    PointAttributeName[PointAttributeName[\\"FILLER\\"] = 5] = \\"FILLER\\";\\\\n    PointAttributeName[PointAttributeName[\\"INTENSITY\\"] = 6] = \\"INTENSITY\\";\\\\n    PointAttributeName[PointAttributeName[\\"CLASSIFICATION\\"] = 7] = \\"CLASSIFICATION\\";\\\\n    PointAttributeName[PointAttributeName[\\"NORMAL_SPHEREMAPPED\\"] = 8] = \\"NORMAL_SPHEREMAPPED\\";\\\\n    PointAttributeName[PointAttributeName[\\"NORMAL_OCT16\\"] = 9] = \\"NORMAL_OCT16\\";\\\\n    PointAttributeName[PointAttributeName[\\"NORMAL\\"] = 10] = \\"NORMAL\\";\\\\n})(PointAttributeName || (PointAttributeName = {}));\\\\nconst POINT_ATTRIBUTE_TYPES = {\\\\n    DATA_TYPE_DOUBLE: { ordinal: 0, size: 8 },\\\\n    DATA_TYPE_FLOAT: { ordinal: 1, size: 4 },\\\\n    DATA_TYPE_INT8: { ordinal: 2, size: 1 },\\\\n    DATA_TYPE_UINT8: { ordinal: 3, size: 1 },\\\\n    DATA_TYPE_INT16: { ordinal: 4, size: 2 },\\\\n    DATA_TYPE_UINT16: { ordinal: 5, size: 2 },\\\\n    DATA_TYPE_INT32: { ordinal: 6, size: 4 },\\\\n    DATA_TYPE_UINT32: { ordinal: 7, size: 4 },\\\\n    DATA_TYPE_INT64: { ordinal: 8, size: 8 },\\\\n    DATA_TYPE_UINT64: { ordinal: 9, size: 8 },\\\\n};\\\\nfunction makePointAttribute(name, type, numElements) {\\\\n    return {\\\\n        name,\\\\n        type,\\\\n        numElements,\\\\n        byteSize: numElements * type.size,\\\\n    };\\\\n}\\\\nconst RGBA_PACKED = makePointAttribute(PointAttributeName.COLOR_PACKED, POINT_ATTRIBUTE_TYPES.DATA_TYPE_INT8, 4);\\\\nconst POINT_ATTRIBUTES = {\\\\n    POSITION_CARTESIAN: makePointAttribute(PointAttributeName.POSITION_CARTESIAN, POINT_ATTRIBUTE_TYPES.DATA_TYPE_FLOAT, 3),\\\\n    RGBA_PACKED,\\\\n    COLOR_PACKED: RGBA_PACKED,\\\\n    RGB_PACKED: makePointAttribute(PointAttributeName.COLOR_PACKED, POINT_ATTRIBUTE_TYPES.DATA_TYPE_INT8, 3),\\\\n    NORMAL_FLOATS: makePointAttribute(PointAttributeName.NORMAL_FLOATS, POINT_ATTRIBUTE_TYPES.DATA_TYPE_FLOAT, 3),\\\\n    FILLER_1B: makePointAttribute(PointAttributeName.FILLER, POINT_ATTRIBUTE_TYPES.DATA_TYPE_UINT8, 1),\\\\n    INTENSITY: makePointAttribute(PointAttributeName.INTENSITY, POINT_ATTRIBUTE_TYPES.DATA_TYPE_UINT16, 1),\\\\n    CLASSIFICATION: makePointAttribute(PointAttributeName.CLASSIFICATION, POINT_ATTRIBUTE_TYPES.DATA_TYPE_UINT8, 1),\\\\n    NORMAL_SPHEREMAPPED: makePointAttribute(PointAttributeName.NORMAL_SPHEREMAPPED, POINT_ATTRIBUTE_TYPES.DATA_TYPE_UINT8, 2),\\\\n    NORMAL_OCT16: makePointAttribute(PointAttributeName.NORMAL_OCT16, POINT_ATTRIBUTE_TYPES.DATA_TYPE_UINT8, 2),\\\\n    NORMAL: makePointAttribute(PointAttributeName.NORMAL, POINT_ATTRIBUTE_TYPES.DATA_TYPE_FLOAT, 3),\\\\n};\\\\nclass PointAttributes {\\\\n    constructor(pointAttributeNames = []) {\\\\n        this.attributes = [];\\\\n        this.byteSize = 0;\\\\n        this.size = 0;\\\\n        for (let i = 0; i < pointAttributeNames.length; i++) {\\\\n            const pointAttributeName = pointAttributeNames[i];\\\\n            const pointAttribute = POINT_ATTRIBUTES[pointAttributeName];\\\\n            this.attributes.push(pointAttribute);\\\\n            this.byteSize += pointAttribute.byteSize;\\\\n            this.size++;\\\\n        }\\\\n    }\\\\n    add(pointAttribute) {\\\\n        this.attributes.push(pointAttribute);\\\\n        this.byteSize += pointAttribute.byteSize;\\\\n        this.size++;\\\\n    }\\\\n    hasColors() {\\\\n        return this.attributes.find(isColorAttribute) !== undefined;\\\\n    }\\\\n    hasNormals() {\\\\n        return this.attributes.find(isNormalAttribute) !== undefined;\\\\n    }\\\\n}\\\\nfunction isColorAttribute({ name }) {\\\\n    return name === PointAttributeName.COLOR_PACKED;\\\\n}\\\\nfunction isNormalAttribute({ name }) {\\\\n    return (name === PointAttributeName.NORMAL_SPHEREMAPPED ||\\\\n        name === PointAttributeName.NORMAL_FLOATS ||\\\\n        name === PointAttributeName.NORMAL ||\\\\n        name === PointAttributeName.NORMAL_OCT16);\\\\n}\\\\n\\\\n;// CONCATENATED MODULE: ./src/version.ts\\\\nclass Version {\\\\n    constructor(version) {\\\\n        this.versionMinor = 0;\\\\n        this.version = version;\\\\n        const vmLength = version.indexOf(\\\\\'.\\\\\') === -1 ? version.length : version.indexOf(\\\\\'.\\\\\');\\\\n        this.versionMajor = parseInt(version.substr(0, vmLength), 10);\\\\n        this.versionMinor = parseInt(version.substr(vmLength + 1), 10);\\\\n        if (isNaN(this.versionMinor)) {\\\\n            this.versionMinor = 0;\\\\n        }\\\\n    }\\\\n    newerThan(version) {\\\\n        const v = new Version(version);\\\\n        if (this.versionMajor > v.versionMajor) {\\\\n            return true;\\\\n        }\\\\n        else if (this.versionMajor === v.versionMajor && this.versionMinor > v.versionMinor) {\\\\n            return true;\\\\n        }\\\\n        else {\\\\n            return false;\\\\n        }\\\\n    }\\\\n    equalOrHigher(version) {\\\\n        const v = new Version(version);\\\\n        if (this.versionMajor > v.versionMajor) {\\\\n            return true;\\\\n        }\\\\n        else if (this.versionMajor === v.versionMajor && this.versionMinor >= v.versionMinor) {\\\\n            return true;\\\\n        }\\\\n        else {\\\\n            return false;\\\\n        }\\\\n    }\\\\n    upTo(version) {\\\\n        return !this.newerThan(version);\\\\n    }\\\\n}\\\\n\\\\n;// CONCATENATED MODULE: ./src/workers/custom-array-view.ts\\\\n/**\\\\n * Adapted from Potree.js http://potree.org\\\\n * Potree License: https://github.com/potree/potree/blob/1.5/LICENSE\\\\n */\\\\n// http://jsperf.com/uint8array-vs-dataview3/3\\\\n// tslint:disable:no-bitwise\\\\nclass CustomArrayView {\\\\n    constructor(buffer) {\\\\n        this.tmp = new ArrayBuffer(4);\\\\n        this.tmpf = new Float32Array(this.tmp);\\\\n        this.tmpu8 = new Uint8Array(this.tmp);\\\\n        this.u8 = new Uint8Array(buffer);\\\\n    }\\\\n    getUint32(i) {\\\\n        return (this.u8[i + 3] << 24) | (this.u8[i + 2] << 16) | (this.u8[i + 1] << 8) | this.u8[i];\\\\n    }\\\\n    getUint16(i) {\\\\n        return (this.u8[i + 1] << 8) | this.u8[i];\\\\n    }\\\\n    getFloat32(i) {\\\\n        const tmpu8 = this.tmpu8;\\\\n        const u8 = this.u8;\\\\n        const tmpf = this.tmpf;\\\\n        tmpu8[0] = u8[i + 0];\\\\n        tmpu8[1] = u8[i + 1];\\\\n        tmpu8[2] = u8[i + 2];\\\\n        tmpu8[3] = u8[i + 3];\\\\n        return tmpf[0];\\\\n    }\\\\n    getUint8(i) {\\\\n        return this.u8[i];\\\\n    }\\\\n}\\\\n// tslint:enable:no-bitwise\\\\n\\\\n;// CONCATENATED MODULE: ./src/workers/binary-decoder-worker-internal.ts\\\\n/**\\\\n * Adapted from Potree.js http://potree.org\\\\n * Potree License: https://github.com/potree/potree/blob/1.5/LICENSE\\\\n */\\\\n\\\\n\\\\n\\\\n// IE11 does not have Math.sign(), this has been adapted from CoreJS es6.math.sign.js for TypeScript\\\\nconst mathSign = Math.sign ||\\\\n    function (x) {\\\\n        // tslint:disable-next-line:triple-equals\\\\n        return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;\\\\n    };\\\\nfunction handleMessage(event) {\\\\n    const buffer = event.data.buffer;\\\\n    const pointAttributes = event.data.pointAttributes;\\\\n    const ctx = {\\\\n        attributeBuffers: {},\\\\n        currentOffset: 0,\\\\n        data: new CustomArrayView(buffer),\\\\n        mean: [0, 0, 0],\\\\n        nodeOffset: event.data.offset,\\\\n        numPoints: event.data.buffer.byteLength / pointAttributes.byteSize,\\\\n        pointAttributes,\\\\n        scale: event.data.scale,\\\\n        tightBoxMax: [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY],\\\\n        tightBoxMin: [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY],\\\\n        transferables: [],\\\\n        version: new Version(event.data.version),\\\\n    };\\\\n    for (const pointAttribute of ctx.pointAttributes.attributes) {\\\\n        decodeAndAddAttribute(pointAttribute, ctx);\\\\n        ctx.currentOffset += pointAttribute.byteSize;\\\\n    }\\\\n    const indices = new ArrayBuffer(ctx.numPoints * 4);\\\\n    const iIndices = new Uint32Array(indices);\\\\n    for (let i = 0; i < ctx.numPoints; i++) {\\\\n        iIndices[i] = i;\\\\n    }\\\\n    if (!ctx.attributeBuffers[PointAttributeName.CLASSIFICATION]) {\\\\n        addEmptyClassificationBuffer(ctx);\\\\n    }\\\\n    const message = {\\\\n        buffer: buffer,\\\\n        mean: ctx.mean,\\\\n        attributeBuffers: ctx.attributeBuffers,\\\\n        tightBoundingBox: { min: ctx.tightBoxMin, max: ctx.tightBoxMax },\\\\n        indices,\\\\n    };\\\\n    postMessage(message, ctx.transferables);\\\\n}\\\\nfunction addEmptyClassificationBuffer(ctx) {\\\\n    const buffer = new ArrayBuffer(ctx.numPoints * 4);\\\\n    const classifications = new Float32Array(buffer);\\\\n    for (let i = 0; i < ctx.numPoints; i++) {\\\\n        classifications[i] = 0;\\\\n    }\\\\n    ctx.attributeBuffers[PointAttributeName.CLASSIFICATION] = {\\\\n        buffer,\\\\n        attribute: POINT_ATTRIBUTES.CLASSIFICATION,\\\\n    };\\\\n}\\\\nfunction decodeAndAddAttribute(attribute, ctx) {\\\\n    const decodedAttribute = decodePointAttribute(attribute, ctx);\\\\n    if (decodedAttribute === undefined) {\\\\n        return;\\\\n    }\\\\n    ctx.attributeBuffers[decodedAttribute.attribute.name] = decodedAttribute;\\\\n    ctx.transferables.push(decodedAttribute.buffer);\\\\n}\\\\nfunction decodePointAttribute(attribute, ctx) {\\\\n    switch (attribute.name) {\\\\n        case PointAttributeName.POSITION_CARTESIAN:\\\\n            return decodePositionCartesian(attribute, ctx);\\\\n        case PointAttributeName.COLOR_PACKED:\\\\n            return decodeColor(attribute, ctx);\\\\n        case PointAttributeName.INTENSITY:\\\\n            return decodeIntensity(attribute, ctx);\\\\n        case PointAttributeName.CLASSIFICATION:\\\\n            return decodeClassification(attribute, ctx);\\\\n        case PointAttributeName.NORMAL_SPHEREMAPPED:\\\\n            return decodeNormalSphereMapped(attribute, ctx);\\\\n        case PointAttributeName.NORMAL_OCT16:\\\\n            return decodeNormalOct16(attribute, ctx);\\\\n        case PointAttributeName.NORMAL:\\\\n            return decodeNormal(attribute, ctx);\\\\n        default:\\\\n            return undefined;\\\\n    }\\\\n}\\\\nfunction decodePositionCartesian(attribute, ctx) {\\\\n    const buffer = new ArrayBuffer(ctx.numPoints * 4 * 3);\\\\n    const positions = new Float32Array(buffer);\\\\n    for (let i = 0; i < ctx.numPoints; i++) {\\\\n        let x;\\\\n        let y;\\\\n        let z;\\\\n        if (ctx.version.newerThan(\\\\\'1.3\\\\\')) {\\\\n            x = ctx.data.getUint32(ctx.currentOffset + i * ctx.pointAttributes.byteSize + 0) * ctx.scale;\\\\n            y = ctx.data.getUint32(ctx.currentOffset + i * ctx.pointAttributes.byteSize + 4) * ctx.scale;\\\\n            z = ctx.data.getUint32(ctx.currentOffset + i * ctx.pointAttributes.byteSize + 8) * ctx.scale;\\\\n        }\\\\n        else {\\\\n            x = ctx.data.getFloat32(i * ctx.pointAttributes.byteSize + 0) + ctx.nodeOffset[0];\\\\n            y = ctx.data.getFloat32(i * ctx.pointAttributes.byteSize + 4) + ctx.nodeOffset[1];\\\\n            z = ctx.data.getFloat32(i * ctx.pointAttributes.byteSize + 8) + ctx.nodeOffset[2];\\\\n        }\\\\n        positions[3 * i + 0] = x;\\\\n        positions[3 * i + 1] = y;\\\\n        positions[3 * i + 2] = z;\\\\n        ctx.mean[0] += x / ctx.numPoints;\\\\n        ctx.mean[1] += y / ctx.numPoints;\\\\n        ctx.mean[2] += z / ctx.numPoints;\\\\n        ctx.tightBoxMin[0] = Math.min(ctx.tightBoxMin[0], x);\\\\n        ctx.tightBoxMin[1] = Math.min(ctx.tightBoxMin[1], y);\\\\n        ctx.tightBoxMin[2] = Math.min(ctx.tightBoxMin[2], z);\\\\n        ctx.tightBoxMax[0] = Math.max(ctx.tightBoxMax[0], x);\\\\n        ctx.tightBoxMax[1] = Math.max(ctx.tightBoxMax[1], y);\\\\n        ctx.tightBoxMax[2] = Math.max(ctx.tightBoxMax[2], z);\\\\n    }\\\\n    return { buffer, attribute };\\\\n}\\\\nfunction decodeColor(attribute, ctx) {\\\\n    const buffer = new ArrayBuffer(ctx.numPoints * 3);\\\\n    const colors = new Uint8Array(buffer);\\\\n    for (let i = 0; i < ctx.numPoints; i++) {\\\\n        colors[3 * i + 0] = ctx.data.getUint8(ctx.currentOffset + i * ctx.pointAttributes.byteSize + 0);\\\\n        colors[3 * i + 1] = ctx.data.getUint8(ctx.currentOffset + i * ctx.pointAttributes.byteSize + 1);\\\\n        colors[3 * i + 2] = ctx.data.getUint8(ctx.currentOffset + i * ctx.pointAttributes.byteSize + 2);\\\\n    }\\\\n    return { buffer, attribute };\\\\n}\\\\nfunction decodeIntensity(attribute, ctx) {\\\\n    const buffer = new ArrayBuffer(ctx.numPoints * 4);\\\\n    const intensities = new Float32Array(buffer);\\\\n    for (let i = 0; i < ctx.numPoints; i++) {\\\\n        intensities[i] = ctx.data.getUint16(ctx.currentOffset + i * ctx.pointAttributes.byteSize);\\\\n    }\\\\n    return { buffer, attribute };\\\\n}\\\\nfunction decodeClassification(attribute, ctx) {\\\\n    const buffer = new ArrayBuffer(ctx.numPoints);\\\\n    const classifications = new Uint8Array(buffer);\\\\n    for (let j = 0; j < ctx.numPoints; j++) {\\\\n        classifications[j] = ctx.data.getUint8(ctx.currentOffset + j * ctx.pointAttributes.byteSize);\\\\n    }\\\\n    return { buffer, attribute };\\\\n}\\\\nfunction decodeNormalSphereMapped(attribute, ctx) {\\\\n    const buffer = new ArrayBuffer(ctx.numPoints * 4 * 3);\\\\n    const normals = new Float32Array(buffer);\\\\n    for (let j = 0; j < ctx.numPoints; j++) {\\\\n        const bx = ctx.data.getUint8(ctx.currentOffset + j * ctx.pointAttributes.byteSize + 0);\\\\n        const by = ctx.data.getUint8(ctx.currentOffset + j * ctx.pointAttributes.byteSize + 1);\\\\n        const ex = bx / 255;\\\\n        const ey = by / 255;\\\\n        let nx = ex * 2 - 1;\\\\n        let ny = ey * 2 - 1;\\\\n        let nz = 1;\\\\n        const nw = -1;\\\\n        const l = nx * -nx + ny * -ny + nz * -nw;\\\\n        nz = l;\\\\n        nx = nx * Math.sqrt(l);\\\\n        ny = ny * Math.sqrt(l);\\\\n        nx = nx * 2;\\\\n        ny = ny * 2;\\\\n        nz = nz * 2 - 1;\\\\n        normals[3 * j + 0] = nx;\\\\n        normals[3 * j + 1] = ny;\\\\n        normals[3 * j + 2] = nz;\\\\n    }\\\\n    return { buffer, attribute };\\\\n}\\\\nfunction decodeNormalOct16(attribute, ctx) {\\\\n    const buff = new ArrayBuffer(ctx.numPoints * 4 * 3);\\\\n    const normals = new Float32Array(buff);\\\\n    for (let j = 0; j < ctx.numPoints; j++) {\\\\n        const bx = ctx.data.getUint8(ctx.currentOffset + j * ctx.pointAttributes.byteSize + 0);\\\\n        const by = ctx.data.getUint8(ctx.currentOffset + j * ctx.pointAttributes.byteSize + 1);\\\\n        const u = (bx / 255) * 2 - 1;\\\\n        const v = (by / 255) * 2 - 1;\\\\n        let z = 1 - Math.abs(u) - Math.abs(v);\\\\n        let x = 0;\\\\n        let y = 0;\\\\n        if (z >= 0) {\\\\n            x = u;\\\\n            y = v;\\\\n        }\\\\n        else {\\\\n            x = -(v / mathSign(v) - 1) / mathSign(u);\\\\n            y = -(u / mathSign(u) - 1) / mathSign(v);\\\\n        }\\\\n        const length = Math.sqrt(x * x + y * y + z * z);\\\\n        x = x / length;\\\\n        y = y / length;\\\\n        z = z / length;\\\\n        normals[3 * j + 0] = x;\\\\n        normals[3 * j + 1] = y;\\\\n        normals[3 * j + 2] = z;\\\\n    }\\\\n    return { buffer: buff, attribute };\\\\n}\\\\nfunction decodeNormal(attribute, ctx) {\\\\n    const buffer = new ArrayBuffer(ctx.numPoints * 4 * 3);\\\\n    const normals = new Float32Array(buffer);\\\\n    for (let j = 0; j < ctx.numPoints; j++) {\\\\n        const x = ctx.data.getFloat32(ctx.currentOffset + j * ctx.pointAttributes.byteSize + 0);\\\\n        const y = ctx.data.getFloat32(ctx.currentOffset + j * ctx.pointAttributes.byteSize + 4);\\\\n        const z = ctx.data.getFloat32(ctx.currentOffset + j * ctx.pointAttributes.byteSize + 8);\\\\n        normals[3 * j + 0] = x;\\\\n        normals[3 * j + 1] = y;\\\\n        normals[3 * j + 2] = z;\\\\n    }\\\\n    return { buffer, attribute };\\\\n}\\\\n\\\\n;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./src/workers/binary-decoder.worker.js\\\\n\\\\n\\\\n/*eslint-disable */\\\\nonmessage = handleMessage;//# sourceURL=[module]\\\\n\')}},__webpack_exports__={};__webpack_modules__[717]()})();", "Worker", undefined, undefined);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wb3RyZWUvLi9zcmMvd29ya2Vycy9iaW5hcnktZGVjb2Rlci53b3JrZXIuanM/YzYyNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcbmltcG9ydCB3b3JrZXIgZnJvbSBcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL3dvcmtlci1sb2FkZXIvZGlzdC9ydW50aW1lL2lubGluZS5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBXb3JrZXJfZm4oKSB7XG4gIHJldHVybiB3b3JrZXIoXCIoKCk9PntcXFwidXNlIHN0cmljdFxcXCI7dmFyIF9fd2VicGFja19tb2R1bGVzX189ezcxNzooKT0+e2V2YWwoJ1xcXFxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3BvaW50LWF0dHJpYnV0ZXMudHNcXFxcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXFxcbi8vIENvbnZlcnRlZCB0byBUeXBlc2NyaXB0IGFuZCBhZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL3BvdHJlZS9wb3RyZWVcXFxcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXFxcbnZhciBQb2ludEF0dHJpYnV0ZU5hbWU7XFxcXG4oZnVuY3Rpb24gKFBvaW50QXR0cmlidXRlTmFtZSkge1xcXFxuICAgIFBvaW50QXR0cmlidXRlTmFtZVtQb2ludEF0dHJpYnV0ZU5hbWVbXFxcIlBPU0lUSU9OX0NBUlRFU0lBTlxcXCJdID0gMF0gPSBcXFwiUE9TSVRJT05fQ0FSVEVTSUFOXFxcIjtcXFxcbiAgICBQb2ludEF0dHJpYnV0ZU5hbWVbUG9pbnRBdHRyaWJ1dGVOYW1lW1xcXCJDT0xPUl9QQUNLRURcXFwiXSA9IDFdID0gXFxcIkNPTE9SX1BBQ0tFRFxcXCI7XFxcXG4gICAgUG9pbnRBdHRyaWJ1dGVOYW1lW1BvaW50QXR0cmlidXRlTmFtZVtcXFwiQ09MT1JfRkxPQVRTXzFcXFwiXSA9IDJdID0gXFxcIkNPTE9SX0ZMT0FUU18xXFxcIjtcXFxcbiAgICBQb2ludEF0dHJpYnV0ZU5hbWVbUG9pbnRBdHRyaWJ1dGVOYW1lW1xcXCJDT0xPUl9GTE9BVFNfMjU1XFxcIl0gPSAzXSA9IFxcXCJDT0xPUl9GTE9BVFNfMjU1XFxcIjtcXFxcbiAgICBQb2ludEF0dHJpYnV0ZU5hbWVbUG9pbnRBdHRyaWJ1dGVOYW1lW1xcXCJOT1JNQUxfRkxPQVRTXFxcIl0gPSA0XSA9IFxcXCJOT1JNQUxfRkxPQVRTXFxcIjtcXFxcbiAgICBQb2ludEF0dHJpYnV0ZU5hbWVbUG9pbnRBdHRyaWJ1dGVOYW1lW1xcXCJGSUxMRVJcXFwiXSA9IDVdID0gXFxcIkZJTExFUlxcXCI7XFxcXG4gICAgUG9pbnRBdHRyaWJ1dGVOYW1lW1BvaW50QXR0cmlidXRlTmFtZVtcXFwiSU5URU5TSVRZXFxcIl0gPSA2XSA9IFxcXCJJTlRFTlNJVFlcXFwiO1xcXFxuICAgIFBvaW50QXR0cmlidXRlTmFtZVtQb2ludEF0dHJpYnV0ZU5hbWVbXFxcIkNMQVNTSUZJQ0FUSU9OXFxcIl0gPSA3XSA9IFxcXCJDTEFTU0lGSUNBVElPTlxcXCI7XFxcXG4gICAgUG9pbnRBdHRyaWJ1dGVOYW1lW1BvaW50QXR0cmlidXRlTmFtZVtcXFwiTk9STUFMX1NQSEVSRU1BUFBFRFxcXCJdID0gOF0gPSBcXFwiTk9STUFMX1NQSEVSRU1BUFBFRFxcXCI7XFxcXG4gICAgUG9pbnRBdHRyaWJ1dGVOYW1lW1BvaW50QXR0cmlidXRlTmFtZVtcXFwiTk9STUFMX09DVDE2XFxcIl0gPSA5XSA9IFxcXCJOT1JNQUxfT0NUMTZcXFwiO1xcXFxuICAgIFBvaW50QXR0cmlidXRlTmFtZVtQb2ludEF0dHJpYnV0ZU5hbWVbXFxcIk5PUk1BTFxcXCJdID0gMTBdID0gXFxcIk5PUk1BTFxcXCI7XFxcXG59KShQb2ludEF0dHJpYnV0ZU5hbWUgfHwgKFBvaW50QXR0cmlidXRlTmFtZSA9IHt9KSk7XFxcXG5jb25zdCBQT0lOVF9BVFRSSUJVVEVfVFlQRVMgPSB7XFxcXG4gICAgREFUQV9UWVBFX0RPVUJMRTogeyBvcmRpbmFsOiAwLCBzaXplOiA4IH0sXFxcXG4gICAgREFUQV9UWVBFX0ZMT0FUOiB7IG9yZGluYWw6IDEsIHNpemU6IDQgfSxcXFxcbiAgICBEQVRBX1RZUEVfSU5UODogeyBvcmRpbmFsOiAyLCBzaXplOiAxIH0sXFxcXG4gICAgREFUQV9UWVBFX1VJTlQ4OiB7IG9yZGluYWw6IDMsIHNpemU6IDEgfSxcXFxcbiAgICBEQVRBX1RZUEVfSU5UMTY6IHsgb3JkaW5hbDogNCwgc2l6ZTogMiB9LFxcXFxuICAgIERBVEFfVFlQRV9VSU5UMTY6IHsgb3JkaW5hbDogNSwgc2l6ZTogMiB9LFxcXFxuICAgIERBVEFfVFlQRV9JTlQzMjogeyBvcmRpbmFsOiA2LCBzaXplOiA0IH0sXFxcXG4gICAgREFUQV9UWVBFX1VJTlQzMjogeyBvcmRpbmFsOiA3LCBzaXplOiA0IH0sXFxcXG4gICAgREFUQV9UWVBFX0lOVDY0OiB7IG9yZGluYWw6IDgsIHNpemU6IDggfSxcXFxcbiAgICBEQVRBX1RZUEVfVUlOVDY0OiB7IG9yZGluYWw6IDksIHNpemU6IDggfSxcXFxcbn07XFxcXG5mdW5jdGlvbiBtYWtlUG9pbnRBdHRyaWJ1dGUobmFtZSwgdHlwZSwgbnVtRWxlbWVudHMpIHtcXFxcbiAgICByZXR1cm4ge1xcXFxuICAgICAgICBuYW1lLFxcXFxuICAgICAgICB0eXBlLFxcXFxuICAgICAgICBudW1FbGVtZW50cyxcXFxcbiAgICAgICAgYnl0ZVNpemU6IG51bUVsZW1lbnRzICogdHlwZS5zaXplLFxcXFxuICAgIH07XFxcXG59XFxcXG5jb25zdCBSR0JBX1BBQ0tFRCA9IG1ha2VQb2ludEF0dHJpYnV0ZShQb2ludEF0dHJpYnV0ZU5hbWUuQ09MT1JfUEFDS0VELCBQT0lOVF9BVFRSSUJVVEVfVFlQRVMuREFUQV9UWVBFX0lOVDgsIDQpO1xcXFxuY29uc3QgUE9JTlRfQVRUUklCVVRFUyA9IHtcXFxcbiAgICBQT1NJVElPTl9DQVJURVNJQU46IG1ha2VQb2ludEF0dHJpYnV0ZShQb2ludEF0dHJpYnV0ZU5hbWUuUE9TSVRJT05fQ0FSVEVTSUFOLCBQT0lOVF9BVFRSSUJVVEVfVFlQRVMuREFUQV9UWVBFX0ZMT0FULCAzKSxcXFxcbiAgICBSR0JBX1BBQ0tFRCxcXFxcbiAgICBDT0xPUl9QQUNLRUQ6IFJHQkFfUEFDS0VELFxcXFxuICAgIFJHQl9QQUNLRUQ6IG1ha2VQb2ludEF0dHJpYnV0ZShQb2ludEF0dHJpYnV0ZU5hbWUuQ09MT1JfUEFDS0VELCBQT0lOVF9BVFRSSUJVVEVfVFlQRVMuREFUQV9UWVBFX0lOVDgsIDMpLFxcXFxuICAgIE5PUk1BTF9GTE9BVFM6IG1ha2VQb2ludEF0dHJpYnV0ZShQb2ludEF0dHJpYnV0ZU5hbWUuTk9STUFMX0ZMT0FUUywgUE9JTlRfQVRUUklCVVRFX1RZUEVTLkRBVEFfVFlQRV9GTE9BVCwgMyksXFxcXG4gICAgRklMTEVSXzFCOiBtYWtlUG9pbnRBdHRyaWJ1dGUoUG9pbnRBdHRyaWJ1dGVOYW1lLkZJTExFUiwgUE9JTlRfQVRUUklCVVRFX1RZUEVTLkRBVEFfVFlQRV9VSU5UOCwgMSksXFxcXG4gICAgSU5URU5TSVRZOiBtYWtlUG9pbnRBdHRyaWJ1dGUoUG9pbnRBdHRyaWJ1dGVOYW1lLklOVEVOU0lUWSwgUE9JTlRfQVRUUklCVVRFX1RZUEVTLkRBVEFfVFlQRV9VSU5UMTYsIDEpLFxcXFxuICAgIENMQVNTSUZJQ0FUSU9OOiBtYWtlUG9pbnRBdHRyaWJ1dGUoUG9pbnRBdHRyaWJ1dGVOYW1lLkNMQVNTSUZJQ0FUSU9OLCBQT0lOVF9BVFRSSUJVVEVfVFlQRVMuREFUQV9UWVBFX1VJTlQ4LCAxKSxcXFxcbiAgICBOT1JNQUxfU1BIRVJFTUFQUEVEOiBtYWtlUG9pbnRBdHRyaWJ1dGUoUG9pbnRBdHRyaWJ1dGVOYW1lLk5PUk1BTF9TUEhFUkVNQVBQRUQsIFBPSU5UX0FUVFJJQlVURV9UWVBFUy5EQVRBX1RZUEVfVUlOVDgsIDIpLFxcXFxuICAgIE5PUk1BTF9PQ1QxNjogbWFrZVBvaW50QXR0cmlidXRlKFBvaW50QXR0cmlidXRlTmFtZS5OT1JNQUxfT0NUMTYsIFBPSU5UX0FUVFJJQlVURV9UWVBFUy5EQVRBX1RZUEVfVUlOVDgsIDIpLFxcXFxuICAgIE5PUk1BTDogbWFrZVBvaW50QXR0cmlidXRlKFBvaW50QXR0cmlidXRlTmFtZS5OT1JNQUwsIFBPSU5UX0FUVFJJQlVURV9UWVBFUy5EQVRBX1RZUEVfRkxPQVQsIDMpLFxcXFxufTtcXFxcbmNsYXNzIFBvaW50QXR0cmlidXRlcyB7XFxcXG4gICAgY29uc3RydWN0b3IocG9pbnRBdHRyaWJ1dGVOYW1lcyA9IFtdKSB7XFxcXG4gICAgICAgIHRoaXMuYXR0cmlidXRlcyA9IFtdO1xcXFxuICAgICAgICB0aGlzLmJ5dGVTaXplID0gMDtcXFxcbiAgICAgICAgdGhpcy5zaXplID0gMDtcXFxcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludEF0dHJpYnV0ZU5hbWVzLmxlbmd0aDsgaSsrKSB7XFxcXG4gICAgICAgICAgICBjb25zdCBwb2ludEF0dHJpYnV0ZU5hbWUgPSBwb2ludEF0dHJpYnV0ZU5hbWVzW2ldO1xcXFxuICAgICAgICAgICAgY29uc3QgcG9pbnRBdHRyaWJ1dGUgPSBQT0lOVF9BVFRSSUJVVEVTW3BvaW50QXR0cmlidXRlTmFtZV07XFxcXG4gICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZXMucHVzaChwb2ludEF0dHJpYnV0ZSk7XFxcXG4gICAgICAgICAgICB0aGlzLmJ5dGVTaXplICs9IHBvaW50QXR0cmlidXRlLmJ5dGVTaXplO1xcXFxuICAgICAgICAgICAgdGhpcy5zaXplKys7XFxcXG4gICAgICAgIH1cXFxcbiAgICB9XFxcXG4gICAgYWRkKHBvaW50QXR0cmlidXRlKSB7XFxcXG4gICAgICAgIHRoaXMuYXR0cmlidXRlcy5wdXNoKHBvaW50QXR0cmlidXRlKTtcXFxcbiAgICAgICAgdGhpcy5ieXRlU2l6ZSArPSBwb2ludEF0dHJpYnV0ZS5ieXRlU2l6ZTtcXFxcbiAgICAgICAgdGhpcy5zaXplKys7XFxcXG4gICAgfVxcXFxuICAgIGhhc0NvbG9ycygpIHtcXFxcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlcy5maW5kKGlzQ29sb3JBdHRyaWJ1dGUpICE9PSB1bmRlZmluZWQ7XFxcXG4gICAgfVxcXFxuICAgIGhhc05vcm1hbHMoKSB7XFxcXG4gICAgICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZXMuZmluZChpc05vcm1hbEF0dHJpYnV0ZSkgIT09IHVuZGVmaW5lZDtcXFxcbiAgICB9XFxcXG59XFxcXG5mdW5jdGlvbiBpc0NvbG9yQXR0cmlidXRlKHsgbmFtZSB9KSB7XFxcXG4gICAgcmV0dXJuIG5hbWUgPT09IFBvaW50QXR0cmlidXRlTmFtZS5DT0xPUl9QQUNLRUQ7XFxcXG59XFxcXG5mdW5jdGlvbiBpc05vcm1hbEF0dHJpYnV0ZSh7IG5hbWUgfSkge1xcXFxuICAgIHJldHVybiAobmFtZSA9PT0gUG9pbnRBdHRyaWJ1dGVOYW1lLk5PUk1BTF9TUEhFUkVNQVBQRUQgfHxcXFxcbiAgICAgICAgbmFtZSA9PT0gUG9pbnRBdHRyaWJ1dGVOYW1lLk5PUk1BTF9GTE9BVFMgfHxcXFxcbiAgICAgICAgbmFtZSA9PT0gUG9pbnRBdHRyaWJ1dGVOYW1lLk5PUk1BTCB8fFxcXFxuICAgICAgICBuYW1lID09PSBQb2ludEF0dHJpYnV0ZU5hbWUuTk9STUFMX09DVDE2KTtcXFxcbn1cXFxcblxcXFxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3ZlcnNpb24udHNcXFxcbmNsYXNzIFZlcnNpb24ge1xcXFxuICAgIGNvbnN0cnVjdG9yKHZlcnNpb24pIHtcXFxcbiAgICAgICAgdGhpcy52ZXJzaW9uTWlub3IgPSAwO1xcXFxuICAgICAgICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xcXFxuICAgICAgICBjb25zdCB2bUxlbmd0aCA9IHZlcnNpb24uaW5kZXhPZihcXFxcJy5cXFxcJykgPT09IC0xID8gdmVyc2lvbi5sZW5ndGggOiB2ZXJzaW9uLmluZGV4T2YoXFxcXCcuXFxcXCcpO1xcXFxuICAgICAgICB0aGlzLnZlcnNpb25NYWpvciA9IHBhcnNlSW50KHZlcnNpb24uc3Vic3RyKDAsIHZtTGVuZ3RoKSwgMTApO1xcXFxuICAgICAgICB0aGlzLnZlcnNpb25NaW5vciA9IHBhcnNlSW50KHZlcnNpb24uc3Vic3RyKHZtTGVuZ3RoICsgMSksIDEwKTtcXFxcbiAgICAgICAgaWYgKGlzTmFOKHRoaXMudmVyc2lvbk1pbm9yKSkge1xcXFxuICAgICAgICAgICAgdGhpcy52ZXJzaW9uTWlub3IgPSAwO1xcXFxuICAgICAgICB9XFxcXG4gICAgfVxcXFxuICAgIG5ld2VyVGhhbih2ZXJzaW9uKSB7XFxcXG4gICAgICAgIGNvbnN0IHYgPSBuZXcgVmVyc2lvbih2ZXJzaW9uKTtcXFxcbiAgICAgICAgaWYgKHRoaXMudmVyc2lvbk1ham9yID4gdi52ZXJzaW9uTWFqb3IpIHtcXFxcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xcXFxuICAgICAgICB9XFxcXG4gICAgICAgIGVsc2UgaWYgKHRoaXMudmVyc2lvbk1ham9yID09PSB2LnZlcnNpb25NYWpvciAmJiB0aGlzLnZlcnNpb25NaW5vciA+IHYudmVyc2lvbk1pbm9yKSB7XFxcXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICBlbHNlIHtcXFxcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcXFxcbiAgICAgICAgfVxcXFxuICAgIH1cXFxcbiAgICBlcXVhbE9ySGlnaGVyKHZlcnNpb24pIHtcXFxcbiAgICAgICAgY29uc3QgdiA9IG5ldyBWZXJzaW9uKHZlcnNpb24pO1xcXFxuICAgICAgICBpZiAodGhpcy52ZXJzaW9uTWFqb3IgPiB2LnZlcnNpb25NYWpvcikge1xcXFxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgZWxzZSBpZiAodGhpcy52ZXJzaW9uTWFqb3IgPT09IHYudmVyc2lvbk1ham9yICYmIHRoaXMudmVyc2lvbk1pbm9yID49IHYudmVyc2lvbk1pbm9yKSB7XFxcXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICBlbHNlIHtcXFxcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcXFxcbiAgICAgICAgfVxcXFxuICAgIH1cXFxcbiAgICB1cFRvKHZlcnNpb24pIHtcXFxcbiAgICAgICAgcmV0dXJuICF0aGlzLm5ld2VyVGhhbih2ZXJzaW9uKTtcXFxcbiAgICB9XFxcXG59XFxcXG5cXFxcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy93b3JrZXJzL2N1c3RvbS1hcnJheS12aWV3LnRzXFxcXG4vKipcXFxcbiAqIEFkYXB0ZWQgZnJvbSBQb3RyZWUuanMgaHR0cDovL3BvdHJlZS5vcmdcXFxcbiAqIFBvdHJlZSBMaWNlbnNlOiBodHRwczovL2dpdGh1Yi5jb20vcG90cmVlL3BvdHJlZS9ibG9iLzEuNS9MSUNFTlNFXFxcXG4gKi9cXFxcbi8vIGh0dHA6Ly9qc3BlcmYuY29tL3VpbnQ4YXJyYXktdnMtZGF0YXZpZXczLzNcXFxcbi8vIHRzbGludDpkaXNhYmxlOm5vLWJpdHdpc2VcXFxcbmNsYXNzIEN1c3RvbUFycmF5VmlldyB7XFxcXG4gICAgY29uc3RydWN0b3IoYnVmZmVyKSB7XFxcXG4gICAgICAgIHRoaXMudG1wID0gbmV3IEFycmF5QnVmZmVyKDQpO1xcXFxuICAgICAgICB0aGlzLnRtcGYgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMudG1wKTtcXFxcbiAgICAgICAgdGhpcy50bXB1OCA9IG5ldyBVaW50OEFycmF5KHRoaXMudG1wKTtcXFxcbiAgICAgICAgdGhpcy51OCA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XFxcXG4gICAgfVxcXFxuICAgIGdldFVpbnQzMihpKSB7XFxcXG4gICAgICAgIHJldHVybiAodGhpcy51OFtpICsgM10gPDwgMjQpIHwgKHRoaXMudThbaSArIDJdIDw8IDE2KSB8ICh0aGlzLnU4W2kgKyAxXSA8PCA4KSB8IHRoaXMudThbaV07XFxcXG4gICAgfVxcXFxuICAgIGdldFVpbnQxNihpKSB7XFxcXG4gICAgICAgIHJldHVybiAodGhpcy51OFtpICsgMV0gPDwgOCkgfCB0aGlzLnU4W2ldO1xcXFxuICAgIH1cXFxcbiAgICBnZXRGbG9hdDMyKGkpIHtcXFxcbiAgICAgICAgY29uc3QgdG1wdTggPSB0aGlzLnRtcHU4O1xcXFxuICAgICAgICBjb25zdCB1OCA9IHRoaXMudTg7XFxcXG4gICAgICAgIGNvbnN0IHRtcGYgPSB0aGlzLnRtcGY7XFxcXG4gICAgICAgIHRtcHU4WzBdID0gdThbaSArIDBdO1xcXFxuICAgICAgICB0bXB1OFsxXSA9IHU4W2kgKyAxXTtcXFxcbiAgICAgICAgdG1wdThbMl0gPSB1OFtpICsgMl07XFxcXG4gICAgICAgIHRtcHU4WzNdID0gdThbaSArIDNdO1xcXFxuICAgICAgICByZXR1cm4gdG1wZlswXTtcXFxcbiAgICB9XFxcXG4gICAgZ2V0VWludDgoaSkge1xcXFxuICAgICAgICByZXR1cm4gdGhpcy51OFtpXTtcXFxcbiAgICB9XFxcXG59XFxcXG4vLyB0c2xpbnQ6ZW5hYmxlOm5vLWJpdHdpc2VcXFxcblxcXFxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3dvcmtlcnMvYmluYXJ5LWRlY29kZXItd29ya2VyLWludGVybmFsLnRzXFxcXG4vKipcXFxcbiAqIEFkYXB0ZWQgZnJvbSBQb3RyZWUuanMgaHR0cDovL3BvdHJlZS5vcmdcXFxcbiAqIFBvdHJlZSBMaWNlbnNlOiBodHRwczovL2dpdGh1Yi5jb20vcG90cmVlL3BvdHJlZS9ibG9iLzEuNS9MSUNFTlNFXFxcXG4gKi9cXFxcblxcXFxuXFxcXG5cXFxcbi8vIElFMTEgZG9lcyBub3QgaGF2ZSBNYXRoLnNpZ24oKSwgdGhpcyBoYXMgYmVlbiBhZGFwdGVkIGZyb20gQ29yZUpTIGVzNi5tYXRoLnNpZ24uanMgZm9yIFR5cGVTY3JpcHRcXFxcbmNvbnN0IG1hdGhTaWduID0gTWF0aC5zaWduIHx8XFxcXG4gICAgZnVuY3Rpb24gKHgpIHtcXFxcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOnRyaXBsZS1lcXVhbHNcXFxcbiAgICAgICAgcmV0dXJuICh4ID0gK3gpID09IDAgfHwgeCAhPSB4ID8geCA6IHggPCAwID8gLTEgOiAxO1xcXFxuICAgIH07XFxcXG5mdW5jdGlvbiBoYW5kbGVNZXNzYWdlKGV2ZW50KSB7XFxcXG4gICAgY29uc3QgYnVmZmVyID0gZXZlbnQuZGF0YS5idWZmZXI7XFxcXG4gICAgY29uc3QgcG9pbnRBdHRyaWJ1dGVzID0gZXZlbnQuZGF0YS5wb2ludEF0dHJpYnV0ZXM7XFxcXG4gICAgY29uc3QgY3R4ID0ge1xcXFxuICAgICAgICBhdHRyaWJ1dGVCdWZmZXJzOiB7fSxcXFxcbiAgICAgICAgY3VycmVudE9mZnNldDogMCxcXFxcbiAgICAgICAgZGF0YTogbmV3IEN1c3RvbUFycmF5VmlldyhidWZmZXIpLFxcXFxuICAgICAgICBtZWFuOiBbMCwgMCwgMF0sXFxcXG4gICAgICAgIG5vZGVPZmZzZXQ6IGV2ZW50LmRhdGEub2Zmc2V0LFxcXFxuICAgICAgICBudW1Qb2ludHM6IGV2ZW50LmRhdGEuYnVmZmVyLmJ5dGVMZW5ndGggLyBwb2ludEF0dHJpYnV0ZXMuYnl0ZVNpemUsXFxcXG4gICAgICAgIHBvaW50QXR0cmlidXRlcyxcXFxcbiAgICAgICAgc2NhbGU6IGV2ZW50LmRhdGEuc2NhbGUsXFxcXG4gICAgICAgIHRpZ2h0Qm94TWF4OiBbTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLCBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFksIE51bWJlci5ORUdBVElWRV9JTkZJTklUWV0sXFxcXG4gICAgICAgIHRpZ2h0Qm94TWluOiBbTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksIE51bWJlci5QT1NJVElWRV9JTkZJTklUWV0sXFxcXG4gICAgICAgIHRyYW5zZmVyYWJsZXM6IFtdLFxcXFxuICAgICAgICB2ZXJzaW9uOiBuZXcgVmVyc2lvbihldmVudC5kYXRhLnZlcnNpb24pLFxcXFxuICAgIH07XFxcXG4gICAgZm9yIChjb25zdCBwb2ludEF0dHJpYnV0ZSBvZiBjdHgucG9pbnRBdHRyaWJ1dGVzLmF0dHJpYnV0ZXMpIHtcXFxcbiAgICAgICAgZGVjb2RlQW5kQWRkQXR0cmlidXRlKHBvaW50QXR0cmlidXRlLCBjdHgpO1xcXFxuICAgICAgICBjdHguY3VycmVudE9mZnNldCArPSBwb2ludEF0dHJpYnV0ZS5ieXRlU2l6ZTtcXFxcbiAgICB9XFxcXG4gICAgY29uc3QgaW5kaWNlcyA9IG5ldyBBcnJheUJ1ZmZlcihjdHgubnVtUG9pbnRzICogNCk7XFxcXG4gICAgY29uc3QgaUluZGljZXMgPSBuZXcgVWludDMyQXJyYXkoaW5kaWNlcyk7XFxcXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdHgubnVtUG9pbnRzOyBpKyspIHtcXFxcbiAgICAgICAgaUluZGljZXNbaV0gPSBpO1xcXFxuICAgIH1cXFxcbiAgICBpZiAoIWN0eC5hdHRyaWJ1dGVCdWZmZXJzW1BvaW50QXR0cmlidXRlTmFtZS5DTEFTU0lGSUNBVElPTl0pIHtcXFxcbiAgICAgICAgYWRkRW1wdHlDbGFzc2lmaWNhdGlvbkJ1ZmZlcihjdHgpO1xcXFxuICAgIH1cXFxcbiAgICBjb25zdCBtZXNzYWdlID0ge1xcXFxuICAgICAgICBidWZmZXI6IGJ1ZmZlcixcXFxcbiAgICAgICAgbWVhbjogY3R4Lm1lYW4sXFxcXG4gICAgICAgIGF0dHJpYnV0ZUJ1ZmZlcnM6IGN0eC5hdHRyaWJ1dGVCdWZmZXJzLFxcXFxuICAgICAgICB0aWdodEJvdW5kaW5nQm94OiB7IG1pbjogY3R4LnRpZ2h0Qm94TWluLCBtYXg6IGN0eC50aWdodEJveE1heCB9LFxcXFxuICAgICAgICBpbmRpY2VzLFxcXFxuICAgIH07XFxcXG4gICAgcG9zdE1lc3NhZ2UobWVzc2FnZSwgY3R4LnRyYW5zZmVyYWJsZXMpO1xcXFxufVxcXFxuZnVuY3Rpb24gYWRkRW1wdHlDbGFzc2lmaWNhdGlvbkJ1ZmZlcihjdHgpIHtcXFxcbiAgICBjb25zdCBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoY3R4Lm51bVBvaW50cyAqIDQpO1xcXFxuICAgIGNvbnN0IGNsYXNzaWZpY2F0aW9ucyA9IG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyKTtcXFxcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN0eC5udW1Qb2ludHM7IGkrKykge1xcXFxuICAgICAgICBjbGFzc2lmaWNhdGlvbnNbaV0gPSAwO1xcXFxuICAgIH1cXFxcbiAgICBjdHguYXR0cmlidXRlQnVmZmVyc1tQb2ludEF0dHJpYnV0ZU5hbWUuQ0xBU1NJRklDQVRJT05dID0ge1xcXFxuICAgICAgICBidWZmZXIsXFxcXG4gICAgICAgIGF0dHJpYnV0ZTogUE9JTlRfQVRUUklCVVRFUy5DTEFTU0lGSUNBVElPTixcXFxcbiAgICB9O1xcXFxufVxcXFxuZnVuY3Rpb24gZGVjb2RlQW5kQWRkQXR0cmlidXRlKGF0dHJpYnV0ZSwgY3R4KSB7XFxcXG4gICAgY29uc3QgZGVjb2RlZEF0dHJpYnV0ZSA9IGRlY29kZVBvaW50QXR0cmlidXRlKGF0dHJpYnV0ZSwgY3R4KTtcXFxcbiAgICBpZiAoZGVjb2RlZEF0dHJpYnV0ZSA9PT0gdW5kZWZpbmVkKSB7XFxcXG4gICAgICAgIHJldHVybjtcXFxcbiAgICB9XFxcXG4gICAgY3R4LmF0dHJpYnV0ZUJ1ZmZlcnNbZGVjb2RlZEF0dHJpYnV0ZS5hdHRyaWJ1dGUubmFtZV0gPSBkZWNvZGVkQXR0cmlidXRlO1xcXFxuICAgIGN0eC50cmFuc2ZlcmFibGVzLnB1c2goZGVjb2RlZEF0dHJpYnV0ZS5idWZmZXIpO1xcXFxufVxcXFxuZnVuY3Rpb24gZGVjb2RlUG9pbnRBdHRyaWJ1dGUoYXR0cmlidXRlLCBjdHgpIHtcXFxcbiAgICBzd2l0Y2ggKGF0dHJpYnV0ZS5uYW1lKSB7XFxcXG4gICAgICAgIGNhc2UgUG9pbnRBdHRyaWJ1dGVOYW1lLlBPU0lUSU9OX0NBUlRFU0lBTjpcXFxcbiAgICAgICAgICAgIHJldHVybiBkZWNvZGVQb3NpdGlvbkNhcnRlc2lhbihhdHRyaWJ1dGUsIGN0eCk7XFxcXG4gICAgICAgIGNhc2UgUG9pbnRBdHRyaWJ1dGVOYW1lLkNPTE9SX1BBQ0tFRDpcXFxcbiAgICAgICAgICAgIHJldHVybiBkZWNvZGVDb2xvcihhdHRyaWJ1dGUsIGN0eCk7XFxcXG4gICAgICAgIGNhc2UgUG9pbnRBdHRyaWJ1dGVOYW1lLklOVEVOU0lUWTpcXFxcbiAgICAgICAgICAgIHJldHVybiBkZWNvZGVJbnRlbnNpdHkoYXR0cmlidXRlLCBjdHgpO1xcXFxuICAgICAgICBjYXNlIFBvaW50QXR0cmlidXRlTmFtZS5DTEFTU0lGSUNBVElPTjpcXFxcbiAgICAgICAgICAgIHJldHVybiBkZWNvZGVDbGFzc2lmaWNhdGlvbihhdHRyaWJ1dGUsIGN0eCk7XFxcXG4gICAgICAgIGNhc2UgUG9pbnRBdHRyaWJ1dGVOYW1lLk5PUk1BTF9TUEhFUkVNQVBQRUQ6XFxcXG4gICAgICAgICAgICByZXR1cm4gZGVjb2RlTm9ybWFsU3BoZXJlTWFwcGVkKGF0dHJpYnV0ZSwgY3R4KTtcXFxcbiAgICAgICAgY2FzZSBQb2ludEF0dHJpYnV0ZU5hbWUuTk9STUFMX09DVDE2OlxcXFxuICAgICAgICAgICAgcmV0dXJuIGRlY29kZU5vcm1hbE9jdDE2KGF0dHJpYnV0ZSwgY3R4KTtcXFxcbiAgICAgICAgY2FzZSBQb2ludEF0dHJpYnV0ZU5hbWUuTk9STUFMOlxcXFxuICAgICAgICAgICAgcmV0dXJuIGRlY29kZU5vcm1hbChhdHRyaWJ1dGUsIGN0eCk7XFxcXG4gICAgICAgIGRlZmF1bHQ6XFxcXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xcXFxuICAgIH1cXFxcbn1cXFxcbmZ1bmN0aW9uIGRlY29kZVBvc2l0aW9uQ2FydGVzaWFuKGF0dHJpYnV0ZSwgY3R4KSB7XFxcXG4gICAgY29uc3QgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGN0eC5udW1Qb2ludHMgKiA0ICogMyk7XFxcXG4gICAgY29uc3QgcG9zaXRpb25zID0gbmV3IEZsb2F0MzJBcnJheShidWZmZXIpO1xcXFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3R4Lm51bVBvaW50czsgaSsrKSB7XFxcXG4gICAgICAgIGxldCB4O1xcXFxuICAgICAgICBsZXQgeTtcXFxcbiAgICAgICAgbGV0IHo7XFxcXG4gICAgICAgIGlmIChjdHgudmVyc2lvbi5uZXdlclRoYW4oXFxcXCcxLjNcXFxcJykpIHtcXFxcbiAgICAgICAgICAgIHggPSBjdHguZGF0YS5nZXRVaW50MzIoY3R4LmN1cnJlbnRPZmZzZXQgKyBpICogY3R4LnBvaW50QXR0cmlidXRlcy5ieXRlU2l6ZSArIDApICogY3R4LnNjYWxlO1xcXFxuICAgICAgICAgICAgeSA9IGN0eC5kYXRhLmdldFVpbnQzMihjdHguY3VycmVudE9mZnNldCArIGkgKiBjdHgucG9pbnRBdHRyaWJ1dGVzLmJ5dGVTaXplICsgNCkgKiBjdHguc2NhbGU7XFxcXG4gICAgICAgICAgICB6ID0gY3R4LmRhdGEuZ2V0VWludDMyKGN0eC5jdXJyZW50T2Zmc2V0ICsgaSAqIGN0eC5wb2ludEF0dHJpYnV0ZXMuYnl0ZVNpemUgKyA4KSAqIGN0eC5zY2FsZTtcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICBlbHNlIHtcXFxcbiAgICAgICAgICAgIHggPSBjdHguZGF0YS5nZXRGbG9hdDMyKGkgKiBjdHgucG9pbnRBdHRyaWJ1dGVzLmJ5dGVTaXplICsgMCkgKyBjdHgubm9kZU9mZnNldFswXTtcXFxcbiAgICAgICAgICAgIHkgPSBjdHguZGF0YS5nZXRGbG9hdDMyKGkgKiBjdHgucG9pbnRBdHRyaWJ1dGVzLmJ5dGVTaXplICsgNCkgKyBjdHgubm9kZU9mZnNldFsxXTtcXFxcbiAgICAgICAgICAgIHogPSBjdHguZGF0YS5nZXRGbG9hdDMyKGkgKiBjdHgucG9pbnRBdHRyaWJ1dGVzLmJ5dGVTaXplICsgOCkgKyBjdHgubm9kZU9mZnNldFsyXTtcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICBwb3NpdGlvbnNbMyAqIGkgKyAwXSA9IHg7XFxcXG4gICAgICAgIHBvc2l0aW9uc1szICogaSArIDFdID0geTtcXFxcbiAgICAgICAgcG9zaXRpb25zWzMgKiBpICsgMl0gPSB6O1xcXFxuICAgICAgICBjdHgubWVhblswXSArPSB4IC8gY3R4Lm51bVBvaW50cztcXFxcbiAgICAgICAgY3R4Lm1lYW5bMV0gKz0geSAvIGN0eC5udW1Qb2ludHM7XFxcXG4gICAgICAgIGN0eC5tZWFuWzJdICs9IHogLyBjdHgubnVtUG9pbnRzO1xcXFxuICAgICAgICBjdHgudGlnaHRCb3hNaW5bMF0gPSBNYXRoLm1pbihjdHgudGlnaHRCb3hNaW5bMF0sIHgpO1xcXFxuICAgICAgICBjdHgudGlnaHRCb3hNaW5bMV0gPSBNYXRoLm1pbihjdHgudGlnaHRCb3hNaW5bMV0sIHkpO1xcXFxuICAgICAgICBjdHgudGlnaHRCb3hNaW5bMl0gPSBNYXRoLm1pbihjdHgudGlnaHRCb3hNaW5bMl0sIHopO1xcXFxuICAgICAgICBjdHgudGlnaHRCb3hNYXhbMF0gPSBNYXRoLm1heChjdHgudGlnaHRCb3hNYXhbMF0sIHgpO1xcXFxuICAgICAgICBjdHgudGlnaHRCb3hNYXhbMV0gPSBNYXRoLm1heChjdHgudGlnaHRCb3hNYXhbMV0sIHkpO1xcXFxuICAgICAgICBjdHgudGlnaHRCb3hNYXhbMl0gPSBNYXRoLm1heChjdHgudGlnaHRCb3hNYXhbMl0sIHopO1xcXFxuICAgIH1cXFxcbiAgICByZXR1cm4geyBidWZmZXIsIGF0dHJpYnV0ZSB9O1xcXFxufVxcXFxuZnVuY3Rpb24gZGVjb2RlQ29sb3IoYXR0cmlidXRlLCBjdHgpIHtcXFxcbiAgICBjb25zdCBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoY3R4Lm51bVBvaW50cyAqIDMpO1xcXFxuICAgIGNvbnN0IGNvbG9ycyA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XFxcXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdHgubnVtUG9pbnRzOyBpKyspIHtcXFxcbiAgICAgICAgY29sb3JzWzMgKiBpICsgMF0gPSBjdHguZGF0YS5nZXRVaW50OChjdHguY3VycmVudE9mZnNldCArIGkgKiBjdHgucG9pbnRBdHRyaWJ1dGVzLmJ5dGVTaXplICsgMCk7XFxcXG4gICAgICAgIGNvbG9yc1szICogaSArIDFdID0gY3R4LmRhdGEuZ2V0VWludDgoY3R4LmN1cnJlbnRPZmZzZXQgKyBpICogY3R4LnBvaW50QXR0cmlidXRlcy5ieXRlU2l6ZSArIDEpO1xcXFxuICAgICAgICBjb2xvcnNbMyAqIGkgKyAyXSA9IGN0eC5kYXRhLmdldFVpbnQ4KGN0eC5jdXJyZW50T2Zmc2V0ICsgaSAqIGN0eC5wb2ludEF0dHJpYnV0ZXMuYnl0ZVNpemUgKyAyKTtcXFxcbiAgICB9XFxcXG4gICAgcmV0dXJuIHsgYnVmZmVyLCBhdHRyaWJ1dGUgfTtcXFxcbn1cXFxcbmZ1bmN0aW9uIGRlY29kZUludGVuc2l0eShhdHRyaWJ1dGUsIGN0eCkge1xcXFxuICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihjdHgubnVtUG9pbnRzICogNCk7XFxcXG4gICAgY29uc3QgaW50ZW5zaXRpZXMgPSBuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlcik7XFxcXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdHgubnVtUG9pbnRzOyBpKyspIHtcXFxcbiAgICAgICAgaW50ZW5zaXRpZXNbaV0gPSBjdHguZGF0YS5nZXRVaW50MTYoY3R4LmN1cnJlbnRPZmZzZXQgKyBpICogY3R4LnBvaW50QXR0cmlidXRlcy5ieXRlU2l6ZSk7XFxcXG4gICAgfVxcXFxuICAgIHJldHVybiB7IGJ1ZmZlciwgYXR0cmlidXRlIH07XFxcXG59XFxcXG5mdW5jdGlvbiBkZWNvZGVDbGFzc2lmaWNhdGlvbihhdHRyaWJ1dGUsIGN0eCkge1xcXFxuICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihjdHgubnVtUG9pbnRzKTtcXFxcbiAgICBjb25zdCBjbGFzc2lmaWNhdGlvbnMgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xcXFxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgY3R4Lm51bVBvaW50czsgaisrKSB7XFxcXG4gICAgICAgIGNsYXNzaWZpY2F0aW9uc1tqXSA9IGN0eC5kYXRhLmdldFVpbnQ4KGN0eC5jdXJyZW50T2Zmc2V0ICsgaiAqIGN0eC5wb2ludEF0dHJpYnV0ZXMuYnl0ZVNpemUpO1xcXFxuICAgIH1cXFxcbiAgICByZXR1cm4geyBidWZmZXIsIGF0dHJpYnV0ZSB9O1xcXFxufVxcXFxuZnVuY3Rpb24gZGVjb2RlTm9ybWFsU3BoZXJlTWFwcGVkKGF0dHJpYnV0ZSwgY3R4KSB7XFxcXG4gICAgY29uc3QgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGN0eC5udW1Qb2ludHMgKiA0ICogMyk7XFxcXG4gICAgY29uc3Qgbm9ybWFscyA9IG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyKTtcXFxcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGN0eC5udW1Qb2ludHM7IGorKykge1xcXFxuICAgICAgICBjb25zdCBieCA9IGN0eC5kYXRhLmdldFVpbnQ4KGN0eC5jdXJyZW50T2Zmc2V0ICsgaiAqIGN0eC5wb2ludEF0dHJpYnV0ZXMuYnl0ZVNpemUgKyAwKTtcXFxcbiAgICAgICAgY29uc3QgYnkgPSBjdHguZGF0YS5nZXRVaW50OChjdHguY3VycmVudE9mZnNldCArIGogKiBjdHgucG9pbnRBdHRyaWJ1dGVzLmJ5dGVTaXplICsgMSk7XFxcXG4gICAgICAgIGNvbnN0IGV4ID0gYnggLyAyNTU7XFxcXG4gICAgICAgIGNvbnN0IGV5ID0gYnkgLyAyNTU7XFxcXG4gICAgICAgIGxldCBueCA9IGV4ICogMiAtIDE7XFxcXG4gICAgICAgIGxldCBueSA9IGV5ICogMiAtIDE7XFxcXG4gICAgICAgIGxldCBueiA9IDE7XFxcXG4gICAgICAgIGNvbnN0IG53ID0gLTE7XFxcXG4gICAgICAgIGNvbnN0IGwgPSBueCAqIC1ueCArIG55ICogLW55ICsgbnogKiAtbnc7XFxcXG4gICAgICAgIG56ID0gbDtcXFxcbiAgICAgICAgbnggPSBueCAqIE1hdGguc3FydChsKTtcXFxcbiAgICAgICAgbnkgPSBueSAqIE1hdGguc3FydChsKTtcXFxcbiAgICAgICAgbnggPSBueCAqIDI7XFxcXG4gICAgICAgIG55ID0gbnkgKiAyO1xcXFxuICAgICAgICBueiA9IG56ICogMiAtIDE7XFxcXG4gICAgICAgIG5vcm1hbHNbMyAqIGogKyAwXSA9IG54O1xcXFxuICAgICAgICBub3JtYWxzWzMgKiBqICsgMV0gPSBueTtcXFxcbiAgICAgICAgbm9ybWFsc1szICogaiArIDJdID0gbno7XFxcXG4gICAgfVxcXFxuICAgIHJldHVybiB7IGJ1ZmZlciwgYXR0cmlidXRlIH07XFxcXG59XFxcXG5mdW5jdGlvbiBkZWNvZGVOb3JtYWxPY3QxNihhdHRyaWJ1dGUsIGN0eCkge1xcXFxuICAgIGNvbnN0IGJ1ZmYgPSBuZXcgQXJyYXlCdWZmZXIoY3R4Lm51bVBvaW50cyAqIDQgKiAzKTtcXFxcbiAgICBjb25zdCBub3JtYWxzID0gbmV3IEZsb2F0MzJBcnJheShidWZmKTtcXFxcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGN0eC5udW1Qb2ludHM7IGorKykge1xcXFxuICAgICAgICBjb25zdCBieCA9IGN0eC5kYXRhLmdldFVpbnQ4KGN0eC5jdXJyZW50T2Zmc2V0ICsgaiAqIGN0eC5wb2ludEF0dHJpYnV0ZXMuYnl0ZVNpemUgKyAwKTtcXFxcbiAgICAgICAgY29uc3QgYnkgPSBjdHguZGF0YS5nZXRVaW50OChjdHguY3VycmVudE9mZnNldCArIGogKiBjdHgucG9pbnRBdHRyaWJ1dGVzLmJ5dGVTaXplICsgMSk7XFxcXG4gICAgICAgIGNvbnN0IHUgPSAoYnggLyAyNTUpICogMiAtIDE7XFxcXG4gICAgICAgIGNvbnN0IHYgPSAoYnkgLyAyNTUpICogMiAtIDE7XFxcXG4gICAgICAgIGxldCB6ID0gMSAtIE1hdGguYWJzKHUpIC0gTWF0aC5hYnModik7XFxcXG4gICAgICAgIGxldCB4ID0gMDtcXFxcbiAgICAgICAgbGV0IHkgPSAwO1xcXFxuICAgICAgICBpZiAoeiA+PSAwKSB7XFxcXG4gICAgICAgICAgICB4ID0gdTtcXFxcbiAgICAgICAgICAgIHkgPSB2O1xcXFxuICAgICAgICB9XFxcXG4gICAgICAgIGVsc2Uge1xcXFxuICAgICAgICAgICAgeCA9IC0odiAvIG1hdGhTaWduKHYpIC0gMSkgLyBtYXRoU2lnbih1KTtcXFxcbiAgICAgICAgICAgIHkgPSAtKHUgLyBtYXRoU2lnbih1KSAtIDEpIC8gbWF0aFNpZ24odik7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkgKyB6ICogeik7XFxcXG4gICAgICAgIHggPSB4IC8gbGVuZ3RoO1xcXFxuICAgICAgICB5ID0geSAvIGxlbmd0aDtcXFxcbiAgICAgICAgeiA9IHogLyBsZW5ndGg7XFxcXG4gICAgICAgIG5vcm1hbHNbMyAqIGogKyAwXSA9IHg7XFxcXG4gICAgICAgIG5vcm1hbHNbMyAqIGogKyAxXSA9IHk7XFxcXG4gICAgICAgIG5vcm1hbHNbMyAqIGogKyAyXSA9IHo7XFxcXG4gICAgfVxcXFxuICAgIHJldHVybiB7IGJ1ZmZlcjogYnVmZiwgYXR0cmlidXRlIH07XFxcXG59XFxcXG5mdW5jdGlvbiBkZWNvZGVOb3JtYWwoYXR0cmlidXRlLCBjdHgpIHtcXFxcbiAgICBjb25zdCBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoY3R4Lm51bVBvaW50cyAqIDQgKiAzKTtcXFxcbiAgICBjb25zdCBub3JtYWxzID0gbmV3IEZsb2F0MzJBcnJheShidWZmZXIpO1xcXFxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgY3R4Lm51bVBvaW50czsgaisrKSB7XFxcXG4gICAgICAgIGNvbnN0IHggPSBjdHguZGF0YS5nZXRGbG9hdDMyKGN0eC5jdXJyZW50T2Zmc2V0ICsgaiAqIGN0eC5wb2ludEF0dHJpYnV0ZXMuYnl0ZVNpemUgKyAwKTtcXFxcbiAgICAgICAgY29uc3QgeSA9IGN0eC5kYXRhLmdldEZsb2F0MzIoY3R4LmN1cnJlbnRPZmZzZXQgKyBqICogY3R4LnBvaW50QXR0cmlidXRlcy5ieXRlU2l6ZSArIDQpO1xcXFxuICAgICAgICBjb25zdCB6ID0gY3R4LmRhdGEuZ2V0RmxvYXQzMihjdHguY3VycmVudE9mZnNldCArIGogKiBjdHgucG9pbnRBdHRyaWJ1dGVzLmJ5dGVTaXplICsgOCk7XFxcXG4gICAgICAgIG5vcm1hbHNbMyAqIGogKyAwXSA9IHg7XFxcXG4gICAgICAgIG5vcm1hbHNbMyAqIGogKyAxXSA9IHk7XFxcXG4gICAgICAgIG5vcm1hbHNbMyAqIGogKyAyXSA9IHo7XFxcXG4gICAgfVxcXFxuICAgIHJldHVybiB7IGJ1ZmZlciwgYXR0cmlidXRlIH07XFxcXG59XFxcXG5cXFxcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4vc3JjL3dvcmtlcnMvYmluYXJ5LWRlY29kZXIud29ya2VyLmpzXFxcXG5cXFxcblxcXFxuLyplc2xpbnQtZGlzYWJsZSAqL1xcXFxub25tZXNzYWdlID0gaGFuZGxlTWVzc2FnZTsvLyMgc291cmNlVVJMPVttb2R1bGVdXFxcXG4nKX19LF9fd2VicGFja19leHBvcnRzX189e307X193ZWJwYWNrX21vZHVsZXNfX1s3MTddKCl9KSgpO1wiLCBcIldvcmtlclwiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///91\n')},512:module=>{eval('\n\n/* eslint-env browser */\n\n/* eslint-disable no-undef, no-use-before-define, new-cap */\nmodule.exports = function (content, workerConstructor, workerOptions, url) {\n  var globalScope = self || window;\n\n  try {\n    try {\n      var blob;\n\n      try {\n        // New API\n        blob = new globalScope.Blob([content]);\n      } catch (e) {\n        // BlobBuilder = Deprecated, but widely implemented\n        var BlobBuilder = globalScope.BlobBuilder || globalScope.WebKitBlobBuilder || globalScope.MozBlobBuilder || globalScope.MSBlobBuilder;\n        blob = new BlobBuilder();\n        blob.append(content);\n        blob = blob.getBlob();\n      }\n\n      var URL = globalScope.URL || globalScope.webkitURL;\n      var objectURL = URL.createObjectURL(blob);\n      var worker = new globalScope[workerConstructor](objectURL, workerOptions);\n      URL.revokeObjectURL(objectURL);\n      return worker;\n    } catch (e) {\n      return new globalScope[workerConstructor]("data:application/javascript,".concat(encodeURIComponent(content)), workerOptions);\n    }\n  } catch (e) {\n    if (!url) {\n      throw Error("Inline worker is not supported");\n    }\n\n    return new globalScope[workerConstructor](url, workerOptions);\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTEyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3BvdHJlZS8uL25vZGVfbW9kdWxlcy93b3JrZXItbG9hZGVyL2Rpc3QvcnVudGltZS9pbmxpbmUuanM/ZWNkNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVuZGVmLCBuby11c2UtYmVmb3JlLWRlZmluZSwgbmV3LWNhcCAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY29udGVudCwgd29ya2VyQ29uc3RydWN0b3IsIHdvcmtlck9wdGlvbnMsIHVybCkge1xuICB2YXIgZ2xvYmFsU2NvcGUgPSBzZWxmIHx8IHdpbmRvdztcblxuICB0cnkge1xuICAgIHRyeSB7XG4gICAgICB2YXIgYmxvYjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gTmV3IEFQSVxuICAgICAgICBibG9iID0gbmV3IGdsb2JhbFNjb3BlLkJsb2IoW2NvbnRlbnRdKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gQmxvYkJ1aWxkZXIgPSBEZXByZWNhdGVkLCBidXQgd2lkZWx5IGltcGxlbWVudGVkXG4gICAgICAgIHZhciBCbG9iQnVpbGRlciA9IGdsb2JhbFNjb3BlLkJsb2JCdWlsZGVyIHx8IGdsb2JhbFNjb3BlLldlYktpdEJsb2JCdWlsZGVyIHx8IGdsb2JhbFNjb3BlLk1vekJsb2JCdWlsZGVyIHx8IGdsb2JhbFNjb3BlLk1TQmxvYkJ1aWxkZXI7XG4gICAgICAgIGJsb2IgPSBuZXcgQmxvYkJ1aWxkZXIoKTtcbiAgICAgICAgYmxvYi5hcHBlbmQoY29udGVudCk7XG4gICAgICAgIGJsb2IgPSBibG9iLmdldEJsb2IoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIFVSTCA9IGdsb2JhbFNjb3BlLlVSTCB8fCBnbG9iYWxTY29wZS53ZWJraXRVUkw7XG4gICAgICB2YXIgb2JqZWN0VVJMID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgICAgIHZhciB3b3JrZXIgPSBuZXcgZ2xvYmFsU2NvcGVbd29ya2VyQ29uc3RydWN0b3JdKG9iamVjdFVSTCwgd29ya2VyT3B0aW9ucyk7XG4gICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKG9iamVjdFVSTCk7XG4gICAgICByZXR1cm4gd29ya2VyO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBuZXcgZ2xvYmFsU2NvcGVbd29ya2VyQ29uc3RydWN0b3JdKFwiZGF0YTphcHBsaWNhdGlvbi9qYXZhc2NyaXB0LFwiLmNvbmNhdChlbmNvZGVVUklDb21wb25lbnQoY29udGVudCkpLCB3b3JrZXJPcHRpb25zKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoIXVybCkge1xuICAgICAgdGhyb3cgRXJyb3IoXCJJbmxpbmUgd29ya2VyIGlzIG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBnbG9iYWxTY29wZVt3b3JrZXJDb25zdHJ1Y3Rvcl0odXJsLCB3b3JrZXJPcHRpb25zKTtcbiAgfVxufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///512\n')},604:g=>{g.exports=__WEBPACK_EXTERNAL_MODULE__604__}},__webpack_module_cache__={};function __webpack_require__(g){var I=__webpack_module_cache__[g];if(void 0!==I)return I.exports;var t=__webpack_module_cache__[g]={exports:{}};return __webpack_modules__[g](t,t.exports,__webpack_require__),t.exports}__webpack_require__.n=g=>{var I=g&&g.__esModule?()=>g.default:()=>g;return __webpack_require__.d(I,{a:I}),I},__webpack_require__.d=(g,I)=>{for(var t in I)__webpack_require__.o(I,t)&&!__webpack_require__.o(g,t)&&Object.defineProperty(g,t,{enumerable:!0,get:I[t]})},__webpack_require__.o=(g,I)=>Object.prototype.hasOwnProperty.call(g,I),__webpack_require__.r=g=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(g,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(g,"__esModule",{value:!0})};var __webpack_exports__=__webpack_require__(599);return __webpack_exports__})()));